<!DOCTYPE html>
<html lang="zh-CN">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="MIT 6.824 分布式系统课程- 实现Raft Lab3 K/V Server（Part A）" />
    <meta name="hexo-theme-A4" content="v1.9.8" />
    <link rel="alternate icon" type="image/webp" href="/img/20250602032635.jpg">
    <title>Yann | 我愿做你光华中淡淡的一笔</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery-bundle.min.css">


   
        
<link rel="stylesheet" href="/css/custom.css">

    

<meta name="generator" content="Hexo 5.4.0"></head>
    
    

    
    



    

    
    




    
    <style>
        :root {
            --waline-theme-color: #323e74; 
            --waline-color: #323e74; 
            --waline-border-color: #323e74; 
            --waline-white: #323e74; 
            --waline-bgcolor-light: #f2fafc;  
        }
        body {
            color: #323e74;
            background: #eaeae8;
        }
        .post-md code {
            background: #e7f7f3;
            color: #7f688d; 
        }
        .post-md pre, .post-md .highlight {
            background: #e7f7f3;
            color: #7f688d; 
        }
        pre .string, pre .value, pre .inheritance, pre .header, pre .ruby .symbol, pre .xml .cdata {
            color: #323e74;
        }
        pre .number, pre .preprocessor, pre .built_in, pre .literal, pre .params, pre .constant {
            color: #323e74;
        }
        .year-font-color {
            color: #323e74 !important;
        }
        .wl-card span.wl-nick {
            color: #323e74; 
        }
        .wl-card .wl-badge {
            border: 1px solid #323e74;
            color: #323e74; 
        }
        .wl-btn {
            border: 1px solid #323e74; 
            color:  #323e74;  
        }
        .wl-btn.primary {
            color: #f2fafc; 
        }
        .wl-header label {
            color: #323e74;
        }
        a {
            color: #7f688d;
        }

        .post-md a {
            color: #7f688d;
        }

        .nav li a {
            color: #7f688d;
        }

        .archive-main a:link {
            color: #7f688d;
        }
        .archive-main a:visited {
            color: #767c7c; 
        }

        .archive li span {
            color: #323e74;
        }

        .post-main-title {
            color: #323e74;
        }

        .post-md h1,
        .post-md h2,
        .post-md h3,
        .post-md h4,
        .post-md h5,
        .post-md h6 {
            color: #323e74;
        }

        [data-waline] p {
            color: #323e74;
        }
        [data-waline] a {
            color: #323e74;
        } 
        .wl-sort li.active {
            color: #323e74;
        }

        .wl-card .wl-meta>span {
            background: #f2fafc;
        }

        .paper {
            background: #eaeae8;
        }

        .index-main {
            background: #f2fafc;
        }

        .paper-main {
            background: #f2fafc;
        }

        .wl-panel {
            background: #f2fafc;
        }

        .archive li:nth-child(odd) {
            background: #f2fafc;
            ;
        }

        .archive li:nth-child(even) {
            background: #f2fafc;
        }

        .post-md table tr:nth-child(odd) td {
            background: #f2fafc;
        }

        .post-md table tr:nth-child(even) td {
            background: #f2fafc;
        }

    
        .progress-wrap::after {
            color: #323e74; /* 箭头的颜色 */
        }
        .progress-wrap svg.progress-circle path {
	        stroke: #323e74; /* 边框的颜色 */
        }
        .progress-wrap::before {
	        background-image: linear-gradient(298deg, #7f688d, #7f688d); /* 鼠标滑过的箭头颜色 */
         }

        .return-to-last-progress-wrap::after {
            color: #323e74; /* 箭头的颜色 */
        }
        .return-to-last-progress-wrap svg.progress-circle path {
	        stroke: #323e74; /* 边框的颜色 */
        }
        .return-to-last-progress-wrap::before {
	        background-image: linear-gradient(298deg, #7f688d, #7f688d); /* 鼠标滑过的箭头颜色 */
         }

         .left-toc-container::-webkit-scrollbar-thumb {
            background-color: #323e74; /* 设置滚动条拖动块的颜色 */
        }

        .bs-docs-sidebar .nav>.active>a,
        .bs-docs-sidebar .nav>li>a:hover,
        .bs-docs-sidebar .nav>li>a:focus {
            color: #7f688d;
            border-left-color: #7f688d;
        }
        .bs-docs-sidebar .nav>li>a {
            color:  #323e74;
        }
    </style>

    
    <style>
        body {
            background-image: url(/img/3.jpg);
            background-attachment: fixed;  /* 背景固定，不随页面滚动 */
            background-repeat: no-repeat;  /* 防止背景图片重复 */
            background-size: cover;       /* 背景自适应大小，覆盖整个背景 */
            background-position: center;   /* 背景居中显示 */
        }
        .paper {
            background-image: url(/img/3.jpg);
            background-attachment: fixed;  /* 背景固定，不随页面滚动 */
            background-repeat: no-repeat;  /* 防止背景图片重复 */
            background-size: cover;       /* 背景自适应大小，覆盖整个背景 */
            background-position: center;   /* 背景居中显示 */
        }  
    </style>


    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        <script>
            const options = {
                bottom: '40px', // default: '32px'
                right: 'unset', // default: '32px'
                left: '42px', // default: 'unset'
                time: '0.3s', // default: '0.3s'
                mixColor: '#fff', // default: '#fff'
                backgroundColor: ' #eaeae8  ',  // default: '#fff'
                buttonColorDark: '#100f2c',  // default: '#100f2c'
                buttonColorLight: '#fff', // default: '#fff'
                saveInCookies: true, // default: true,
                label: '🌓', // default: ''
                autoMatchOsTheme: true // default: true
            }
            const darkmode = new Darkmode(options);
            darkmode.showWidget();
        </script>
        
        
            
                <div class="left-toc-container">
                    <nav id="toc" class="bs-docs-sidebar"></nav>
                </div>
            
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <style>
            .header-img {
                width: 56px;
                height: auto;
                object-fit: cover; /* 保持图片比例 */
                transition: transform 0.3s ease-in-out; 
                border-radius: 0; 
            }
            
        </style>
        <img 
            alt="^-^" 
            cache-control="max-age=86400" 
            class="header-img" 
            src="/img/20250602032635.jpg" 
        />
        <div class="header-content">
            <a class="logo" href="/">Yann</a> 
            <span class="description">人工智能、计算机、机器学习、linux、程序员</span> 
        </div>
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/about/">关于</a></li>
            
        
            
                <li><a href="/tags/">标签</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">
    

    
        
            
                <div class="post-main-title" style="text-align: center;">
                    MIT 6.824 分布式系统课程- 实现Raft Lab3 K/V Server（Part A）
                </div>
            
        
      
    

    

        
            <div class="post-head-meta-center">
        
                
                    <span>最近更新：2021-08-06</span> 
                
                
                    
                        &nbsp; | &nbsp;
                    
                     <span>字数总计：2.1k</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span>阅读估时：9分钟</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span id="busuanzi_container_page_pv">
                        阅读量：<span id="busuanzi_value_page_pv"></span>次
                    </span>
                
            </div>
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">课程介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82"><span class="post-toc-text">实验要求</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="post-toc-text">流程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="post-toc-text">实现细节</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Client"><span class="post-toc-text">Client</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Server"><span class="post-toc-text">Server</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Snapshot%EF%BC%88Part-B%EF%BC%89"><span class="post-toc-text">Snapshot（Part B）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-1"><span class="post-toc-text">实验要求</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%B5%81%E7%A8%8B-1"><span class="post-toc-text">流程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82-1"><span class="post-toc-text">实现细节</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Server-1"><span class="post-toc-text">Server</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Raft"><span class="post-toc-text">Raft</span></a></li></ol></li></ol>
            
        
        <div class=".article-gallery"><span id="more"></span>
<h2 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a><strong>课程介绍</strong></h2><p>Distributed Systems课程一共包含Lab1-4共4个大作业，Lab1是实现Mapreduce原型，Lab2-4是实现Raft以及基于Raft实现分布式KV存储。</p>
<p>本次实现Raft，该实验（2020 年版本）分为三个部分，目标是开发一个容错的KV系统，分别是 Part 2A：leader 选举、Part 2B：日志同步、lab2C：状态备份。</p>
<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><ul>
<li>key 和 value 都是字符串；</li>
<li>服务支持三种操作：<ul>
<li><code>Put(key, value)</code>：替换<code>key</code>对应的<code>value</code>；</li>
<li><code>Append(key, arg)</code>：将<code>arg</code>附加到<code>key</code>对应到<code>value</code>，如果不存在则等同于<code>Put</code>；</li>
<li><code>Get(key)</code>：获取<code>key</code>对应的<code>value</code>，如果不存在返回空串；</li>
</ul>
</li>
<li>执行一个操作前，需要确保之前都操作都已经落实了；</li>
<li>如果一个操作成功被应用，则通知客户端，否则向客户端报告一个错误，客户端应该重试其他服务器；</li>
<li>服务器之间不应该直接通信，只能通过 Raft 交换信息；</li>
<li>可以不实现论文 Section 8 中关于只读操作不写 log 的优化，把 Get 也写 log，最终收到  Raft apply 响应时说明已经取得了大多数，此时就避免了读脏数据的可能；</li>
<li>可以不实现服务器主动返回 leader，而在客户端对服务器遍历来寻找 leader；</li>
<li>可能出现这样的情况：当请求操作后，对应的服务器失去领导，新的 leader 接受了其他客户端的操作并提交，原来的服务器将新 leader 反馈的提交应用了，从而造成请求和响应不一致。可以在响应时判断服务器的任期是否变更，或者检查所响应的操作是否和请求对应上；</li>
<li>可以在客户端中记录最后通信的 leader，下次通信时优先考虑，从而节约寻找 leader 的时间；</li>
<li>当发生分区时，允许服务器和客户端无限期等待，直到分区恢复；</li>
<li>Your scheme for duplicate detection should free server memory quickly, for example by having each RPC imply that the client has seen the reply for its previous RPC. It’s OK to assume that a client will make only one call into a Clerk at a time？？？</li>
</ul>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/kvraft.jpg" title="kvraft" class="gallery-item" style="box-shadow: none;"> <img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/kvraft.jpg" alt="kvraft"></a></p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>避免同一个操作被执行多次的策略：为每个客户端设置一个唯一 Id，同时每个命令也有一个唯一 Id，由于单个客户端的请求是串行的，服务端只需要记录每个客户端最后执行的命令 Id 即可。设客户端数量为 $N$，服务器执行的总命令数量为 $M$，可知 $M \gg N$，采用这种策略可以将空间复杂度从 $O(M)$ 降为 $O(N)$</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nServers; i++ &#123;</span><br><span class="line">      <span class="comment">// 因为 [reason0]，需要为每次调用都新建 args, reply</span></span><br><span class="line">			args := GetArgs&#123;key&#125; <span class="comment">// 因为 Get 不更改状态，不用确保只执行一次，所以不绑定唯一 Id</span></span><br><span class="line">			reply := GetReply&#123;&#125;</span><br><span class="line">			ck.servers[ck.leader].Call(<span class="string">&quot;KVServer.Get&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>由于只有 Leader 会接受用户请求，而 Follower 也需要同步状态，所以对 Raft 返回的 Command 进行 apply 应该作为一个后台 goroutine 自动循环 apply</p>
<p>调用 Raft 接口的 goroutine[0] 不能有阻塞 apply goroutine[1] 的风险，这样会导致：goroutine[0] 等待 Raft 返回，Raft 等待 goroutine[1] 读取 channel，goroutine[1] 被 goroutine[0] 阻塞，最终死锁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span> <span class="title">applyCommand</span><span class="params">(op Op)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 不是所有的命令都需要 feedback，如 Follower 只是单纯 apply 而不和用户交互</span></span><br><span class="line">	<span class="keyword">if</span> kv.applyFeedback[op.OpId] != <span class="literal">nil</span> &#123;</span><br><span class="line">		kv.applyFeedback[op.OpId]() <span class="comment">// awake waitFeedback</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span> <span class="title">waitFeedback</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, timeout <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;- ch:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 以免这个请求最终没能成功，永远不 feedback</span></span><br><span class="line">		<span class="keyword">case</span> &lt;- time.After(time.Duration(timeout) * time.Millisecond):</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span> <span class="title">Get</span><span class="params">(args *GetArgs, reply *GetReply)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 为 Get 绑定唯一 Id 的目的在于注册回调</span></span><br><span class="line">	opId := nrand()</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 可能 feedback 时 waitFeedback 已经超时返回，没有继续监听 channel 了</span></span><br><span class="line">  <span class="comment">// 容量设置为 1，避免 feedback 因此阻塞</span></span><br><span class="line">	feedbackCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	kv.registerFeedback(feedbackCh, opId, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 将 reply 的更新放在 feedback</span></span><br><span class="line">    <span class="comment">// 可能 waitFeedback 超时返回了，但 reply 仍被更新 [reason0]</span></span><br><span class="line">		reply.Value = kv.kv[args.Key]</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">defer</span> kv.cancelFeedback(opId) <span class="comment">// 避免影响 waitFeedback 超时返回了，仍然执行 feedback</span></span><br><span class="line">	</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 需要优先于 Start 注册 feedback，以免 applyCommand 时 applyFeedback[OpId] == nil</span></span><br><span class="line">  <span class="comment">// 不能带着锁调 Start，避免死锁，因为 apply goroutine 需要锁</span></span><br><span class="line">	kv.rf.Start(op)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Snapshot（Part-B）"><a href="#Snapshot（Part-B）" class="headerlink" title="Snapshot（Part B）"></a>Snapshot（Part B）</h1><h2 id="实验要求-1"><a href="#实验要求-1" class="headerlink" title="实验要求"></a>实验要求</h2><ul>
<li><code>maxraftstate</code>为创建快照的 Raft 日志大小阈值，如果为 -1 则无需创建快照，通过<code>persister.RaftStateSize()</code>获取 Raft 日志大小；</li>
<li>K/V Server 通知 Raft 使用<code>persister.SaveStateAndSnapshot()</code>同时保存 Raft 状态和快照，以使得日志的删除与快照的存储作为一个原子操作；</li>
<li>使用<code>persister.ReadSnapshot()</code>来读取最新的快照；</li>
<li>Your kvserver must be able to detect duplicated operations in the log across checkpoints, so any state you are using to detect them must be included in the snapshots.？？？</li>
<li>允许在单个 InstallSnapshot RPC 中发送整个快照代替论文中的分块发送；</li>
</ul>
<h2 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h2><p>K/V Server：<br><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/kvraft2.jpg" title="raft2" class="gallery-item" style="box-shadow: none;"> <img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/kvraft2.jpg" alt="raft2"></a></p>
<p>Raft：<br><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/raft2.jpg" title="raft2" class="gallery-item" style="box-shadow: none;"> <img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/raft2.jpg" alt="raft2"></a></p>
<h2 id="实现细节-1"><a href="#实现细节-1" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="Server-1"><a href="#Server-1" class="headerlink" title="Server"></a>Server</h3><p>检查 Raft 日志大小的时机应该是 apply Command 后，因为定时检查无法适应 Raft 日志增长速度，可能在两次检查间有大量 Raft 日志写入，而 apply Command 的速度与 Raft 日志的写入速度是相关的</p>
<p>为了防止阻塞 apply goroutine 造成死锁，不能在 apply goroutine 直接调用 Raft 接口进行 Snapshot，应该开启一个后台 snapshot goroutine 待命</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KVServer <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 最后一次 apply Command 在 Raft 日志的 index</span></span><br><span class="line">  <span class="comment">// 在 Snapshot 时传给 Raft 作 lastIncludedIndex</span></span><br><span class="line">	nowIndex <span class="keyword">int</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span> <span class="title">snapshot</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 先阻塞，刚启动时 nowIndex 未初始化</span></span><br><span class="line">		&lt;- kv.snapshotCh</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> kv.maxraftstate &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">		    kv.persister.RaftStateSize() &gt;= kv.maxraftstate &#123;</span><br><span class="line">			kv.mu.Lock()</span><br><span class="line">			snapshot := kv.genSnapshot()</span><br><span class="line">			lastIncludedIndex := kv.nowIndex</span><br><span class="line">			kv.mu.Unlock() <span class="comment">// 不能带着锁调用 Raft.Snapshot，避免死锁</span></span><br><span class="line">			</span><br><span class="line">			kv.rf.Snapshot(lastIncludedIndex, snapshot)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span> <span class="title">checkSnapshot</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="comment">// 避免 apply goroutine 调用该函数而阻塞</span></span><br><span class="line">	<span class="keyword">case</span> kv.snapshotCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">// non-block</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartKVServer</span><span class="params">(servers []*labrpc.ClientEnd, me <span class="keyword">int</span>, persister *raft.Persister, maxraftstate <span class="keyword">int</span>)</span> *<span class="title">KVServer</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 因为通知发送为非阻塞，为了不错过通知，需要设置容量为 1</span></span><br><span class="line">	kv.snapshotCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">snapshot</span><span class="params">(lastIncludedIndex, lastIncludedTerm <span class="keyword">int</span>, snapshot []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 该函数可能被 InstallSnapshot 调，不加锁</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// index 0 位置存放 lastIncludedIndex, lastIncludedTerm</span></span><br><span class="line">  <span class="comment">// 作为 Raft 状态持久化，而不持久化到 Snapshot</span></span><br><span class="line">  <span class="comment">// 可以方便的作 PrevLogIndex, lastIncludedTerm</span></span><br><span class="line">	<span class="keyword">if</span> lastIncludedIndex &gt; rf.lastLogIndex() &#123;</span><br><span class="line">		rf.log = []LogEntries&#123;LogEntries&#123;<span class="literal">nil</span>, lastIncludedTerm, lastIncludedIndex&#125;&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		rf.log = rf.log[rf.logi(lastIncludedIndex):]</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">Snapshot</span><span class="params">(lastIncludedIndex <span class="keyword">int</span>, snapshot []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	rf.mu.Lock() <span class="comment">// 在调用 snapshot 前加锁</span></span><br><span class="line">	<span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// Server 触发 Snapshot 时，已经因收到 InstallSnapshot RPC 被 snapshot 过了</span></span><br><span class="line">	<span class="keyword">if</span> lastIncludedIndex &lt;= rf.lastIncludedIndex() ||</span><br><span class="line">     <span class="comment">// Server 触发 Snapshot 时，日志可能已经因收到 AppendEntries RPC 被截断了</span></span><br><span class="line">	   lastIncludedIndex &gt; rf.lastLogIndex() &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	rf.snapshot(lastIncludedIndex, rf.log[rf.logi(lastIncludedIndex)].Term, snapshot)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">AppendEntries</span><span class="params">(args *AppendEntriesArgs, reply *AppendEntriesReply)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> args.PrevLogIndex &gt; rf.lastLogIndex() ||</span><br><span class="line">     <span class="comment">// 因延迟，PrevLogIndex 可能落在 Snapshot 过的日志范围</span></span><br><span class="line">	   (rf.logi(args.PrevLogIndex) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">	   rf.log[rf.logi(args.PrevLogIndex)].Term != args.PrevLogTerm) &#123;</span><br><span class="line">		reply.Success = <span class="literal">false</span></span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 当 PrevLogIndex 落在 Snapshot 过的日志范围时，跳过这些部分</span></span><br><span class="line">	i := max(rf.logi(args.PrevLogIndex + <span class="number">1</span>), <span class="number">1</span>)</span><br><span class="line">	j := min(max(<span class="number">1</span> - rf.logi(args.PrevLogIndex + <span class="number">1</span>), <span class="number">0</span>),</span><br><span class="line">	         <span class="built_in">len</span>(args.Entries))</span><br><span class="line">	rf.log = rf.log[:i]</span><br><span class="line">	rf.log = <span class="built_in">append</span>(rf.log, args.Entries[j:]...)</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">for</span> i := rf.commitIndex + <span class="number">1</span>;</span><br><span class="line">      i &lt;= newCommitIndex;</span><br><span class="line">      i++ &#123;</span><br><span class="line">      <span class="comment">// 重启后 commitIndex 为 0，可能落在 snapshot 过的日志范围</span></span><br><span class="line">      <span class="keyword">if</span> rf.logi(i) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 可能 snapshot 由 InstallSnapshot 触发，但在通知 Server apply 之前就崩溃了</span></span><br><span class="line">        <span class="comment">// 所以应该重新通知 Server apply snapshot，而不跳过</span></span><br><span class="line">        rf.applyCh &lt;- ApplyMsg&#123;<span class="literal">false</span>, <span class="literal">nil</span>, rf.lastIncludedIndex()&#125;</span><br><span class="line">        i = rf.lastIncludedIndex()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">    rf.applyCh &lt;- ApplyMsg&#123;<span class="literal">true</span>, rf.log[rf.logi(i)].Command, i&#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">InstallSnapshot</span><span class="params">(args *InstallSnapshotArgs, reply *InstallSnapshotReply)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 因为延迟，收到 InstallSnapshot RPC 时可能已经 snapshot 过了</span></span><br><span class="line">	<span class="keyword">if</span> args.LastIncludedIndex &lt; rf.lastIncludedIndex() &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	rf.snapshot(args.LastIncludedIndex, args.LastIncludedTerm, args.Data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">checkCommit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">for</span> i := rf.commitIndex + <span class="number">1</span>; i &lt;= matchIndex[half]; i++ &#123;</span><br><span class="line">    <span class="comment">// 同之前</span></span><br><span class="line">    <span class="keyword">if</span> rf.logi(i) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">      rf.applyCh &lt;- ApplyMsg&#123;<span class="literal">false</span>, <span class="literal">nil</span>, rf.lastIncludedIndex()&#125;</span><br><span class="line">      i = rf.lastIncludedIndex()</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rf.applyCh &lt;- ApplyMsg&#123;<span class="literal">true</span>, rf.log[rf.logi(i)].Command, i&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">appendEntriesFeedback</span><span class="params">(peer <span class="keyword">int</span>, args *AppendEntriesArgs, reply *AppendEntriesReply)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 可能 nextIndex 最后会退到 Snapshot 过的日志范围</span></span><br><span class="line">	<span class="keyword">if</span> rf.nextIndex[peer] &lt;= rf.lastIncludedIndex() &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="keyword">go</span> rf.sendInstallSnapshot(peer, &amp;args, &amp;reply)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2021-07-30</span>
            
                <span>该篇文章被 Yann</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/Distributed-Systems/'>
                            Distributed Systems
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/Courses/'>
                            Courses
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    
        
            
    
            <div class="post-footer-pre-next">
                
                    <span>上一篇：<a href='/2021/cmbezz4qt003044ce0y382rtg/'>MIT 6.824 分布式系统课程- 实现Raft Lab3 K/V Server（Part B）</a></span>
                

                
                    <span class="post-footer-pre-next-last-span-right">下一篇：<a href="/2021/cmbezz4qe001744cecmunfie3/">Convex Optimization-3</a>
                    </span>
                
            </div>
    
        
    

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2025 China 

            
                

            
        </span>
       
    
</div>



<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>🌊看过大海的人不会忘记海的广阔🌊</span>
            
                <span class="footer-last-span-right"><i>本站由<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo</a>驱动｜使用<a target="_blank" rel="noopener" href="https://github.com/HiNinoJay/hexo-theme-A4">Hexo-theme-A4</a>主题</i></span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery/lightgallery.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-thumbnail.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-fullscreen.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-autoplay.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-zoom.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-rotate.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-paper.umd.min.js"></script>




<script type="text/javascript">
     
    if (typeof lightGallery !== "undefined") {
        var options1 = {
            selector: '.gallery-item',
            plugins: [lgThumbnail, lgFullscreen, lgAutoplay, lgZoom, lgRotate, lgPager], // 启用插件
            thumbnail: true,          // 显示缩略图
            zoom: true,               // 启用缩放功
            rotate: true,             // 启用旋转功能能
            autoplay: true,        // 启用自动播放功能
            fullScreen: true,      // 启用全屏功能
            pager: false, //页码,
            zoomFromOrigin: true,   // 从原始位置缩放
            actualSize: true,       // 启用查看实际大小的功能
            enableZoomAfter: 300,    // 延迟缩放，确保图片加载完成后可缩放
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1); // 修复选择器
    }
    
</script>


    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> 

                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>
<script src="/js/emojiHandler.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    wrapEmojis('.paper');
  });
</script>