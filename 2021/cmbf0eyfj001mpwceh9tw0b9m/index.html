<!DOCTYPE html>
<html lang="zh-CN">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="GAMES202-实时阴影" />
    <meta name="hexo-theme-A4" content="v1.9.8" />
    <link rel="alternate icon" type="image/webp" href="/img/20250602032635.jpg">
    <title>Yann | 我愿做你光华中淡淡的一笔</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery-bundle.min.css">


   
        
<link rel="stylesheet" href="/css/custom.css">

    

<meta name="generator" content="Hexo 5.4.2"></head>
    
    

    
    



    
        <style>
            .paper-main{
                max-width:  1200px;
            }
        </style>

    
    




    
    <style>
        :root {
            --waline-theme-color: #323e74; 
            --waline-color: #323e74; 
            --waline-border-color: #323e74; 
            --waline-white: #323e74; 
            --waline-bgcolor-light: #f2fafc;  
        }
        body {
            color: #323e74;
            background: #eaeae8;
        }
        .post-md code {
            background: #e7f7f3;
            color: #7f688d; 
        }
        .post-md pre, .post-md .highlight {
            background: #e7f7f3;
            color: #7f688d; 
        }
        pre .string, pre .value, pre .inheritance, pre .header, pre .ruby .symbol, pre .xml .cdata {
            color: #323e74;
        }
        pre .number, pre .preprocessor, pre .built_in, pre .literal, pre .params, pre .constant {
            color: #323e74;
        }
        .year-font-color {
            color: #323e74 !important;
        }
        .wl-card span.wl-nick {
            color: #323e74; 
        }
        .wl-card .wl-badge {
            border: 1px solid #323e74;
            color: #323e74; 
        }
        .wl-btn {
            border: 1px solid #323e74; 
            color:  #323e74;  
        }
        .wl-btn.primary {
            color: #f2fafc; 
        }
        .wl-header label {
            color: #323e74;
        }
        a {
            color: #7f688d;
        }

        .post-md a {
            color: #7f688d;
        }

        .nav li a {
            color: #7f688d;
        }

        .archive-main a:link {
            color: #7f688d;
        }
        .archive-main a:visited {
            color: #767c7c; 
        }

        .archive li span {
            color: #323e74;
        }

        .post-main-title {
            color: #323e74;
        }

        .post-md h1,
        .post-md h2,
        .post-md h3,
        .post-md h4,
        .post-md h5,
        .post-md h6 {
            color: #323e74;
        }

        [data-waline] p {
            color: #323e74;
        }
        [data-waline] a {
            color: #323e74;
        } 
        .wl-sort li.active {
            color: #323e74;
        }

        .wl-card .wl-meta>span {
            background: #f2fafc;
        }

        .paper {
            background: #eaeae8;
        }

        .index-main {
            background: #f2fafc;
        }

        .paper-main {
            background: #f2fafc;
        }

        .wl-panel {
            background: #f2fafc;
        }

        .archive li:nth-child(odd) {
            background: #f2fafc;
            ;
        }

        .archive li:nth-child(even) {
            background: #f2fafc;
        }

        .post-md table tr:nth-child(odd) td {
            background: #f2fafc;
        }

        .post-md table tr:nth-child(even) td {
            background: #f2fafc;
        }

    
        .progress-wrap::after {
            color: #323e74; /* 箭头的颜色 */
        }
        .progress-wrap svg.progress-circle path {
	        stroke: #323e74; /* 边框的颜色 */
        }
        .progress-wrap::before {
	        background-image: linear-gradient(298deg, #7f688d, #7f688d); /* 鼠标滑过的箭头颜色 */
         }

        .return-to-last-progress-wrap::after {
            color: #323e74; /* 箭头的颜色 */
        }
        .return-to-last-progress-wrap svg.progress-circle path {
	        stroke: #323e74; /* 边框的颜色 */
        }
        .return-to-last-progress-wrap::before {
	        background-image: linear-gradient(298deg, #7f688d, #7f688d); /* 鼠标滑过的箭头颜色 */
         }

         .left-toc-container::-webkit-scrollbar-thumb {
            background-color: #323e74; /* 设置滚动条拖动块的颜色 */
        }

        .bs-docs-sidebar .nav>.active>a,
        .bs-docs-sidebar .nav>li>a:hover,
        .bs-docs-sidebar .nav>li>a:focus {
            color: #7f688d;
            border-left-color: #7f688d;
        }
        .bs-docs-sidebar .nav>li>a {
            color:  #323e74;
        }
    </style>

    
    <style>
        body {
            background-image: url(/img/3.jpg);
            background-attachment: fixed;  /* 背景固定，不随页面滚动 */
            background-repeat: no-repeat;  /* 防止背景图片重复 */
            background-size: cover;       /* 背景自适应大小，覆盖整个背景 */
            background-position: center;   /* 背景居中显示 */
        }
        .paper {
            background-image: url(/img/3.jpg);
            background-attachment: fixed;  /* 背景固定，不随页面滚动 */
            background-repeat: no-repeat;  /* 防止背景图片重复 */
            background-size: cover;       /* 背景自适应大小，覆盖整个背景 */
            background-position: center;   /* 背景居中显示 */
        }  
    </style>


    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        <script>
            const options = {
                bottom: '40px', // default: '32px'
                right: 'unset', // default: '32px'
                left: '42px', // default: 'unset'
                time: '0.3s', // default: '0.3s'
                mixColor: '#fff', // default: '#fff'
                backgroundColor: ' #eaeae8  ',  // default: '#fff'
                buttonColorDark: '#100f2c',  // default: '#100f2c'
                buttonColorLight: '#fff', // default: '#fff'
                saveInCookies: true, // default: true,
                label: '🌓', // default: ''
                autoMatchOsTheme: true // default: true
            }
            const darkmode = new Darkmode(options);
            darkmode.showWidget();
        </script>
        
        
            
                <div class="left-toc-container">
                    <nav id="toc" class="bs-docs-sidebar"></nav>
                </div>
            
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <style>
            .header-img {
                width: 56px;
                height: auto;
                object-fit: cover; /* 保持图片比例 */
                transition: transform 0.3s ease-in-out; 
                border-radius: 0; 
            }
            
        </style>
        <img 
            alt="^-^" 
            cache-control="max-age=86400" 
            class="header-img" 
            src="/img/20250602032635.jpg" 
        />
        <div class="header-content">
            <a class="logo" href="/">Yann</a> 
            <span class="description">人工智能、计算机、机器学习、linux、程序员</span> 
        </div>
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/about/">关于</a></li>
            
        
            
                <li><a href="/tags/">标签</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">
    

    
        
            
                <div class="post-main-title" style="text-align: center;">
                    GAMES202-实时阴影
                </div>
            
        
      
    

    

        
            <div class="post-head-meta-center">
        
                
                    <span>最近更新：2025-06-02</span> 
                
                
                    
                        &nbsp; | &nbsp;
                    
                     <span>字数总计：3.7k</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span>阅读估时：13分钟</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span id="busuanzi_container_page_pv">
                        阅读量：<span id="busuanzi_value_page_pv"></span>次
                    </span>
                
            </div>
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#CG%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE"><span class="post-toc-text">CG基础回顾</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9F%BA%E7%A1%80GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF"><span class="post-toc-text">基础GPU渲染管线</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#OpenGL"><span class="post-toc-text">OpenGL</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#OpenGL-%E7%9D%80%E8%89%B2%E8%AF%AD%E8%A8%80-GLSL"><span class="post-toc-text">OpenGL 着色语言(GLSL)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B"><span class="post-toc-text">渲染方程</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Shadow-Mapping"><span class="post-toc-text">Shadow Mapping</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="post-toc-text">基本思想</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98"><span class="post-toc-text">存在问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-Self-occlusion%EF%BC%88%E8%87%AA%E9%81%AE%E6%8C%A1%EF%BC%89"><span class="post-toc-text">1. Self occlusion（自遮挡）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-Detached-shadow"><span class="post-toc-text">2. Detached shadow</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-Aliasing%EF%BC%88%E8%B5%B0%E6%A0%B7%EF%BC%89"><span class="post-toc-text">3. Aliasing（走样）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Second-Depth-Shadow-Mapping"><span class="post-toc-text">Second Depth Shadow Mapping</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#PCF%EF%BC%88Percentage-Closer-Filtering%EF%BC%89"><span class="post-toc-text">PCF（Percentage Closer Filtering）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#PCSS%EF%BC%88Percentage-Closer-Soft-Shadows%EF%BC%89"><span class="post-toc-text">PCSS（Percentage Closer Soft Shadows）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#VSSM%EF%BC%88Variance-Soft-Shadow-Mapping%EF%BC%89"><span class="post-toc-text">VSSM（Variance Soft Shadow Mapping）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%AE%80%E5%8C%96PCF"><span class="post-toc-text">简化PCF</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%AE%80%E5%8C%96Blocker-search"><span class="post-toc-text">简化Blocker search</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98-1"><span class="post-toc-text">存在问题</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#MSM%EF%BC%88Moment-Shadow-Mapping%EF%BC%89"><span class="post-toc-text">MSM（Moment Shadow Mapping）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Distance-Field-Soft-Shadows"><span class="post-toc-text">Distance Field Soft Shadows</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#signed-distance-function%EF%BC%88%E7%AC%A6%E5%8F%B7%E8%B7%9D%E7%A6%BB%E5%87%BD%E6%95%B0%EF%BC%89"><span class="post-toc-text">signed distance function（符号距离函数）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#SDF%E5%9C%A8%E9%98%B4%E5%BD%B1%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="post-toc-text">SDF在阴影中的应用</span></a></li></ol></li></ol></li></ol>
            
        
        <div class=".article-gallery"><span id="more"></span>
<h2 id="CG基础回顾"><a href="#CG基础回顾" class="headerlink" title="CG基础回顾"></a>CG基础回顾</h2><h3 id="基础GPU渲染管线"><a href="#基础GPU渲染管线" class="headerlink" title="基础GPU渲染管线"></a>基础GPU渲染管线</h3><p>（待补充）</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202110282255523.png" title="image-20211028225552443" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202110282255523.png" alt="image-20211028225552443" width="800px;" /></a></p>
<h3 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h3><h3 id="OpenGL-着色语言-GLSL"><a href="#OpenGL-着色语言-GLSL" class="headerlink" title="OpenGL 着色语言(GLSL)"></a>OpenGL 着色语言(GLSL)</h3><h3 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h3><p>$$<br>L_0(p,w_0) = L_e(p,w_0) + \int_{H^2} f_r(p,w_i\rightarrow w_o) L_i(p,w_i) cos\theta_i dw_i \tag{3.1}<br>$$</p>
<p>实时渲染中的渲染方程通常写为：<br>$$<br>L_0(p,w_0) = L_e(p,w_0) + \int_{\Omega^+} L_i(p,w_i) f_r(p,w_i,w_o) cos\theta_i V(p,w_i) dw_i \tag{3.2}<br>$$<br>这里公式中的 $L_i( p ,w_i)$ 与 $V( p ,w_i)$ 相乘才等同于上一公式的 $L_i( p ,w_i)$，表示将①光源是否存在 和②光源能否打到 $ p$ 点 两项分开考虑</p>
<h2 id="Shadow-Mapping"><a href="#Shadow-Mapping" class="headerlink" title="Shadow Mapping"></a>Shadow Mapping</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>这里只考虑点光源或者平行光源。</p>
<p>两趟算法：以点光源为例，第一趟，将摄像机放在点光源的位置，渲染出一张shadow map，其实是depth map，用来记录光源看到的最近的点的深度。第二趟，用实际的观察点渲染场景，对摄像机看到的每一个点 $p$ ，通过矩阵变换，将其投影到上一张shadow map中，查询投影坐标上的<strong>depth值</strong>， 和 <strong>$p$ 点到光源的距离</strong>做比较，如果depth值&lt;距离，表明有物体挡在了光源和 $p$ 点之间，则 $p$ 点应该显示阴影。</p>
<p>需要注意：shadow map中保存的是场景中顶点的真实深度（点到光源的真实距离）还是在裁剪空间（视锥体frustum需要经过仿射变换变为正方体形状的裁剪空间）内的z值？进行深度比较时，要保证比较双方的意义是相同的。</p>
<p>平行光源和点光源的区别在于观察空间不同，平行光源是一个长方体，点光源是平截头体。</p>
<h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><h4 id="1-Self-occlusion（自遮挡）"><a href="#1-Self-occlusion（自遮挡）" class="headerlink" title="1. Self occlusion（自遮挡）"></a>1. Self occlusion（自遮挡）</h4><p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111012230917.png" title="image-20211101223001812" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111012230917.png" alt="image-20211101223001812" width="800px;" /></a></p>
<p>由于shadow map本身是有分辨率的，所以它每个像素中用一个值表示一片区域的深度值。对地面上的一个点 $p$ ，如果它对应的shadow map中的深度值小于 $p$ 点到光源的距离（真实的深度值），即 z &lt; dis 时，就会被判定为遮挡。</p>
<p>解决方法：我们可以设定一个bias来抵消上面提到的两个距离的差值，当z + bias &lt; dis 时才判定为遮挡。考虑到在 $p$ 点，如果光源是近乎垂直打在地面上的，那儿shadow map中的值和 $p$ 的深度值差异会很小，bias就可以很小。如果光束方向近乎平行于地面（grazing angle），那么该差异可能很大，bias也需要较大。因此可以用入射光的角度$\theta$来控制bias的大小。</p>
<p>但设置bias会带来另一个问题：detached shadow。</p>
<h4 id="2-Detached-shadow"><a href="#2-Detached-shadow" class="headerlink" title="2. Detached shadow"></a>2. Detached shadow</h4><p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111012248429.png" title="image-20211101224834349" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111012248429.png" alt="image-20211101224834349" width="800px;" /></a></p>
<p>设置bias后，有可能出现这种情况，即本来判定为遮挡的点，因为bias的存在，被判定为不遮挡。那么当bias较大时，就会出现上图的状况。</p>
<h4 id="3-Aliasing（走样）"><a href="#3-Aliasing（走样）" class="headerlink" title="3. Aliasing（走样）"></a>3. Aliasing（走样）</h4><p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111022023700.png" title="image-20211102202317556" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111022023700.png" alt="image-20211102202317556" width="800px;" /></a></p>
<p>还是由于shadow map的每一个像素代表了一块区域，那么当遮挡物离 $p$ 点较远时，一个像素的投影就会变得很大，就会出现上图中左边的锯齿现象。</p>
<p>解决方法：cascaded shadow map等</p>
<h3 id="Second-Depth-Shadow-Mapping"><a href="#Second-Depth-Shadow-Mapping" class="headerlink" title="Second Depth Shadow Mapping"></a>Second Depth Shadow Mapping</h3><p>(试图解决自遮挡和detached shadow的方法，但因耗费太高而没有人用)</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111012256008.png" title="image-20211101225651952" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111012256008.png" alt="image-20211101225651952" width="600px;" /></a></p>
<p>这个方法和最基础的Shadow Mapping方法的区别就是，它采用最小深度和次小深度的均值来作为shadow map中的值。因为不采用bias，所以不会出现detached shadow；如果最小深度和次小深度的值相差较大，也会一定程度减少自遮挡（个人理解）。但缺点就是①：需要模型是一个“盒子”类的东西（watertight）②：保存每个像素的最小深度和次小深度，尽管时间复杂度相同为$O(n)$，但这种方法前面的常数部分更大，耗费要更高。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111012307928.png" title="image-20211101230757888" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111012307928.png" alt="image-20211101230757888" width="500px" /></a></p>
<center>电子竞技不相信眼泪</center>



<h3 id="PCF（Percentage-Closer-Filtering）"><a href="#PCF（Percentage-Closer-Filtering）" class="headerlink" title="PCF（Percentage Closer Filtering）"></a>PCF（Percentage Closer Filtering）</h3><p>PCF是抗锯齿，反走样的一种技术。</p>
<p>基本思想：对一个像素的某个属性，取它周围多个像素属性的平均值。</p>
<p>在Shadow Mapping中的应用：可用于实现面光源的软阴影的效果</p>
<p>对于一个点 $p$，它到光源的距离是dis，通过与shadow map中深度值z的比较，我们可以得到它的可见性，从而确定它是否显示阴影。而PCF则是将dis与shadow map上的一块区域的深度值作比较，得到一系列的可见性值（0或1），再求这些可见性的均值。用此值去确定阴影颜色的深浅。</p>
<p>这块filter的区域越大，平均的像素也就越多，可以实现越模糊，越软的阴影。</p>
<h3 id="PCSS（Percentage-Closer-Soft-Shadows）"><a href="#PCSS（Percentage-Closer-Soft-Shadows）" class="headerlink" title="PCSS（Percentage Closer Soft Shadows）"></a>PCSS（Percentage Closer Soft Shadows）</h3><p><a target="_blank" rel="noopener" href="https://developer.download.nvidia.com/shaderlibrary/docs/shadow_PCSS.pdf">Percentage-Closer Soft Shadows (nvidia.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111022113681.png" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111022113681.png" width="600px" /></a></p>
<p> 通过现实中的景象，我们可以观察到阴影在不同位置的软度是不同的。虽然上图有景深导致的模糊，但还是能说明这个问题。</p>
<p>所以需要确定：对于不同位置的着色点 $p$ ，采用多大的filter？</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/L-Aidan/Images/main/img/image-20211103164111947.png" title="image-20211103164111947" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/L-Aidan/Images/main/img/image-20211103164111947.png" alt="image-20211103164111947" width="300px" /></a></p>
<p>图中 $w_{Penumbra}$  表示软阴影的范围大小，即软的程度。从上图中可以总结出，影响它的因素有：面光源的大小 $w_{Light}$、面光源到遮挡物的垂直距离 $d_{Blocker}$、面光源到阴影接收物的垂直距离 $d_{Receiver}$。根据相似三角性原理：<br>$$<br>w_{Penumbra} = (d_{Receiver} - d_{Blocker}) \cdot w_{Light} / d_{Blocker} \tag{3.4}<br>$$<br>（个人理解）实际应用时，如下图：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111022120550.png" title="202111022120550" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111022120550.png" alt="202111022120550" width="300px" /></a></p>
<p>将面光源水平放置，（假设接收物和面光源平行就好，不影响p点接收到的光）。那么公式里的 $d_{Blocker}$ 就是橙色的那一段，$d_{Receiver}$ 就是橙色 + 黑色的那一段。</p>
<p>假设 $w_{Light}$ 已知，着色点 $p$ 到光源的距离 $d_{Receiver}$ 也可求。而 $d_{Blocker}$ 就是shadow map中记录的深度值（因为面光源无法生成shadow map，所以应该将面光源看作点光源，生成一张shadow map，比如用面光源中心的点）。</p>
<p>因为是面光源，所以对于我们要着色的一个点 $p$，遮挡物上不同的位置都可能挡住了一些入射光，所以需要求一个平均的 $d_{Blocker}$，就是对shadow map上的一个区域中的 $d_{Blocker}$ 求平均值（需要注意，如果shaodow map中的点没有遮挡住 $p$，那就不算遮挡物，不参与平均值计算），那么又有了一个问题，这个区域的大小应该取多少？</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111022217609.png" title="image-20211102221703551" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111022217609.png" alt="image-20211102221703551" width="600px" /></a></p>
<p>有一个方法是，让点 $p$ 连向光源的四个顶点（假设是四个），看这个视锥在shadow map上覆盖了多大的区域，用这个区域来当作求均值的区域。这种方法是很符合直观想象的，我们想求的就是遮住点 $p$ 的blocker的范围，从图中看自然就是红色的区域。</p>
<p>至此，就可以完成整个流程：</p>
<ol>
<li><p>（Blocker search）让点 $p$ 连向光源的顶点，看这个视锥在shadow map上覆盖了多大的区域，在这个区域中计算平均  $d_{Blocker}$。</p>
</li>
<li><p>（Penumbra estimation）用公式(3.4) 计算软阴影范围大小，确定PCF的滤波范围。</p>
</li>
<li><p>（Percentage Closer Filting）使用PCF，求出点 $p$ 的阴影深浅程度。</p>
</li>
</ol>
<h3 id="VSSM（Variance-Soft-Shadow-Mapping）"><a href="#VSSM（Variance-Soft-Shadow-Mapping）" class="headerlink" title="VSSM（Variance Soft Shadow Mapping）"></a>VSSM（Variance Soft Shadow Mapping）</h3><p>上述过程中，第1步和第3步中，对shadow map中每个像素，需要对它的一个邻域进行某个属性的加权平均，要访问邻域内每个像素的值，那么这种操作的时间耗费就会很高。而VSSM没有访问每一个像素值，而是用一种巧妙的方法得到我们所需要的值。</p>
<h4 id="简化PCF"><a href="#简化PCF" class="headerlink" title="简化PCF"></a>简化PCF</h4><p>对于第三步的PCF，我们的操作是，对一个点 $p$，将它到光源的距离dis和shadow map上一块区域内的深度值比较，得到一系列的可见性值（0或1），将这些值平均，得到最终的可见性值。看起来我们需要知道邻域内每个像素的值，但实际上我们只需要知道邻域内有百分之多少的深度值是大于dis的就可以了。于是VSSM在这里使用了一个近似，即切比雪夫不等式：</p>
<p>如果随机变量 $X$ 满足一个均值为 $\mu$，方差为 $\sigma$ 的概率分布，对于某一个 $t$ （$t&gt;\mu$ ）则有：<br>$$<br>P(x&gt;t) \leq \frac{\sigma^2}{\sigma^2 + (t-\mu)^2}<br>$$<br>（一位知乎答主对切比雪夫不等式的解释：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/27821324/answer/80814695">https://www.zhihu.com/question/27821324/answer/80814695</a></p>
<p>带入到PCF中，意义为，对于一个点，它到光源的距离为 $t$，我们希望得到这个点对应shadow map的邻域中深度值大于 $t$ 的概率 $P$。由切比雪夫不等式我们知道，$P$是小于不等式右边的值的，但VSSM采用了一个大胆的假设：把不等式变为等式，将不等式右边的值赋给 $P$。这样我们只需要知道这个邻域中深度值的均值和方差就可以完成PCF。</p>
<p>假设均值已知，那么方差可用高数课本里的公式求出：$Var(X) = E(x^2) - E^2(X)$。我们现在只需要知道该邻域的深度值均值，以及深度值平方的均值。</p>
<p>这里的邻域为矩形区域，求一个矩形区域的均值，leetcode上刷的题终于有了用武之地。</p>
<p>前缀和！</p>
<p>这里不再细说了。均值可用前缀和算法求得，对于平方的均值，可以维护一个深度值的平方的map，同样用前缀和得到均值。</p>
<h4 id="简化Blocker-search"><a href="#简化Blocker-search" class="headerlink" title="简化Blocker search"></a>简化Blocker search</h4><p>虽然这一步也是求一块区域内的深度值均值，但却有一点需要注意，这里求的是矩形区域内blocker的深度值均值，而不是所有深度值的均值。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111101936221.png" title="image-20211102221703551" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111101936221.png" alt="image-20211102221703551" width="200px" /></a></p>
<p>即在上图的矩形区域中，假设着色点的深度值是7，那么只需要求蓝色数字的均值。来看这样一个公式：<br>$$<br>\frac{N_1}{N}z_{unocc} + \frac{N_2}{N}z_{occ} = z_{avg}<br>$$</p>
<p>$N$为矩形区域的像素数，$z_{avg}$为矩形区域内的平均深度；$N_1$为非遮挡物所占的像素数，$z_{unocc}$为非遮挡物的平均深度；$N_2$为遮挡物所占的像素数，$z_{occ}$为遮挡物的平均深度。显然等式成立。</p>
<p>我们想要求得$z_{occ}$，而$\frac{N_1}{N}$可用上面小节提到的切比雪夫不等式近似求得，$\frac{N_2}{N} = 1 - \frac{N_1}{N}$，那么只需要知道$z_{unocc}$就可以了。这里VSSM又做了一个更大胆的假设：认为非遮挡物的深度和当前着色点的深度相同（依据是绝大多数阴影的接收物是个平面），即认为$z_{unocc}=7$，那么除$z_{occ}$的所有变量都是已知的，$z_{occ}$可求。</p>
<p>虽然VSSM耗费大大降低，但目前基本不用这种方法，因为图像降噪的技术非常成熟，可以在采样的PCSS中进行降噪，来达到很好的效果。</p>
<h4 id="存在问题-1"><a href="#存在问题-1" class="headerlink" title="存在问题"></a>存在问题</h4><p>切比雪夫不等式<br>$$<br>P(x&gt;t) \leq \frac{\sigma^2}{\sigma^2 + (t-\mu)^2}<br>$$<br>由于我们由于我们是把切比雪夫不等式当成了等式来使用，那么我们得到的 $P$，是比真实的 $P$ 大的。而 $P$ 表示百分之多少的深度值是大于dis的（没有挡住点 $p$ ），就是说这个值越大，得到的可见性值越大，点 $p$ 越亮。即最终得到的图像比实际场景要亮。当这个误差很大时，就会出现漏光问题（Light Leaking）：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111101957640.png" title="image-20211102221703551" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111101957640.png" alt="image-20211102221703551" width="800px" /></a></p>
<h3 id="MSM（Moment-Shadow-Mapping）"><a href="#MSM（Moment-Shadow-Mapping）" class="headerlink" title="MSM（Moment Shadow Mapping）"></a>MSM（Moment Shadow Mapping）</h3><p>在VSSM里，切比雪夫不等式来近似求得一个概率，也就是CDF，但这个CDF是不精准的。因此如果能够找到更精确的CDF，就可以得到更精准的结果。</p>
<p>数学概念：矩（moment）是对变量分布和形态特点的一组度量。n阶矩被定义为一变量的n次方与其概率密度函数（PDF）之积的积分。</p>
<p>VSSM中只用到了 $X$ 和 $X^2$,，可以认为只用到了前两阶矩，如果再考虑到更高阶的矩，就可以重建一个更加准确的CDF。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111102021198.png" title="image-20211102221703551" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111102021198.png" alt="image-20211102221703551" width="400px" /></a></p>
<p>图中PCF是书写错误，应该为CDF。可以看到使用前四阶矩得到的CDF就非常精准了。</p>
<p>那么如何用矩得到这样一个CDF，还得看论文：<a target="_blank" rel="noopener" href="https://jankautz.com/publications/VSSM_PG2010.pdf">https://jankautz.com/publications/VSSM_PG2010.pdf</a></p>
<p>这一步的耗费也是很高的。</p>
<h3 id="Distance-Field-Soft-Shadows"><a href="#Distance-Field-Soft-Shadows" class="headerlink" title="Distance Field Soft Shadows"></a>Distance Field Soft Shadows</h3><h4 id="signed-distance-function（符号距离函数）"><a href="#signed-distance-function（符号距离函数）" class="headerlink" title="signed distance function（符号距离函数）"></a>signed distance function（符号距离函数）</h4><p>signed distance function（符号距离函数）：对空间中的任意一点，它到一个物体表面有一个最小距离（根据在物体的内外可能区分正负）。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111211417525.png" title="image-20211102221703551" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111211417525.png" alt="image-20211102221703551" width="00px" /></a></p>
<p>对一个点，它到这个场景的最小距离就是它到每一个物体的最小距离的最小值。空间中每一个点都有这样一个最小距离，这些距离在空间中形成了一个标量场。</p>
<p>应用：</p>
<ol>
<li><p>对移动边界的位置进行插值（对每一个点到黑白边界线的distance function进行插值）。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111211418222.png" title="image-20211102221703551" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111211418222.png" alt="image-20211102221703551" width="600px" /></a></p>
</li>
<li><p>融合两个物体（具体方法：对两个distance function进行插值？？不确定）</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111211419305.png" title="image-20211102221703551" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111211419305.png" alt="image-20211102221703551" width="600px" /></a></p>
</li>
</ol>
<h4 id="SDF在阴影中的应用"><a href="#SDF在阴影中的应用" class="headerlink" title="SDF在阴影中的应用"></a>SDF在阴影中的应用</h4><p>阴影，可以理解为在着色点 $p$ 处，面光源被遮挡的越多就越暗。SDF可以得到一个着色点被遮挡的程度，也就得到了visibility。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111211431137.png" title="image-20211102221703551" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111211431137.png" alt="image-20211102221703551" width="400px" /></a></p>
<p>对图中圆圈中的点，圆的半径表示它的SDF的值，意味着在以此点为圆心，此半径为球的内部，是没有任何物体的；也就是说在这个球内，没有物体会遮挡住下方的着色点。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111211432390.png" title="image-20211102221703551" class="gallery-item" style="box-shadow: none;"> <img src="https://raw.githubusercontent.com/L-Aidan/Images/main/img/202111211432390.png" alt="image-20211102221703551" width="400px" /></a></p>
<p>和Ray-marching结合，我们可以粗略的估计出着色点被遮挡的程度。如上图，假设从o点射向光源的ray，在点 $p_1$ ，我们查询SDF得到一个半径，可以求得角度 ${\theta}_1$，粗略的认为 ${\theta}_1$内的方向角内没有物体遮挡住光源。然后在ray方向上找到点 $p_2$ 。重复此过程，直至ray走了足够远的距离或者ray与一个物体相交。取各个 $\theta$ 的最小值，就得到了未被遮挡的范围大小。</p>
<p>勾股定理求出 $\theta$ :<br>$$<br>{\theta} = arcsin\frac{SDF(p)}{||p-o||}<br>$$<br>而实际应用中，反三角函数运算量很大，因此可以转化为：<br>$$<br>{\theta} = min{\frac{k\cdot SDF(p)}{||p-o||}, 1.0}<br>$$<br>用k来调整软阴影的大小。k越大，意味着足够小的 $\theta$ 就可以使visibility达到1.0，阴影就越硬，反之则越软。</p>
<p><strong>Pros &amp; Cons</strong>：</p>
<p>Pros：速度快，质量高</p>
<p>Cons：空间中每个点的SDF需要预计算，存储空间耗费也很高。</p>
</div>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2021-04-21</span>
            
                <span>该篇文章被 Yann</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/computer-graphics/'>
                            computer graphics
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/Courses/'>
                            Courses
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    
        
            
    
            <div class="post-footer-pre-next">
                
                    <span>上一篇：<a href='/2021/cmbf0eyf30009pwceaslnejfz/'>初学加性组合（三）：有关Approximate group的一些性质</a></span>
                

                
                    <span class="post-footer-pre-next-last-span-right">下一篇：<a href="/2021/cmbf0eyfm0023pwce6o2hb9kn/">GAMES202-实时PBR</a>
                    </span>
                
            </div>
    
        
    

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2025 China 

            
                

            
        </span>
       
    
</div>



<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>🌊看过大海的人不会忘记海的广阔🌊</span>
            
                <span class="footer-last-span-right"><i>本站由<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo</a>驱动｜使用<a target="_blank" rel="noopener" href="https://github.com/HiNinoJay/hexo-theme-A4">Hexo-theme-A4</a>主题</i></span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery/lightgallery.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-thumbnail.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-fullscreen.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-autoplay.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-zoom.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-rotate.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-paper.umd.min.js"></script>




<script type="text/javascript">
     
    if (typeof lightGallery !== "undefined") {
        var options1 = {
            selector: '.gallery-item',
            plugins: [lgThumbnail, lgFullscreen, lgAutoplay, lgZoom, lgRotate, lgPager], // 启用插件
            thumbnail: true,          // 显示缩略图
            zoom: true,               // 启用缩放功
            rotate: true,             // 启用旋转功能能
            autoplay: true,        // 启用自动播放功能
            fullScreen: true,      // 启用全屏功能
            pager: false, //页码,
            zoomFromOrigin: true,   // 从原始位置缩放
            actualSize: true,       // 启用查看实际大小的功能
            enableZoomAfter: 300,    // 延迟缩放，确保图片加载完成后可缩放
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1); // 修复选择器
    }
    
</script>


    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> 

                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>
<script src="/js/emojiHandler.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    wrapEmojis('.paper');
  });
</script>