<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yuanquanquan的个人博客 | 我愿做你光华中淡淡的一笔</title>
  
  <subtitle>我愿做你光华中淡淡的一笔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yuanquanquan.top/"/>
  <updated>2022-07-24T15:17:34.520Z</updated>
  <id>http://yuanquanquan.top/</id>
  
  <author>
    <name>Yann</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TDA4开发</title>
    <link href="http://yuanquanquan.top/2022/202220724/"/>
    <id>http://yuanquanquan.top/2022/202220724/</id>
    <published>2022-07-24T13:52:31.000Z</published>
    <updated>2022-07-24T15:17:34.520Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>TI 的 TDA4VM SoC 包含双核 A72、高性能视觉加速器、视频编解码器加速器、最新的 C71x 和 C66x DSP、用于捕获和显示的高带宽实时 IP、GPU、专用安全岛和安全加速器。SoC 经过功率优化，可为机器人、工业和汽车应用中的感知、传感器融合、定位和路径规划任务提供一流的性能。TDA4VM Edge AI Starter Kit (SK) 是一款低成本、小尺寸板，功耗大约20W，能提供8TOPS深度学习算力，支持Tensorflow Lite,ONNX,TVM,GStreamer接口</p></blockquote><span id="more"></span><h2 id="TDA4开发-一-soc介绍"><a href="#TDA4开发-一-soc介绍" class="headerlink" title="TDA4开发(一) soc介绍"></a>TDA4开发(一) soc介绍</h2><h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220724211613695.png" alt=""></p><h3 id="TDA4VM-SK"><a href="#TDA4VM-SK" class="headerlink" title="TDA4VM SK"></a>TDA4VM SK</h3><p><strong>运行前准备</strong></p><p>•SK板</p><p>•USB camera  •支持HDMI或者DP口的显示器  •至少16GB空间SD卡，如果大于16G，需要手动拓展 root filesystem</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220724212422704.png" alt=""></p><p>•网线和局域网  </p><p>•串口电源（5-20V DC），功率保证20W以上  如果功率不够，运行期间可能导致重启</p><p><strong>设置启动模式</strong></p><p>将拨码开关拨到如图所示位置，系统从SD卡启动</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220724212522518.png" alt=""></p><h3 id="支持的相机输入"><a href="#支持的相机输入" class="headerlink" title="支持的相机输入"></a>支持的相机输入</h3><p><strong>USB Camera</strong></p><p>驱动已经在SDK中解决了，根据文档说明，已经测试过C270/C920/C922三款camera，如果遇到camera打不开的情况参考文档[1]</p><p><strong>YUV sensor</strong></p><p>支持OV5640，200万像素，CSI接口，YUYV输出，产品信息[2]默认在SDK中，OV5640是被屏蔽的，需要手动开启支持打开<code>/run/media/mmcblk0p1/uenv.txt</code></p><p>然后编辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name_overlays=k3-j721e-edgeai-apps.dtbo k3-j721e-sk-csi2-ov5640.dtbo</span><br></pre></td></tr></table></figure><p>重启设备即可</p><p><strong>Raw sensor</strong></p><p>RPiV2</p><h3 id="软件设置"><a href="#软件设置" class="headerlink" title="软件设置"></a>软件设置</h3><p>下载SDK包[3]</p><p>下载烧录软件[4]</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220724212600518.png" alt=""></p><p>烧录软件使用1.7.0版本烧录完成即可上电启动</p><p>先插入SD卡，然后再上电，显示器就会有如下图所示画面，代表启动成功</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220724212621593.png" alt=""></p><p>板子默认在串口打印日志，所以初次上电需要连接串口，登陆账号</p><p><strong>串口使用</strong></p><p>在host ubuntu上推荐安装minicom，minicom使用方法参考[5]</p><p>在windows上推荐安装teraterm[6]</p><p>ubuntu下启动minicom</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo minicom -D /dev/ttyUSB2 -c on</span><br></pre></td></tr></table></figure><p>板子默认串口波特率是115200 连接串口登陆用户名是root，不需要密码进去之后，ifconfig查询板子ip地址，后面即可使用ssh登陆</p><p>推荐使用vscode，可以利用remote插件来直接ssh登陆到板子，然后可以很方便地修改配置文件</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220724212646622.png" alt=""></p><p><strong>配置软件环境</strong></p><p>软件环境配置才是重点，例如安装tensorflow，onnx，python和c++依赖库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/edge_ai_apps#./setup_script.sh</span><br></pre></td></tr></table></figure><p>运行上面脚本，所有环境自动安装</p><p>•clone Tensoflow•clone ONNX-RT•clone edgeai-tiovx-modules•clone edgai-gst-plugins•clone adgeai-tidl-tools•compile C++ apps</p><p>经常会遇到运行失败，原因就是访问github比较慢，多试几次就好</p><p>如果需要调试相关环境，直接在运行的时候，加入参数，即可编译debug版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@j7-evm:/opt/edge_ai_apps#./setup_script.sh -d</span><br></pre></td></tr></table></figure><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><code>[1]</code> 参考文档: <em><a href="https://software-dl.ti.com/jacinto7/esd/processor-sdk-linux-sk-tda4vm/latest/exports/docs/faq.html#pub-edgeai-multiple-usb-cams">https://software-dl.ti.com/jacinto7/esd/processor-sdk-linux-sk-tda4vm/latest/exports/docs/faq.html#pub-edgeai-multiple-usb-cams</a></em><br><code>[2]</code> 产品信息: <em><a href="https://www.leopardimaging.com/product/cmos-sensor-modules/mipi-camera-modules/li-am65x-csi2">https://www.leopardimaging.com/product/cmos-sensor-modules/mipi-camera-modules/li-am65x-csi2</a></em><br><code>[3]</code> SDK包: <em><a href="https://dr-download.ti.com/software-development/software-development-kit-sdk/MD-4K6R4tqhZI/08.02.00.02/ti-processor-sdk-linux-sk-tda4vm-etcher-image.zip">https://dr-download.ti.com/software-development/software-development-kit-sdk/MD-4K6R4tqhZI/08.02.00.02/ti-processor-sdk-linux-sk-tda4vm-etcher-image.zip</a></em><br><code>[4]</code> 烧录软件: <em><a href="https://github.com/balena-io/etcher/releases/tag/v1.7.0">https://github.com/balena-io/etcher/releases/tag/v1.7.0</a></em><br><code>[5]</code> minicom使用方法参考: <em><a href="https://help.ubuntu.com/community/Minicom">https://help.ubuntu.com/community/Minicom</a></em><br><code>[6]</code> teraterm: <em><a href="https://learn.sparkfun.com/tutorials/terminal-basics/tera-term-windows">https://learn.sparkfun.com/tutorials/terminal-basics/tera-term-windows</a></em></p><h1 id="TDA4开发-二-运行demo"><a href="#TDA4开发-二-运行demo" class="headerlink" title="TDA4开发(二) 运行demo"></a>TDA4开发(二) 运行demo</h1><p>原创 carpenter 卡本特 <em>2022-07-08 20:30</em> <em>发表于广东</em></p><p>收录于合集#Ti-tda44个</p><h3 id="运行板载demo"><a href="#运行板载demo" class="headerlink" title="运行板载demo"></a>运行板载demo</h3><p>Ti在板载端提供了非常丰富的demo，每个demo都提供了输入文件，模型文件。只需要修改config文件运行即可，demo分为python版本和c++版本，C++版本的运行效率会稍微高一些</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件通过使用YAML格式来设置参数，配置文件路径为<code>edge_ai_app/configs</code></p><p>在配置文件中指定了demo运行的输入类型，例如picture, video, camera</p><p>还可以指定加载模型的路径，指定输出类型，例如是保存到本地文件还是输出到显示器</p><p>如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220724213111606.png" alt=""></p><p>config 文件分为四个部分</p><p>•Inputs</p><p>•Models</p><p>•Outputs</p><p>•Flows</p><h3 id="Inputs"><a href="#Inputs" class="headerlink" title="Inputs"></a><strong>Inputs</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inputs:    input0:                                         #Camera Input        source: /dev/video2                         #Device file entry of the camera        format: jpeg                                #Input data format suported by camera        width: 1280                                 #Width and Height of the input        height: 720        framerate: 30                               #Framerate of the source</span><br><span class="line">    input1:                                         #Video Input        source: ../data/videos/video_0000_h264.mp4  #Video file        format: h264                                #File encoding format        width: 1280        height: 720        framerate: 25</span><br><span class="line">    input2:                                         #Image Input        source: ../data/images/%04d.jpg             #Sequence of Image files, printf style formatting is used        width: 1280        height: 720        index: 0                                    #Starting Index (optional)</span><br></pre></td></tr></table></figure><p><strong>1, Camera</strong></p><p>挂载到板子上的camera会被v4l2src GStreamer来作解析，是否会被识别为camera，需要使用脚本来验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./init_script.sh</span><br></pre></td></tr></table></figure><p>如果插上的camera能够成功被识别，那么会有如下输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@j7-evm:/opt/edge_ai_apps# ./init_script.shUSB Camera detected    device = /dev/video2    format = jpeg</span><br></pre></td></tr></table></figure><p><strong>2, Video</strong></p><p>支持H264和H265格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input1:    source: ../data/videos/video_0000_h264.mp4    format: h264    width: 1280    height: 720    framerate: 25</span><br><span class="line">input2:    source: ../data/videos/video_0000_h265.mp4    format: h265    width: 1280    height: 720    framerate: 25</span><br></pre></td></tr></table></figure><p>如果不确定某个视频文件具体的视频流格式，那么可以在<code>format</code>设置为<code>auto</code>, 可以被Gstreamer自动解码识别</p><p><strong>3, Images</strong></p><p>可以配置输入为多张图片，指定图片文件夹路径即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input2:    source: ../data/images/%04d.jpg    width: 1280    height: 720    index: 0    framerate: 1</span><br></pre></td></tr></table></figure><p><strong>4, RTSP stream</strong></p><p>GStreamer可以解析来自于RTSP数据源非加密数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input0:    source: rtsp://172.24.145.220:8554/test # rtsp stream url, replace this with correct url    width: 1280    height: 720    framerate: 30</span><br></pre></td></tr></table></figure><h3 id="Models"><a href="#Models" class="headerlink" title="Models"></a><strong>Models</strong></h3><p>配置推理模型的相关参数，包括模型路径，和模型参数，例如阈值。在anchor based的目标检测算法中可能有<code>topN</code>参数，在<code>segmentation</code>中有<code>alpha</code>参数, 不同类型的模型需要的配置参数不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">models:    model0:        model_path: ../models/segmentation/ONR-SS-871-deeplabv3lite-mobv2-cocoseg21-512x512   #Model Directory        alpha: 0.4                                                                            #alpha for blending segmentation mask (optional)    model1:        model_path: ../models/detection/TFL-OD-202-ssdLite-mobDet-DSP-coco-320x320        viz_threshold: 0.3                                                                    #Visualization threshold for adding bounding boxes (optional)    model2:        model_path: ../models/classification/TVM-CL-338-mobileNetV2-qat        topN: 5                                                                               #Number of top N classes (optional)</span><br></pre></td></tr></table></figure><h3 id="Outputs"><a href="#Outputs" class="headerlink" title="Outputs"></a><strong>Outputs</strong></h3><p>可以配置为显示器输出，保存为视频文件，输出为图片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">outputs:    output0:                                                     #Display Output        sink: kmssink        width: 1920                                              #Width and Height of the output        height: 1080        connector: 39                                            #Connector ID for kmssink (optional)</span><br><span class="line">    output1:                                                     #Video Output        sink: ../data/output/videos/output_video.mkv             #Output video file        width: 1920        height: 1080</span><br><span class="line">    output2:                                                     #Image Output        sink: ../data/output/images/output_image_%04d.jpg        #Image file name, printf style formatting is used        width: 1920        height: 1080</span><br></pre></td></tr></table></figure><p><strong>1, 显示器输出</strong></p><p>支持DP和HDMI的输出，确认显示器是否成功连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@j7-evm:/opt/edge_ai_apps# modetest -M tidss -c | grep connected39      38      connected       DP-1            530x300         12      3848      0       disconnected    HDMI-A-1        0x0             0       47</span><br></pre></td></tr></table></figure><p>例如上面显示，connector 39是<code>connected</code>状态，所以在配置Output的时候，可以在<code>connector</code>填入39</p><p><strong>2，保存本地视频</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output1:    sink: ../data/output/videos/output_video.mkv    width: 1920    height: 1080</span><br></pre></td></tr></table></figure><p><strong>3，保存为图片</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output2:    sink: ../data/output/images/output_image_%04d.jpg    width: 1920    height: 1080</span><br></pre></td></tr></table></figure><h3 id="Flows"><a href="#Flows" class="headerlink" title="Flows"></a><strong>Flows</strong></h3><p>通过配置Flows可以将不同的<code>input</code>,<code>model</code>,<code>output</code>组合到一起</p><h3 id="模型下载"><a href="#模型下载" class="headerlink" title="模型下载"></a>模型下载</h3><p>跑完板载的简单demo，可以配置比较复杂的任务了</p><p>Ti提供了一个叫做Model Downloader Tool[1]的工具，用来下载不同类型的预训练模型</p><p>运行下载器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@j7-evm:/opt/edge_ai_apps# ./download_models.sh</span><br></pre></td></tr></table></figure><p>是一个可交互界面，可以通过键盘选择想要下载的模型文件，其保存路径在<code>/opt/model/zoo</code></p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220724213513708.png" alt=""><img src="https://mmbiz.qpic.cn/mmbiz_png/ygGMicIOvEAR3ia0Ajtfb0EWoiaaZ2Mzwqibmm0iadu8S1OTBHEomLjU3IRRcXqJ0L4XZh6GxPGEtR5qwLlh72X6ZFQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h3 id="自定义模型"><a href="#自定义模型" class="headerlink" title="自定义模型"></a>自定义模型</h3><p>官方提供的模型肯定是不能满足个人业务需求的，所以自己训练模型并导入到tda4运行，是一个必然绕不开的路</p><p>Ti SDK提供了加载自定义模型的接口</p><p>•Tensorflow Lite•ONNX•TVM/Neo AI-DLR</p><p>每一个DNN模型需要满足以下结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TFL-OD-2010-ssd-mobV2-coco-mlperf-300x300│├── param.yaml│├── artifacts│   ├── 264_tidl_io_1.bin│   ├── 264_tidl_net.bin│   ├── 264_tidl_net.bin.layer_info.txt│   ├── 264_tidl_net.bin_netLog.txt│   ├── 264_tidl_net.bin.svg│   ├── allowedNode.txt│   └── runtimes_visualization.svg│└── model    └── ssd_mobilenet_v2_300_float.tflite</span><br></pre></td></tr></table></figure><p>•model</p><p>模型文件，例如tflite，onnx等</p><p>   •artifacts</p><p>由SDK编译生成出来的文件，网络层信息，量化信息，节点名称。</p><p>此部分是将模型转为TiDL模型中最为关键的一部分，Ti提供专门的文档[2]来解释这部分内容。</p><p>  •param.yaml  定义前处理，后处理等参数，例如anchor based和anchor free的后处理操作就很大不一样, 例如目标检测和语义分割对应的param格式就不一样，Ti提供了benchmark[3], 可以在里面找到对应的模板</p><p>SDK提供了一个工具叫做Edge AI TIDL Tools[4], 可以将通用模型转为Ti支持的DNN模型，目前支持三种模型的转换，但是<strong>Ti建议分别使用三种模型尝试转换，哪种模型的精度高就选用哪种模型做最终部署</strong></p><h3 id="References-1"><a href="#References-1" class="headerlink" title="References"></a>References</h3><p><code>[1]</code> Model Downloader Tool: <em><a href="https://github.com/TexasInstruments/edgeai-modelzoo">https://github.com/TexasInstruments/edgeai-modelzoo</a></em><br><code>[2]</code> 文档: <em><a href="https://software-dl.ti.com/jacinto7/esd/processor-sdk-linux-sk-tda4vm/latest/exports/docs/inference_models.html#pub-edgeai-compile-artifacts">https://software-dl.ti.com/jacinto7/esd/processor-sdk-linux-sk-tda4vm/latest/exports/docs/inference_models.html#pub-edgeai-compile-artifacts</a></em><br><code>[3]</code> benchmark: <em><a href="https://github.com/TexasInstruments/edgeai-benchmark/tree/master/examples/configs/yaml">https://github.com/TexasInstruments/edgeai-benchmark/tree/master/examples/configs/yaml</a></em><br><code>[4]</code> Edge AI TIDL Tools: <em><a href="https://github.com/TexasInstruments/edgeai-tidl-tools/blob/master/examples/osrt_python/README.md#model-compilation-on-pc">https://github.com/TexasInstruments/edgeai-tidl-tools/blob/master/examples/osrt_python/README.md#model-compilation-on-pc</a></em></p><h1 id="TDA4开发-三-运行demo"><a href="#TDA4开发-三-运行demo" class="headerlink" title="TDA4开发(三) 运行demo"></a>TDA4开发(三) 运行demo</h1><h3 id="TiDL-tools"><a href="#TiDL-tools" class="headerlink" title="TiDL-tools"></a>TiDL-tools</h3><p>在TDA4上进行inference的时候，主要是跑在A72和C71-MMA异构系统上，并不是单核完成。具体哪些操作在A核哪些操作在DSP核，需要在SDK编译时候配置。</p><p>TF-Lite[1]提供了TFLite Delgate API[2], TiDL可以很方便地去调用。ONNX和TVM则是调用标准API</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220724213740440.png" alt=""></p><h3 id="WorkFlow"><a href="#WorkFlow" class="headerlink" title="WorkFlow"></a>WorkFlow</h3><p>以TFLite为例，TFLite的模型首先需要在PC上根据SDK生成Artifacts，然后再将模型和artifact一起作为输入，送到soc中完成推理任务</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220724213718806.png" alt=""></p><h3 id="模型转换"><a href="#模型转换" class="headerlink" title="模型转换"></a>模型转换</h3><h3 id="1，在PC上搭建环境-3"><a href="#1，在PC上搭建环境-3" class="headerlink" title="1，在PC上搭建环境[3]"></a>1，在PC上搭建环境[3]</h3><p>建议Ubuntu18.04 + Python3.6， 模型转换只能通过python脚本完成</p><p>需要使用pip配置环境，需要先安装pip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-pip</span><br></pre></td></tr></table></figure><p>下载代码，然后安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/TexasInstruments/edgeai-tidl-tools.gitexport DEVICE=j7#export DEVICE=am62   #设置DEVICEcd edgeai-tidl-toolssource ./setup.sh</span><br></pre></td></tr></table></figure><p>需要大量下载，时间会比较长</p><p>可能会在某个步骤安装出错，需要打开setup.sh，按照终端输出信息来重试几次。</p><p><strong>编译ONNX失败</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220724213831480.png" alt=""></p><p>这是因为没有安装proto compillar</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install protobuf-compiler libprotoc-dev</span><br></pre></td></tr></table></figure><p>成功安装如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220724213921185.png" alt=""></p><p><strong>配置环境变量</strong></p><p>在代码里面有大量使用系统环境变量的地方，需要事先将环境变量设置好</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220724214059962.png" alt=""><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220724214250591.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export DEVICE=j7export TIDL_TOOLS_PATH=&quot;/home/lcg/tidl/edgeai-tidl-tools&quot;</span><br></pre></td></tr></table></figure><p>临时修改环境比那两只需要在shell中直接执行export即可，如果需要一劳永逸，添加到<code>~/.bahsrc</code>中即可</p><h3 id="2，验证环境是否可用"><a href="#2，验证环境是否可用" class="headerlink" title="2，验证环境是否可用"></a>2，<strong>验证环境是否可用</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./scripts/run_python_examples.sh</span><br></pre></td></tr></table></figure><p>脚本中包含了很多验证的过程，如果哪一步骤出错，可以单独验证</p><p>如果出现这种情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: could not load library libvx_tidl_rt.so</span><br></pre></td></tr></table></figure><p>或者下面这种情况</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220724214337266.png" alt=""></p><p>需要在当前shell终端重新运行<code>source ./setup.sh</code>，配置当前终端环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/lcg/tidl/edgeai-tidl-tools/tidl_tools/tidl_graphVisualiser.out: error while loading shared libraries: libcgraph.so.6: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220724214547870.png" alt=""></p><p>没有找到<code>libcgraph.so</code>库，如果安装过，则把路径添加到<code>$ld_LIBRARY_PATH</code>即可</p><p>如果没有安装过，则<code>sudo apt install graphviz</code></p><p><strong>使用python脚本验证example</strong></p><p>python脚本可以同时完成模型转换和推理验证</p><p>使用如下命令生成artifacts，并生成结果图片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd examples/osrt_python/tflpython3 tflrt_delegate.py -c#具体 -c -d 参数可以参考代码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220724214626003.png" alt=""></p><p>如果能生成以上结果，就说明python运行example没有问题</p><p><strong>使用C++验证example</strong></p><p>C++的example只能完成推理验证，不能做模型转换。所以需要使用python代码生成的artifacts来做推理生成结果</p><p>C++的API需要读取<code>yaml</code>文件，所以需要单独安装一个库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libyaml-cpp-dev</span><br></pre></td></tr></table></figure><p>在<code>edgaai-tidl-tools</code>目录下创建<code>build</code>文件夹用来生成编译文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir build &amp;&amp; cd build</span><br></pre></td></tr></table></figure><p>在编译过程中，通过cmake设置参数来指定编译类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake-gui ../example</span><br></pre></td></tr></table></figure><p>•TENSORFLOW_INSTALL_DIR : defaults check at ~/tensorflow•ONNXRT_INSTALL_DIR: defaults check at ~/onnxruntime•DLR_INSTALL_DIR: defaults check at ~/neo-ai-dlr•OPENCV_INSTALL_DIR: defaults check at ~/opencv-4.1.0•ARMNN_PATH: defaults check at ~/armnn•TARGET_FS_PATH: defaults check ~/targetfs•CROSS_COMPILER_PATH: defaults check ~/gcc-arm-9.2-2019.12-x86_64-aarch64-none-linux-gnu</p><p>这里采用默认配置即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#例如你要修改opencv路径#cmake -DOPENCV_INSTALL_DIR=&quot;/home/opencv4.1&quot; -DTARGET_CPU=arm ../examplesmake -jcd ../</span><br></pre></td></tr></table></figure><p>在repo的根目录生成bin文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220724214808478.png" alt=""></p><p>运行example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># -f 指定artifacts，由python脚本生成# -i 指定输入图像./bin/Release/ort_main -f model-artifacts/od-ort-ssd-lite_mobilenetv2_fpn -i test_data/ADE_val_00001801.jpg</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220724215013969.png" alt=""></p><h3 id="3，SOC端推理"><a href="#3，SOC端推理" class="headerlink" title="3，SOC端推理"></a>3，SOC端推理</h3><p>在模型转化阶段生成的<code>artifacts</code>，此处就派上用场了</p><p>将文件夹拷贝到soc板，<code>./model-artifacts</code>,<code>models</code></p><p>这里的脚本只能验证流程是否跑通，并不能得到具体的精度数据，如果需要量化评估，需要参考ti 提供的benchmark[4]</p><h3 id="References-2"><a href="#References-2" class="headerlink" title="References"></a>References</h3><p><code>[1]</code> TF-Lite: <em><a href="https://www.tensorflow.org/lite/guide/inference">https://www.tensorflow.org/lite/guide/inference</a></em><br><code>[2]</code> TFLite Delgate API: <em><a href="https://www.tensorflow.org/lite/performance/delegates">https://www.tensorflow.org/lite/performance/delegates</a></em><br><code>[3]</code> 搭建环境: <em><a href="https://github.com/TexasInstruments/edgeai-tidl-tools/blob/master/README.md#setup">https://github.com/TexasInstruments/edgeai-tidl-tools/blob/master/README.md#setup</a></em><br><code>[4]</code> benchmark: <em><a href="https://github.com/TexasInstruments/edgeai-benchmark">https://github.com/TexasInstruments/edgeai-benchmark</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;TI 的 TDA4VM SoC 包含双核 A72、高性能视觉加速器、视频编解码器加速器、最新的 C71x 和 C66x DSP、用于捕获和显示的高带宽实时 IP、GPU、专用安全岛和安全加速器。SoC 经过功率优化，可为机器人、工业和汽车应用中的感知、传感器融合、定位和路径规划任务提供一流的性能。TDA4VM Edge AI Starter Kit (SK) 是一款低成本、小尺寸板，功耗大约20W，能提供8TOPS深度学习算力，支持Tensorflow Lite,ONNX,TVM,GStreamer接口&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ROS操作系统入门-3</title>
    <link href="http://yuanquanquan.top/2022/20220720/"/>
    <id>http://yuanquanquan.top/2022/20220720/</id>
    <published>2022-07-18T01:13:00.000Z</published>
    <updated>2022-07-18T01:30:35.091Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要：这篇文章主要介绍ROS常用工具、ROSPY和ROSCPP常用模块，完全看完三篇文章，可以说ROS就基本入门，可以自己动手做实验了。</p></blockquote><span id="more"></span><p><strong>ROS常用工具</strong></p><p>ROS工具的 功能大概有以下几个方向：仿真、调试、可视化。这里主要介绍常用工具作用，如何添加模块，设置参数B站都有视频，这里不会有过多解读。</p><p><strong>gazebo</strong>是一种最常用的机器人仿真工具，模拟器，也是目前独立的开源机器人仿真平台。gazebo可以进行机器人的动力学仿真，可以模仿机器人常用的传感器（比如激光雷达、摄像头、IMU等），也可以加载自定义的环境和场景。</p><p><strong>RViz</strong>是可视化工具，是将接收到的信息呈现出来；rviz和gazebo非常相似，但是gazebo实现的是仿真，提供一个虚拟世界，RVIZ实现的是可视化，呈现接收到的信息。</p><p><strong>rqt</strong>主要作用和RVIZ一致都是可视化，有了它我们可以直观的看到消息的通信架构和流通路径；</p><blockquote><p>常用命令：</p><p>rqt_graph :显示通信架构</p><p>rqt_plot ：绘制曲线</p><p>rqt_console ：查看日志</p></blockquote><p><strong>rosbag</strong>是一套用于记录和回放ROS主题的工具，此外还提供代码API，对包进行操作编写。</p><blockquote><p>常用命令：cheak 确定一个包是否可以在当前系统中进行，或者是否可以迁移。decompress 压缩一个或多个包文件。filter 解压一个或多个包文件。fix 在包文件中修复消息，以便在当前系统中播放。help 获取相关命令指示帮助信息info 总结一个或多个包文件的内容。play 以一种时间同步的方式回放一个或多个包文件的内容。record 用指定主题的内容记录一个包文件。reindex 重新索引一个或多个包文件。</p></blockquote><p><strong>rosbridge</strong>是一个用在ROS系统和其他系统之间的一个功能包,就像是它的名字一样,起到 一个”桥梁”的作用,使得ros系统和其他系统能够进行交互.Rosbridge为非ROS程序提供了 一个JSON API,有许多与Rosbridge进行交互的前端，包括一个用于Web浏览器交互的 WebSocket服务器。Rosbridge_suite是一个包含Rosbridge的元程序包，用于Rosbridge 的各种前端程序包（如WebSocket程序包）和帮助程序包。</p><p><strong>moveit</strong>它融合了研究者在运动规划、操纵、3D感知、运动学、控制和导航方面的最新进展，为操作 者提供了一个易于使用的平台，使用它可以开发先进的机器人应用，也被广泛应用于工业， 商业，研发和其他领域。move结构图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220718092217431.png" alt=""></p><h4 id="roscpp代码演示"><a href="#roscpp代码演示" class="headerlink" title="roscpp代码演示"></a>roscpp代码演示</h4><p>ROS为我们机器人开发者提供了不同语言的 接口，比如roscpp是C++语言ROS接口（目前最广泛应用的ROS客户端库，执行效率高），rospy是python语言的ROS接口（开发效率高，通常用在对运行时间没有太大要求的场合，例如配置、初始化等操作），rosjava是java语言的ROS接口（测试版本） 我们直接调用它所 提供的函数就可以实现topic、service等通信功能。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220718092243887.png" alt=""></p><p>roscpp位于 /opt/ros/kinetic 之下，用C++实现了ROS通信。在ROS中，C++的代码是通过 catkin这个编译系统（扩展的CMake）来进行编译构建的。每一个node的节点功能可能不一样，但是都包含初始化、销毁、句柄等操作。</p><ul><li><strong>ROS代码逻辑整体</strong></li></ul><p>常见的ros代码逻辑包含下面的执行步骤：</p><p>1.调用ros::init()函数初始化节点的名称和其他信息</p><p>2.创建ros::NodeHandle对象，也就是节点句柄，用于创建Pub、Sub(NodeHandle就是节点资源的描述，需要借助“把手”才能操作资源)</p><p>3调用ros::shutdown()手动关闭节点（一般是系统自动帮我们完成）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;ros/ros.h&gt;</span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">ros::init(argc, argv, &quot;your_node_name&quot;);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">//....节点功能</span><br><span class="line">//创建话题的publisher</span><br><span class="line">ros::Publisher advertise(const string &amp;topic, uint32_t queue_size, bool latch=false);</span><br><span class="line">//创建话题的subscriber</span><br><span class="line">ros::Subscriber subscribe(const string &amp;topic, uint32_t queue_size, void(*)(M));</span><br><span class="line">//创建服务的server，提供服务</span><br><span class="line">ros::ServiceServer advertiseService(const string &amp;service, bool(*srv_func)(Mreq &amp;, Mre</span><br><span class="line">s &amp;));</span><br><span class="line">//创建服务的client</span><br><span class="line">ros::ServiceClient serviceClient(const string &amp;service_name, bool persistent=false);</span><br><span class="line">//查询某个参数的值</span><br><span class="line">bool getParam(const string &amp;key, std::string &amp;s);</span><br><span class="line">bool getParam (const std::string &amp;key, double &amp;d) const；</span><br><span class="line">bool getParam (const std::string &amp;key, int &amp;i) const；</span><br><span class="line">//给参数赋值</span><br><span class="line">void setParam (const std::string &amp;key, const std::string &amp;s) const；</span><br><span class="line">void setParam (const std::string &amp;key, const char *s) const;</span><br><span class="line">void setParam (const std::string &amp;key, int i) const;</span><br><span class="line">//....</span><br><span class="line">ros::spin();//用于触发topic、service的响应队列</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>roscpp的主要部分包括：<strong>ros::init() : 解析传入的ROS参数，创建node第一步需要用到的函数**</strong>ros::NodeHandle : 和topic、service、param等交互的公共接口<strong>**ros::master : 包含从master查询信息的函数</strong>ros::this_node：包含查询这个进程(node)的函数<strong>ros::service：包含查询服务的函数**</strong>ros::param：包含查询参数服务器的函数，而不需要用到NodeHandle**ros::names：包含处理ROS图资源名称的函数</p><p>具体可见：<a href="http://docs.ros.org/api/roscpp/html/index.html">http://docs.ros.org/api/roscpp/html/index.html</a></p><p>以上功能可以分为以下几类：Initialization and Shutdown 初始与关闭Topics 话题Services 服务Parameter Server 参数服务器Timers 定时器NodeHandles 节点句柄Callbacks and Spinning 回调和自旋（或者翻译叫轮询？）Logging 日志Names and Node Information 名称管理Time 时钟Exception 异常</p></blockquote><ul><li><p><strong>回调函数与spin()方法</strong></p><p><strong>CallBack回调函数与ros::spin() 方法需要配合使用，当消息传来时，只指定回调函数，系统不会自动触发，必须要 ros::spin() 或 者 ros::spinOnce() 才能真正使回调函数生效。</strong>处理流程：回调函数一般作为参数传到另外一个函数（一般是函数指针），当消息message到达时，先会把消息放到一个队列中，当有spin函数执行时，就会处理消息队列队首的信息。spin具体的处理方法可以分成阻塞/非阻塞，单线程/多线程两种。</p><p>| spin方法                      | 阻塞   | 线程   |<br>| —————————– | —— | —— |<br>| ros::spin()                   | 阻塞   | 单线程 |<br>| ros::spinOnce()               | 非阻塞 | 单线程 |<br>| ros::MultiTreadedSpin()       | 阻塞   | 多线程 |<br>| ros::AsyncMultiThreadedSpin() | 非阻塞 | 多线程 |</p></li><li><p><strong>ROS节点编写</strong></p><p>基本流程，首先创建一个工作空间workplace，然后根据实际需要创建相应的包package，编写相应的需求文件，如源文件;根据编译运行需要，补充CMakeLists.txt、package.xml相应说明，如添加依赖，查找相关包，运行所需要的包，消息类型等等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p xxx_ws   //创建工作空间</span><br><span class="line">catkin_make     //编译工作空间</span><br><span class="line">//打开.bashrc 设置xxx_ws工作空间的环境变量</span><br><span class="line">catkin_create_pkg xxxx（包） xx(依赖)   //创建包</span><br></pre></td></tr></table></figure></li></ul><p>\1. <strong>编写一个talker的node</strong></p><p>在工作空间的src/目录下，第1步，创建一个talker的包study：$ catkin_create_pkg study roscpp第2步，打开vcode（或者其他ide），study/src，创建源文件study_node.cpp,代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;ros/ros.h&quot;</span><br><span class="line">#include&quot;std_msgs/String.h&quot;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">//编写一个node并发布出来</span><br><span class="line">int main(int argc,char **argv)&#123;</span><br><span class="line">   ros::init(argc,argv,&quot;study_talker&quot;);//定义node的属性</span><br><span class="line">   ros::NodeHandle n;//ros提供的一个类，可以实例化publisher,进行发布数据</span><br><span class="line">   ros::Publisher study_pub=n.advertise&lt;std_msgs::String&gt;(&quot;/study_topic&quot;,10);</span><br><span class="line">   //定义node要发布的topic的名称，以及发布的有效率（表示10为有效的，如果很久都没有缓存进去，那么早期发布的就会被释放掉）</span><br><span class="line">   ros::Rate loop_rate(10);//每秒发布10次</span><br><span class="line"></span><br><span class="line">   int count=0;//记录发布的次数</span><br><span class="line"></span><br><span class="line">   while(ros::ok())&#123;</span><br><span class="line">       //ros：：ok的作用是，只要ros master正常运行，如果没有中断操作，都会继续运行的</span><br><span class="line">       std_msgs::String msg;//定义要发布到ros里面的变量名称，或者实例化一个对象来保存要发布的消息</span><br><span class="line">       std::stringstream ss;//定义c++变量来保存输出的变量</span><br><span class="line">       ss&lt;&lt;&quot;hello study world!&quot;&lt;&lt;count;//输出的字符串以及次数</span><br><span class="line">       count++;//次数自加</span><br><span class="line">       msg.data=ss.str();//发布的字符串封装到ros变量</span><br><span class="line">       study_pub.publish(msg);//把消息通过ros上面 定义的publisher发布出去</span><br><span class="line">       loop_rate.sleep();//暂停0.1秒</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第3步，设置CMakeLists.txt&amp;package.xmlCMakeLists.txt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">roscpp</span><br><span class="line">std_msgs</span><br><span class="line">)//告诉系统编译本包时，需要找到这两个包</span><br><span class="line"></span><br><span class="line">catkin_package(</span><br><span class="line"># INCLUDE_DIRS include</span><br><span class="line"># LIBRARIES study</span><br><span class="line">CATKIN_DEPENDS roscpp std_msgs</span><br><span class="line"># DEPENDS system_lib</span><br><span class="line">)//声明依赖本包同时需要里面这两个ros包</span><br><span class="line"></span><br><span class="line">add_executable($&#123;PROJECT_NAME&#125;_node src/study_node.cpp)//编译本包生成的可执行文件</span><br><span class="line"></span><br><span class="line">add_dependencies($&#123;PROJECT_NAME&#125;_node $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)//链接可执行文件和依赖库</span><br><span class="line"></span><br><span class="line">//一般情况而已，CMakeLists.txt是创建包同时，系统自动生成的，然后，我们需要的工作，一般情况就是把上面基本地方去掉#号就行了（目的告诉系统，关于该包，在哪，依赖是啥）</span><br></pre></td></tr></table></figure><p>package.xml：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;roscpp&lt;/build_depend&gt;</span><br><span class="line">&lt;build_depend&gt;std_msgs&lt;/build_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;roscpp&lt;/exec_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;</span><br><span class="line">//主要修改类似样式，当然，本例子比较简单，系统生成的，不需要做其他修改，但是，如果节点添加新的依赖，需要在这些地方添加相应的包</span><br></pre></td></tr></table></figure><p>第4步，编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ catkin_make  #注意在要做工作空间的一级目录下使用该指令</span><br></pre></td></tr></table></figure><p>第5步，验证,终端运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ roscore &amp; #后台运行一个ROS master</span><br><span class="line">$ rosrun study study_node &amp; #后台运行包名+节点名</span><br><span class="line">$ rostopic list #</span><br><span class="line">/study_topic //表示定义的topic正常发布</span><br><span class="line">/rosout</span><br><span class="line">/rosout_agg</span><br><span class="line">$ rostopic echo #查看study_topic</span><br><span class="line">data: &quot;hello study world!2360&quot;//表示发布成功</span><br><span class="line">---</span><br><span class="line">data: &quot;hello study world!2361&quot;</span><br></pre></td></tr></table></figure><p>这时，从零开始创建的talker节点node，成功创建完成</p><p>\2. <strong>编写一个listener的node</strong></p><p>在工作空间的src/目录下，第1步，创建一个listener的包study_listen：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ catkin_create_pkg study_listen roscpp</span><br></pre></td></tr></table></figure><p>第2步，study_listen/src，创建源文件study_listen_node.cpp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;ros/ros.h&quot;</span><br><span class="line">#include&quot;std_msgs/String.h&quot;</span><br><span class="line"></span><br><span class="line">//创建一个listener的node</span><br><span class="line">void studyCallback(const std_msgs::String::ConstPtr&amp; msg)&#123;</span><br><span class="line">   //回调函数一定是要求是无返回类型</span><br><span class="line">   ROS_INFO(&quot;I can see you again,%s&quot;,msg-&gt;data.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc,char ** argv)&#123;</span><br><span class="line">   ros::init(argc,argv,&quot;study_listener&quot;);//初始化这么一个node</span><br><span class="line">   ros::NodeHandle n;//命名空间</span><br><span class="line">   ros::Subscriber sub=n.subscribe(&quot;study_topic&quot;,10,studyCallback);</span><br><span class="line">   //表示聆听study_topic这个主题，每次听到就会启动回调函数，这里的10也表示一个缓冲数量，多了，前面的会被是放掉</span><br><span class="line">   //这里一定要注意，聆听的topic一定要和发布的topic的名称对应上，否则，是没办法接收的</span><br><span class="line">   ros::spin();</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第3步，设置CMakeLists.txt&amp;package.xmlCMakeLists.txt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line"> roscpp</span><br><span class="line"> std_msgs</span><br><span class="line">)//告诉系统编译本包时，需要找到这两个包</span><br><span class="line"></span><br><span class="line">catkin_package(</span><br><span class="line"># INCLUDE_DIRS include</span><br><span class="line"># LIBRARIES study</span><br><span class="line">CATKIN_DEPENDS roscpp std_msgs</span><br><span class="line"># DEPENDS system_lib</span><br><span class="line">)//声明依赖本包同时需要里面这两个ros包</span><br><span class="line"></span><br><span class="line">add_executable($&#123;PROJECT_NAME&#125;_node src/study_listen_node.cpp)//编译本包生成的可执行文件</span><br><span class="line"></span><br><span class="line">add_dependencies($&#123;PROJECT_NAME&#125;_node $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;)//链接可执行文件和依赖库</span><br><span class="line"></span><br><span class="line">//一般情况而已，CMakeLists.txt是创建包同时，系统自动生成的，然后，我们需要的工作，一般情况就是把上面基本地方去掉#号就行了（目的告诉系统，关于该包，在哪，依赖是啥）</span><br></pre></td></tr></table></figure><p>package.xml：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;roscpp&lt;/build_depend&gt;</span><br><span class="line">&lt;build_depend&gt;std_msgs&lt;/build_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;roscpp&lt;/exec_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;</span><br><span class="line">//主要修改类似样式，当然，本例子比较简单，系统生成的，不需要做其他修改，但是，如果节点添加新的依赖，需要在这些地方添加相应的包</span><br></pre></td></tr></table></figure><p>第4步，编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ catkin_make  #注意在要做工作空间的一级目录下使用该指令</span><br></pre></td></tr></table></figure><p>第5步，验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ roscore &amp; #运行一个ROS master</span><br><span class="line">$ rosrun study study_node &amp; #包名+节点名;由于测试listener的节点，所以需要启动一个talker的node才行</span><br><span class="line">$ rostopic echo #study_topic</span><br><span class="line">data: &quot;hello study world!432&quot;</span><br><span class="line">---</span><br><span class="line">data: &quot;hello study world!433&quot; //表示发布成功</span><br><span class="line">#开启一个新终端</span><br><span class="line">$ rosrun study study_listen_node #包名+节点名</span><br><span class="line">[ INFO] [1606043574.419247936]: I can see you again,hello study world!178 //表示监听成功</span><br></pre></td></tr></table></figure><p>这时，从零开始创建的listener节点node，成功创建完成</p><p>\3. <strong>自定义消息类型并发布演示</strong></p><p>这里主要就是定义一个消息类型是重点，然后，在上面创建的talker以及listener包里面头文件包含，然后在CMakeLists.txt&amp;package.xml两文件中，添加新的头文件类型即可使用新定义的消息类型了。</p><p>第一步，创建一个包:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ catkin_create_pkg study_msgs std_msgs roscpp</span><br></pre></td></tr></table></figure><p>第二步，在包创建一个msg文件夹(<strong>注意文件夹名称一定是这样子的，否则，在cmakelists要修改很多</strong>)</p><p>第三步，在文件夹中新建文件，<code>StudyMsg.msg</code>（注意命名方式以及后缀）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string detail</span><br><span class="line">int32 id</span><br></pre></td></tr></table></figure><p><strong>注意，自定义的消息类型，记得一定不能写其他说明性内容进去，否则发生编译错误</strong></p><p>第四步，设置CMakeLists.txt&amp;package.xmlCMakeLists.txt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">roscpp</span><br><span class="line">std_msgs message_generation</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">## Generate messages in the &#x27;msg&#x27; folder//这里可以看出，系统只会在msg文件夹中查找，对应第二步</span><br><span class="line">add_message_files(</span><br><span class="line">  FILES</span><br><span class="line">  StudyMsg.msg</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">## Generate added messages and services with any dependencies listed here</span><br><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>package.xml：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;message_generation&lt;/build_depend&gt; </span><br><span class="line">  &lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;</span><br></pre></td></tr></table></figure><p>第五步，编译，<code>catkin_make</code></p><p>第六步，查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd include/study_msgs</span><br><span class="line">$ ls</span><br><span class="line">StudyMsg.h   //表示该头文件生成成功</span><br></pre></td></tr></table></figure><p>这时候，自定义消息类型生成成功，并且，可以被其他包通过头文件#include”study_msgs/StudyMsg.h”方式，就可以正常使用。下面，以发布一个talker节点来展示，并且发布的topic名称为/study_topic_new当然，CMakeLists.txt&amp;package.xml要做相应的补充，CMakeLists.txt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">roscpp</span><br><span class="line">std_msgs study_msgs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">catkin_package(</span><br><span class="line"># INCLUDE_DIRS include</span><br><span class="line"># LIBRARIES study</span><br><span class="line">CATKIN_DEPENDS roscpp std_msgs study_msgs</span><br><span class="line"># DEPENDS system_lib</span><br><span class="line">)</span><br><span class="line">//两者都是添加新消息类型study_msgs</span><br></pre></td></tr></table></figure><p>package.xml：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;study_msgs&lt;/build_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;study_msgs&lt;/exec_depend&gt;</span><br><span class="line">//添加新消息类型study_msgs</span><br></pre></td></tr></table></figure><p>此时，study_node.cpp为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;ros/ros.h&quot;</span><br><span class="line">#include&quot;std_msgs/String.h&quot;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&quot;study_msgs/StudyMsg.h&quot;//使用自定义消息类型</span><br><span class="line"></span><br><span class="line">int main(int argc,char **argv)&#123;</span><br><span class="line">   ros::init(argc,argv,&quot;study_talker&quot;);//node&#x27;s attribute name</span><br><span class="line">   ros::NodeHandle n;</span><br><span class="line">   ros::Publisher study_pub=n.advertise&lt;std_msgs::String&gt;(&quot;/study_topic&quot;,10);//define publisher&#x27;s topic</span><br><span class="line">   ros::Publisher study_pub_new=n.advertise&lt;study_msgs::StudyMsg&gt;(&quot;/study_topic_new&quot;,10);//新定义消息发布的主题名称定义</span><br><span class="line">   ros::Publisher study_pub_param=n.advertise&lt;study_msgs::StudyMsg&gt;(&quot;/params_topic&quot;,10);</span><br><span class="line">   </span><br><span class="line">   ros::Rate loop_rate(10);//10 per/s</span><br><span class="line"></span><br><span class="line">   int count=0;</span><br><span class="line"></span><br><span class="line">   while(ros::ok())&#123;</span><br><span class="line">       std_msgs::String msg;</span><br><span class="line">       std::stringstream ss;</span><br><span class="line">       //std::stringstream ss_new;</span><br><span class="line">       ss&lt;&lt;&quot;hello study world!&quot;&lt;&lt;count;</span><br><span class="line">       count++;</span><br><span class="line">       msg.data=ss.str();</span><br><span class="line">       study_pub.publish(msg);</span><br><span class="line"></span><br><span class="line">       //使用自定义消息类型发布消息</span><br><span class="line">       study_msgs::StudyMsg studyMsg;</span><br><span class="line">       studyMsg.id=count;//发布内容的id</span><br><span class="line">       studyMsg.detail=&quot;hello study world! new&quot;;//自定义消息类型发布的内容datail</span><br><span class="line">       study_pub_new.publish(studyMsg);</span><br><span class="line">       loop_rate.sleep();//pause 0.1s</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终端查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ rostopic echo /study_topic_new </span><br><span class="line">---</span><br><span class="line">detail: &quot;hello study world! new&quot;</span><br><span class="line">id: 29975</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>\4. <strong>参数中心rosparam的使用演示</strong></p><p>开始展示之前，一定要记得在study_listen包的CMakeLists.txt&amp;package.xml做好跟上面的talker包study一样准备，保证可以使用自定义消息类型。</p><p>study_node.cpp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;ros/ros.h&quot;</span><br><span class="line">#include&quot;std_msgs/String.h&quot;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&quot;study_msgs/StudyMsg.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc,char **argv)&#123;</span><br><span class="line">   ros::init(argc,argv,&quot;study_talker&quot;);//node&#x27;s attribute name</span><br><span class="line">   ros::NodeHandle n;</span><br><span class="line">   ros::Publisher study_pub=n.advertise&lt;std_msgs::String&gt;(&quot;/study_topic&quot;,10);//define publisher&#x27;s topic</span><br><span class="line">   ros::Publisher study_pub_new=n.advertise&lt;study_msgs::StudyMsg&gt;(&quot;/study_topic_new&quot;,10);//测试新定义消息类型</span><br><span class="line">   ros::Publisher study_pub_param=n.advertise&lt;study_msgs::StudyMsg&gt;(&quot;/params_topic&quot;,10);//测试参数中心</span><br><span class="line">   </span><br><span class="line">   ros::Rate loop_rate(10);//10 per/s</span><br><span class="line"></span><br><span class="line">   int count=0;</span><br><span class="line"></span><br><span class="line">   while(ros::ok())&#123;</span><br><span class="line">       std_msgs::String msg;</span><br><span class="line">       std::stringstream ss;</span><br><span class="line">       //std::stringstream ss_new;</span><br><span class="line">       ss&lt;&lt;&quot;hello study world!&quot;&lt;&lt;count;</span><br><span class="line">       count++;</span><br><span class="line">       msg.data=ss.str();</span><br><span class="line">       study_pub.publish(msg);</span><br><span class="line"></span><br><span class="line">//发布新定义消息类型</span><br><span class="line">       study_msgs::StudyMsg studyMsg;</span><br><span class="line">       studyMsg.id=count;</span><br><span class="line">       studyMsg.detail=&quot;hello study world! new&quot;;</span><br><span class="line">       study_pub_new.publish(studyMsg);</span><br><span class="line"></span><br><span class="line">       //测试参数中心</span><br><span class="line">       study_msgs::StudyMsg studyMsg_param;</span><br><span class="line">       std::string param_string;</span><br><span class="line">       n.param&lt;std::string&gt;(&quot;myparam&quot;,param_string,&quot;cc&quot;);//通过该myparam可以重新定义发布的消息，否则 会一直使用用的是默认值 cc</span><br><span class="line">       studyMsg_param.detail=param_string;</span><br><span class="line">       studyMsg_param.id=count;</span><br><span class="line">       study_pub_param.publish(studyMsg_param);</span><br><span class="line"></span><br><span class="line">       loop_rate.sleep();//pause 0.1s</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>study_listen_node.cpp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;ros/ros.h&quot;</span><br><span class="line">#include&quot;std_msgs/String.h&quot;</span><br><span class="line">#include&quot;study_msgs/StudyMsg.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void studyCallback(const std_msgs::String::ConstPtr&amp; msg)&#123;</span><br><span class="line">  ROS_INFO(&quot;I can see you again,%s &quot;,msg-&gt;data.c_str());</span><br><span class="line">&#125;//测试是监听study_topic成功与否</span><br><span class="line"></span><br><span class="line">void studyCallback_new(const study_msgs::StudyMsg::ConstPtr&amp; msg)&#123;</span><br><span class="line">  ROS_INFO(&quot;I think I cant forget you,%s,%d&quot;,msg-&gt;detail.c_str(),msg-&gt;id);</span><br><span class="line">&#125;//测试监听自定义消息成功与否</span><br><span class="line"></span><br><span class="line">void studyCallback_param(const study_msgs::StudyMsg::ConstPtr&amp; msg)&#123;</span><br><span class="line">  ROS_INFO(&quot;I think I cant forget you,%s,%d&quot;,msg-&gt;detail.c_str(),msg-&gt;id);</span><br><span class="line">&#125;//测试rosparam参数中心是否工作成功</span><br><span class="line"></span><br><span class="line">int main(int argc,char ** argv)&#123;</span><br><span class="line">  ros::init(argc,argv,&quot;study_listener&quot;);</span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line">  ros::Subscriber sub=n.subscribe(&quot;/study_topic&quot;,10,studyCallback);</span><br><span class="line">  ros::Subscriber sub_new=n.subscribe(&quot;study_topic_new&quot;,10,studyCallback_new);</span><br><span class="line">  ros::Subscriber sub_param=n.subscribe(&quot;/params_topic&quot;,10,studyCallback_param);</span><br><span class="line">  ros::spin();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改了上面的两个文件，接下来就是编译整个工作空间并成功，接着在终端执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ roscore &amp;  #启动ros master</span><br><span class="line">$ rosrun study study_node &amp; #启动talker节点</span><br><span class="line">$ rosrun study_listen study_listen_node #启动listener节点</span><br><span class="line">[ INFO] [1606047990.464340880]: I can see you again,hello study world!99 </span><br><span class="line">[ INFO] [1606047990.464436530]: I think I cant forget you,hello study world! new,100</span><br><span class="line">[ INFO] [1606047990.476383810]: I think I cant forget you,cc,100</span><br></pre></td></tr></table></figure><p>这时候我们发现，上面我们定义的回调函数，都成功调用了（表示上面的talker/listener/自定义消息 类型都是编写并运行正常的）当我们在终端2启动参数中心rosparam设置参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosparam set /myparam &quot;yqy&quot;</span><br></pre></td></tr></table></figure><p>终端1的显示调整为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ INFO] [1606048163.371016634]: I can see you again,hello study world!368 </span><br><span class="line">[ INFO] [1606048163.371113447]: I think I cant forget you,hello study world! new,369</span><br><span class="line">[ INFO] [1606048163.394940978]: I think I cant forget you,yqy,369</span><br></pre></td></tr></table></figure><p>也就是将周期第三个，cc调整为yqy了。</p><p>本章小结：创建一个包，需要定义好CmakeLists.txt 、package.xml两个文件，主要就是告诉系统，我这个包编译和运行时依赖是什么;talker和listener的编写也是基本套路一样的，重新发布的主题以及消息类型以及内容就发布ok了;listener的回调函数，注意是无返回类型的;重新自定义一个消息类型，注意文件夹命名以及文件后缀名称。基本是这些。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要：这篇文章主要介绍ROS常用工具、ROSPY和ROSCPP常用模块，完全看完三篇文章，可以说ROS就基本入门，可以自己动手做实验了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="ROS" scheme="http://yuanquanquan.top/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>ROS操作系统入门（2）</title>
    <link href="http://yuanquanquan.top/2022/20220719/"/>
    <id>http://yuanquanquan.top/2022/20220719/</id>
    <published>2022-07-18T01:12:50.000Z</published>
    <updated>2022-07-18T01:45:28.801Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>ROS的通信架构是ROS的灵魂所在，它包括数据处理，进程运行，消息传递等</strong>。这篇文章主要介绍ROS1的通信架构的基础通信方式和相关概念，因为ROS1和ROS2的通信方式相差很大，文章后面会介绍ROS2 的通信框架和差异。</p></blockquote><span id="more"></span><p>接下来介绍一下三组概念：master<-->node<-->launch、topic<-->msg、service<-->srv<-->parameter <-->action.</p><h4 id="一、masternodelaunch"><a href="#一、masternodelaunch" class="headerlink" title="一、masternodelaunch"></a>一、master<-->node<-->launch</h4><p><strong>node:</strong>ROS最小的进程单元就是节点node。一个软件包里面有多个可执行文件，可执行文件被运行就是进程（process）,这个进程就是节点node。</p><blockquote><p><strong>rosnode list 列出当前运行的node信息</strong></p><p><strong>rosnode info node_name 显示出node的详细信息</strong></p><p><strong>rosnode kill node_name 结束某个node</strong></p><p>rosnode ping 测试链接节点</p><p>rosnode machine 列出在特定机器或列表机器上运行的节点</p><p>rosnode cleanup  清除不可到达节点的注册信息</p></blockquote><p><strong>master:</strong>ROS网络架构的管理中心，管理着各个node。node先在master进行注册，node之间通信需要经过master编排才能点对点的通信。所以ROS程序启动，<strong>第一步先执行roscore指令启动master,执行指令后同时启动的还有rosout（负责日志输出、记录当前系统状态）和parameter server（参数服务器，非node,负责存储参数配置） ,再由节点管理器按照cmakelists.txt、package.xml配置执行rosrun pkgname node_name 依次启动node</strong>。</p><p><strong>launch:</strong>复杂节点启动管理文件。执行roslaunch pkg_name file_name.launch 指令后，首先系统先检测roscore是否启动，如果没有启动会默认自动拉起。然后按照launch配置启动规则，有序启动多个节点，减少终端输入。</p><h4 id="二、topicmsg"><a href="#二、topicmsg" class="headerlink" title="二、topicmsg"></a>二、topic<-->msg</h4><p>ROS1的通信方式有四种：topic主题，service服务，parameter service 参数服务器 ,actionlib动作库。</p><p><strong>topic：</strong>ROS通信最常用的一种，对实时性、周期性消息，使用topic传输是最佳选择。简单的说，启动topic 首先需要publisher和subscriber 节点到master进行注册，然后publisher 会发布topic，subscriber在master指挥下会订阅topic,从而建立sub-pub之间的通信。<strong>一个topic可以有多个publisher,一个publisher可以同时向多个subscriber发送消息，subscriber 接收消息会进行处理（回调函数 callback），publisher发送消息后就继续执行下一个动作，消息的状态和处理结构都不会影响publisher执行，subscriber只管消息接受和处理，publisher挂死不会对subscriber节点状态影响,所以topic通信实现了node之间的解耦，此通信方式属于异步通信。</strong></p><blockquote><p><strong>rostopic list 列出当前所有topic</strong></p><p>rostopic info topic_name  显示某个topic的属性信息</p><p><strong>rostopic echo topic_name 显示某个topic的内容</strong></p><p><strong>rostopic pub topic_name 向某个topic发布内容</strong></p><p>rostopic bw topic_name 查看某个topic的带宽</p><p>rostopic hz 查看某个topic的频率</p><p>rostopic find topic_type 查看某个类型的topic</p><p>rostopic type topic_name 查看某个topic类型的msg</p></blockquote><p><strong>message:</strong>直观查看message就是一种数据格式。严格说按照规定的格式发送的数据就是message消息，所以消息既是内容也是标准格式。基本的msg包括bool、int8、int16、int32、int64(以及uint)、float、float64、string、time、 duration、header、可变长数组array[]、固定长度数组array[C]。</p><blockquote><p>rosmsg list 列出系统消息</p><p>rosmsg show msg_name 显示某个msg的格式</p><p>—常见消息名称–</p><p>Vector 矢量; 向量</p><p>twist  转动，旋转</p><p>covariance  协方差；协变性；共离散;</p><p>Odometry 里程计</p><p>quaternion  四元组</p></blockquote><ul><li><strong>话题的通信机制</strong></li></ul><p><strong>此处假设 Talker 首先启动，可分成图中所示的七步来分析建立通信的详细过程：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220718093240280.png" alt=""></p><ol><li><p><strong>Talker 注册</strong>Talker 启动，通过 1234 端口使用 RPC 向 ROS Master 注册发布者的信息，包含所发布消息的话题名；ROS master 会将节点的注册信息加入注册列表中。</p></li><li><p><strong>Listener 注册</strong>Listener 启动，同样通过 RPC 向 ROS Master 注册订阅者的信息，包含需要订阅的话题名。</p></li><li><p><strong>ROS Master 进行信息匹配</strong>Master 根据 Listener 的订阅信息从注册列表中进行查找，如果没有找到匹配的发布者，则等待发布者的加入；如果找到匹配的发布者信息，则通过 RPC 向 Listener 发布 Talker 的 RPC 地址信息。</p></li><li><p><strong>Listener 发送连接请求</strong>Listener 接收到 Master 发回的 Talker 地址信息，尝试通过 RPC 向 Talker 发送连接请求，传输订阅的话题名、消息类型以及通信协议（TCP/UDP）。</p></li><li><p><strong>Talker 确认连接请求</strong>Talker 接收到 listener 发送的连接请求后，继续通过 RPC 向 Listener 确认链接信息，其中包含自身的 TCP 地址信息。</p></li><li><p><strong>Listener 尝试与 Talker 建立网络连接</strong>Listener 接收到确认信息后，使用 TCP 尝试与 Talker 建立网络连接。</p></li><li><p><strong>Talker 向 Listener 发布数据</strong>成功建立连接后，Talker 开始向 Listener 发送话题消息数据。</p><p><strong>从上面的分析中可以发现，前五个步骤使用的通信协议都是 RPC，最后发布数据的过程才使用到 TCP。ROS Master 在节点建立连接的过程中起到了重要作用，但是并不参与节点之间最终的数据传输。</strong></p></li></ol><h4 id="三、servicesrvparameter-action"><a href="#三、servicesrvparameter-action" class="headerlink" title="三、servicesrvparameter action"></a>三、service<-->srv<-->parameter <-->action</h4><p><strong>service:</strong> 请求–查询双向同步通信模型，service分层两部分，客户端（client）和服务端（server）。客户端(client)发送请求(request)要等服务端(server)处理，反馈回复（reply）才会发送下一个请求到服务端（server）.</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220718093251928.png" alt=""></p><table><thead><tr><th>名称</th><th>topic</th><th>service</th></tr></thead><tbody><tr><td>通信方式</td><td>异步通信</td><td>同步通信</td></tr><tr><td>实现原理</td><td>TCP/IP</td><td>TCP/IP</td></tr><tr><td>通信模型</td><td>publisher/subscriber</td><td>request/replay</td></tr><tr><td>映射关系</td><td>多对多</td><td>多对一</td></tr><tr><td>特点</td><td>subs收到数据会回调callback</td><td>远程过程调用（RPC）服务器端的服务</td></tr><tr><td>应用场景</td><td>连续、高频的数据发布</td><td>偶尔使用的功能、具体任务</td></tr><tr><td>举例</td><td>激光雷达、里程计发布数据</td><td>拍照、逆解计算、开关传感器</td></tr></tbody></table><p>注意：远程过程调用（RPC）可以理解为一个进程里面调用另外一个进程的函数。</p><blockquote><p>rosservice list 显示服务列表</p><p>rosservice info 打印服务信息</p><p>rosservice type 打印服务类型</p><p>rosservice uri 打印服务ROSRPC uri(统一资源标识，URI包含URL)</p><p><strong>rosservice call 使用所提供的args调用服务</strong></p><p>rosservice args 打印服务参数</p><p>rosservice find 查找服务</p></blockquote><p><strong>srv:</strong>service的数据类型，service通信的数据格式定义在*srv中，包含请求（request）和响应（reply）两部分。</p><blockquote><p>rossrv show 显示服务描述</p><p>rossrv list 列出所有服务</p><p>rossrv md5 显示服务md5</p><p>rossrv package 列出包服务</p><p>rossrv packages 列出包含服务的包</p></blockquote><ul><li><strong>服务通信机制</strong></li></ul><p><strong>服务是一种带有应答的通信机制，通信原理如下图所示，与话题的通信相比，其减少了 Listener 与 Talker 之间的 RPC 通信。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220718093259591.png" alt=""></p><ol><li><strong>Talker 注册</strong>Talker 启动，通过 1234 端口使用 RPC 向 ROS Master 注册发布者的信息，包含所发布消息的话题名；ROS master 会将节点的注册信息加入注册列表中。</li><li><strong>Listener 注册</strong>Listener 启动，同样通过 RPC 向 ROS Master 注册订阅者的信息，包含需要订阅的服务名。</li><li><strong>ROS Master 进行信息匹配</strong>Master 根据 Listener 的订阅信息从注册列表中进行查找，如果没有找到匹配的服务提供者，则等待该服务提供者的加入；如果找到匹配的服务提供者信息，则通过 RPC 向 Listener 发布 Talker 的 TCP 地址信息。</li><li><strong>Listener 尝试与 Talker 建立网络连接</strong>Listener 接收到确认信息后，使用 TCP 尝试与 Talker 建立网络连接，并发送服务的请求数据。</li><li><strong>Talker 向 Listener 发布数据</strong>Talker 接收到服务请求和参数后，开始执行服务功能，执行完成后，向 Listener 发送应答数据。</li></ol><p><strong>parameter server:</strong>参数服务器维护的一般是静态数据字典，它使用互联网传输，在节点管理器master中运行，实现整个通信。</p><blockquote><p><strong>rosparam set param_key param_value 设置参数**</strong>rosparam get param_key 显示参数<strong>**rosparam load file_name 从文件加载参数</strong>(yaml格式)<strong>rosparam dump file_name 保存参数到文件</strong>(yaml格式)<strong>rosparam delete 删除参数</strong>rosparam list 列出参数名称</p></blockquote><ul><li><p><strong>参数管理机制</strong></p><p>参数类似于 ROS 中的全局变量，由 ROS Master 进行管理，其通信机制较为简单，不涉及 TCP/UDP 的通信。</p></li></ul><p>  <img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220718093316902.png" alt=""></p><ol><li><strong>Talker 设置变量</strong>Talker 使用 RPC 向 ROS Master 发送参数设置数据，包含参数名和参数值；ROS Master 会将参数名和参数值保存到参数列表中。</li><li><strong>Listener 查询参数值</strong>Listener 通过 RPC 向 ROS Master 发送参数查找请求，包含索要查找的参数名。</li><li><strong>ROS Master 向 Listener 发送参数值</strong>Master 根据 Listener 的查找请求从参数列表中进行查找，查找到参数后，使用RPC 将参数数值发送给 Listener。</li></ol><p><strong>这里需要注意的是，如果 Talker 向 Master 更新参数值，Listener 在不重新查询参数值的情况下是无法知晓参数值已经被更新的。所以在很多场景中，需要一种动态参数更新机制。</strong></p><p><strong>action:</strong>动作类似service,属于请求–查询双向同步通信模型，但是通信过程连续反馈状态信息和随时终止请求。通信双方在action protocol 下通过消息进行数据交流，client和server为用户提供API来请求目标或者通过函数调用和回调来执行目标。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220718093326076.png" alt=""></p><p><strong>action protocal:</strong>action协议包含三部分,目标（设定终点），反馈（实时状态信息），结果（时长、最终姿态）。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220718093338738.png" alt=""></p><h4 id="ROS1和ROS2通信架构比对"><a href="#ROS1和ROS2通信架构比对" class="headerlink" title="ROS1和ROS2通信架构比对"></a>ROS1和ROS2通信架构比对</h4><p>这里主要给大家介绍ROS2和ROS1的通信架构区别，ROS1和ROS2的架构如下，可以分成3层：OS层、中间层和应用层</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220718093347251.png" alt=""></p><ul><li>OS层：ROS1主要构建在Linux上，但ROS2支持多个操作系统。</li><li>中间层：ROS1通信基于TCPROS/UDPROS，而ROS2通信基于DDS（data distribution service）数据分发服务。它是专门为RTOS设计的数据分发/订阅标准，其技术关键是以数据为核心的发布/订阅 模型 DCPS（data-centric publish-subscribe）,DCPS模型类似现在流行的容器命名空间技术，创建了一个全局数据空间，空间内的进程都可以直接访问。另外ROS2的intra-process 和ROS1的nodelet 数据传输方式类似，只是更名了而已，哈哈哈。</li><li>应用层：ROS1强依赖于master单点，只要单点就会降低系统的可靠性，所以ROS1只适用于实验室研究，无法商用。ROS2取消了master节点管理器，节点间使用discover发现机制帮助彼此建立链接。</li></ul><h4 id="ROS-2-的通信模型"><a href="#ROS-2-的通信模型" class="headerlink" title="ROS 2 的通信模型"></a>ROS 2 的通信模型</h4><p>ROS 1的通信模型主要包含话题、服务等通信机制，ROS 2的通信模型会稍显复杂，加入了很多DDS的通信机制。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220718093353563.png" alt=""></p><p>基于DDS数据分发服务的ROS2模型包含以下几个关键概念。</p><p><strong>参与者（Participant）</strong>:在 DDS 中，每一个发布者或者订阅者都成为参与者，对应于一个使用 DDS 的用户，可以使用某种定义好的数据类型来 读/写 全局数据空间。</p><p><strong>发布者（Publisher）</strong>:数据发布的执行者，支持多种数据类型的发布，可以与多个数据写入器（DataWriter）相联，发布一种或多种主题（Topic）的消息。</p><p><strong>订阅者（Subscriber）</strong>:数据订阅的执行者，支持多种数据类型的订阅，可以与多个数据读取器（DataReader）相联，订阅一种或多种主题（Topic）的消息。</p><p><strong>数据写入器（DataWriter）</strong>:上层应用向发布者更新数据的对象，每个数据写入器对应一个特定的Topic，类似于ROS 1中的一个消息发布者。</p><p><strong>数据读取器（DataReader）</strong>:上层应用从订阅者读取数据的对象，每个数据读取器对应一个特定的Topic，类似于ROS 1中的一个消息订阅者。</p><p><strong>话题（Topic）</strong>：和 ROS 1 中的概念类似，话题需要定义一个名称和一种数据结构，但 ROS 2 中的每个话题都是一个实例，可以存储该话题中的历史消息数据。</p><p><strong>质量服务原则（Quality of Service）</strong>:简称 QoS Policy，这是 ROS 2 中新增的、也是非常重要的一个概念，控制各方面与底层的通信机制，主要从时间限制、可靠性、持续性、历史记录这几个方面，满足用户针对不同场景的数据需求。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220718093403354.png" alt=""></p><ul><li>实时性增强：数据必须在 deadline 之前完成更新；</li><li>持续性增强：DDS 可以为 ROS 2 提供数据历史服务，新加入的节点也可以获取发布者发布的所有历史数据；</li><li>可靠性增强：配置可靠性原则，用户可以根据需求选择性能模式（BEST_EFFORT）或者稳定模式（RELIABLE）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;ROS的通信架构是ROS的灵魂所在，它包括数据处理，进程运行，消息传递等&lt;/strong&gt;。这篇文章主要介绍ROS1的通信架构的基础通信方式和相关概念，因为ROS1和ROS2的通信方式相差很大，文章后面会介绍ROS2 的通信框架和差异。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="ROS" scheme="http://yuanquanquan.top/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>ROS操作系统入门-1</title>
    <link href="http://yuanquanquan.top/2022/20220718/"/>
    <id>http://yuanquanquan.top/2022/20220718/</id>
    <published>2022-07-18T01:12:39.000Z</published>
    <updated>2022-07-18T01:30:07.756Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>入门脉络主要由几个部分组成，包括：ros简介、ros文件系统、ros通信架构、常用工具、roscpp和rospy。</p></blockquote><span id="more"></span><h3 id="ROS简介"><a href="#ROS简介" class="headerlink" title="ROS简介"></a>ROS简介</h3><p>机器人操作系统（Robot operating system ,ROS）是一个应用于机器人上的基础框架，它把原本松散的零部件耦合在一起，提供通信的架构，近似上ROS是一个中间件。</p><p>ros上手简单适合研究，但是商用缺点明显。主要是实时通信性能有限，系统稳定差。</p><h3 id="ROS误解"><a href="#ROS误解" class="headerlink" title="ROS误解"></a>ROS误解</h3><p>ROS不是一门编程语言，主要代码由C++编写，客户端可以使用python\java等多种语言编写</p><p>ROS不仅仅是一个函数库，除了客户端库，还包含中心服务器.</p><h3 id="ROS文件系统"><a href="#ROS文件系统" class="headerlink" title="ROS文件系统"></a>ROS文件系统</h3><p>认识ROS首先要知道ROS工程的组织架构，了解各个文件的功能和作用，才能高效的开发和编程。</p><p>这里面包含catkin编译系统，catkin工作空间结构，package软件包结构，重要的cmakelists.txt、package.xml文件内容。</p><ul><li><p><strong>catkin编译系统</strong></p><p>catkin编译系统底层仍然是linux gcc/g++ 只是为了提高编译效率、简化工程管理衍生的，如果有比catkin编译效率更好的软件出现，catkin一样会被替代。</p></li><li><p>一个catkin软件包必须包含两个文件：package.xml（package描述信息），CMakeList.txt(构建package所需的cmake文件列表)。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220718090624382.png" alt=""></p><p><strong>catkin工作原理：</strong></p><ol><li><p>当在工作空间（必须切换到workspace_base否则编译不会成功）敲下catkin_make指令后，编译器首先在当前工作空间./src下递归查找每一个ROS package.</p></li><li><p>package 中会有package.xml和CMakeList.txt文件，catkin编译系统依据CMakeList.txt文件，从而生成makefiles(放在./build/).</p></li><li><p>然后make build目录的makefiles文件，编译链接生成可执行文件放在./devel.</p><p><strong>所以说catkin就是将cmake和make指令做了一个封装，从而完成整个编译过程的工具。</strong></p></li></ol><ul><li><p><strong>catkin工作空间</strong></p><p>catkin的工作空间结构，它包含了src、build、devel 三个文件夹主要作用如下：</p><p> src/: ROS的catkin软件包（源代码包）</p><p> build/: catkin（CMake）的缓存信息和中间文件</p><p> devel/: 生成的目标文件（包括头文件，动态链接库，静态链接库，可执行文件等）、环境变量</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220718090647004.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line">gaocancan@ubuntu:~$ mkdir -p catkin_test/src</span><br><span class="line">gaocancan@ubuntu:~$ cd catkin_test</span><br><span class="line">gaocancan@ubuntu:~/catkin_test$ catkin_make</span><br><span class="line">Base path: /home/gaocancan/catkin_test</span><br><span class="line">Source space: /home/gaocancan/catkin_test/src</span><br><span class="line">Build space: /home/gaocancan/catkin_test/build</span><br><span class="line">Devel space: /home/gaocancan/catkin_test/devel</span><br><span class="line">Install space: /home/gaocancan/catkin_test/install</span><br><span class="line">Creating symlink &quot;/home/gaocancan/catkin_test/src/CMakeLists.txt&quot; pointing to &quot;/opt/ros/kinetic/share/catkin/cmake/toplevel.cmake&quot;</span><br><span class="line">####</span><br><span class="line">####</span><br><span class="line">Running command: &quot;cmake /home/gaocancan/catkin_test/src </span><br><span class="line">-DCATKIN_DEVEL_PREFIX=/home/gaocancan/catkin_test/devel </span><br><span class="line">-DCMAKE_INSTALL_PREFIX=/home/gaocancan/catkin_test/install -G Unix </span><br><span class="line">Makefiles&quot; in &quot;/home/gaocancan/catkin_test/build&quot;</span><br><span class="line">####</span><br><span class="line">-- The C compiler identification is GNU 5.4.0</span><br><span class="line">-- The CXX compiler identification is GNU 5.4.0</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - done</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- Using CATKIN_DEVEL_PREFIX: /home/gaocancan/catkin_test/devel</span><br><span class="line">-- Using CMAKE_PREFIX_PATH: /opt/ros/kinetic</span><br><span class="line">-- This workspace overlays: /opt/ros/kinetic</span><br><span class="line">-- Found PythonInterp: /usr/bin/python2 (found suitable version &quot;2.7.12&quot;, minimum required is &quot;2&quot;) </span><br><span class="line">-- Using PYTHON_EXECUTABLE: /usr/bin/python2</span><br><span class="line">-- Using Debian Python package layout</span><br><span class="line">-- Using empy: /usr/bin/empy</span><br><span class="line">-- Using CATKIN_ENABLE_TESTING: ON</span><br><span class="line">-- Call enable_testing()</span><br><span class="line">-- Using CATKIN_TEST_RESULTS_DIR: /home/gaocancan/catkin_test/build/test_results</span><br><span class="line">-- Found gtest sources under &#x27;/usr/src/gmock&#x27;: gtests will be built</span><br><span class="line">-- Found gmock sources under &#x27;/usr/src/gmock&#x27;: gmock will be built</span><br><span class="line">-- Found PythonInterp: /usr/bin/python2 (found version &quot;2.7.12&quot;) </span><br><span class="line">-- Looking for pthread.h</span><br><span class="line">-- Looking for pthread.h - found</span><br><span class="line">-- Looking for pthread_create</span><br><span class="line">-- Looking for pthread_create - not found</span><br><span class="line">-- Looking for pthread_create in pthreads</span><br><span class="line">-- Looking for pthread_create in pthreads - not found</span><br><span class="line">-- Looking for pthread_create in pthread</span><br><span class="line">-- Looking for pthread_create in pthread - found</span><br><span class="line">-- Found Threads: TRUE  </span><br><span class="line">-- Using Python nosetests: /usr/bin/nosetests-2.7</span><br><span class="line">-- catkin 0.7.29</span><br><span class="line">-- BUILD_SHARED_LIBS is on</span><br><span class="line">-- BUILD_SHARED_LIBS is on</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/gaocancan/catkin_test/build</span><br><span class="line">####</span><br><span class="line">#### Running command: &quot;make -j4 -l4&quot; in &quot;/home/gaocancan/catkin_test/build&quot;</span><br><span class="line">####</span><br><span class="line">gaocancan@ubuntu:~/catkin_test$ tree</span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   ├── atomic_configure</span><br><span class="line">│   │   ├── env.sh</span><br><span class="line">│   │   ├── local_setup.bash</span><br><span class="line">│   │   ├── local_setup.sh</span><br><span class="line">│   │   ├── local_setup.zsh</span><br><span class="line">│   │   ├── setup.bash</span><br><span class="line">│   │   ├── setup.sh</span><br><span class="line">│   │   ├── _setup_util.py</span><br><span class="line">│   │   └── setup.zsh</span><br><span class="line">│   ├── catkin</span><br><span class="line">│   │   └── catkin_generated</span><br><span class="line">│   │       └── version</span><br><span class="line">│   │           └── package.cmake</span><br><span class="line">│   ├── catkin_generated</span><br><span class="line">│   │   ├── env_cached.sh</span><br><span class="line">│   │   ├── generate_cached_setup.py</span><br><span class="line">│   │   ├── installspace</span><br><span class="line">│   │   │   ├── env.sh</span><br><span class="line">│   │   │   ├── local_setup.bash</span><br><span class="line">│   │   │   ├── local_setup.sh</span><br><span class="line">│   │   │   ├── local_setup.zsh</span><br><span class="line">│   │   │   ├── setup.bash</span><br><span class="line">│   │   │   ├── setup.sh</span><br><span class="line">│   │   │   ├── _setup_util.py</span><br><span class="line">│   │   │   └── setup.zsh</span><br><span class="line">│   │   ├── order_packages.cmake</span><br><span class="line">│   │   ├── order_packages.py</span><br><span class="line">│   │   ├── setup_cached.sh</span><br><span class="line">│   │   └── stamps</span><br><span class="line">│   │       └── Project</span><br><span class="line">│   │           ├── interrogate_setup_dot_py.py.stamp</span><br><span class="line">│   │           ├── order_packages.cmake.em.stamp</span><br><span class="line">│   │           ├── package.xml.stamp</span><br><span class="line">│   │           └── _setup_util.py.stamp</span><br><span class="line">│   ├── CATKIN_IGNORE</span><br><span class="line">│   ├── catkin_make.cache</span><br><span class="line">│   ├── CMakeCache.txt</span><br><span class="line">│   ├── CMakeFiles</span><br><span class="line">│   │   ├── 3.5.1</span><br><span class="line">│   │   │   ├── CMakeCCompiler.cmake</span><br><span class="line">│   │   │   ├── CMakeCXXCompiler.cmake</span><br><span class="line">│   │   │   ├── CMakeDetermineCompilerABI_C.bin</span><br><span class="line">│   │   │   ├── CMakeDetermineCompilerABI_CXX.bin</span><br><span class="line">│   │   │   ├── CMakeSystem.cmake</span><br><span class="line">│   │   │   ├── CompilerIdC</span><br><span class="line">│   │   │   │   ├── a.out</span><br><span class="line">│   │   │   │   └── CMakeCCompilerId.c</span><br><span class="line">│   │   │   └── CompilerIdCXX</span><br><span class="line">│   │   │       ├── a.out</span><br><span class="line">│   │   │       └── CMakeCXXCompilerId.cpp</span><br><span class="line">│   │   ├── clean_test_results.dir</span><br><span class="line">│   │   │   ├── build.make</span><br><span class="line">│   │   │   ├── cmake_clean.cmake</span><br><span class="line">│   │   │   ├── DependInfo.cmake</span><br><span class="line">│   │   │   └── progress.make</span><br><span class="line">│   │   ├── cmake.check_cache</span><br><span class="line">│   │   ├── CMakeDirectoryInformation.cmake</span><br><span class="line">│   │   ├── CMakeError.log</span><br><span class="line">│   │   ├── CMakeOutput.log</span><br><span class="line">│   │   ├── CMakeRuleHashes.txt</span><br><span class="line">│   │   ├── CMakeTmp</span><br><span class="line">│   │   ├── download_extra_data.dir</span><br><span class="line">│   │   │   ├── build.make</span><br><span class="line">│   │   │   ├── cmake_clean.cmake</span><br><span class="line">│   │   │   ├── DependInfo.cmake</span><br><span class="line">│   │   │   └── progress.make</span><br><span class="line">│   │   ├── doxygen.dir</span><br><span class="line">│   │   │   ├── build.make</span><br><span class="line">│   │   │   ├── cmake_clean.cmake</span><br><span class="line">│   │   │   ├── DependInfo.cmake</span><br><span class="line">│   │   │   └── progress.make</span><br><span class="line">│   │   ├── feature_tests.bin</span><br><span class="line">│   │   ├── feature_tests.c</span><br><span class="line">│   │   ├── feature_tests.cxx</span><br><span class="line">│   │   ├── Makefile2</span><br><span class="line">│   │   ├── Makefile.cmake</span><br><span class="line">│   │   ├── progress.marks</span><br><span class="line">│   │   ├── run_tests.dir</span><br><span class="line">│   │   │   ├── build.make</span><br><span class="line">│   │   │   ├── cmake_clean.cmake</span><br><span class="line">│   │   │   ├── DependInfo.cmake</span><br><span class="line">│   │   │   └── progress.make</span><br><span class="line">│   │   ├── TargetDirectories.txt</span><br><span class="line">│   │   └── tests.dir</span><br><span class="line">│   │       ├── build.make</span><br><span class="line">│   │       ├── cmake_clean.cmake</span><br><span class="line">│   │       ├── DependInfo.cmake</span><br><span class="line">│   │       └── progress.make</span><br><span class="line">│   ├── cmake_install.cmake</span><br><span class="line">│   ├── CTestConfiguration.ini</span><br><span class="line">│   ├── CTestCustom.cmake</span><br><span class="line">│   ├── CTestTestfile.cmake</span><br><span class="line">│   ├── gtest</span><br><span class="line">│   │   ├── CMakeFiles</span><br><span class="line">│   │   │   ├── CMakeDirectoryInformation.cmake</span><br><span class="line">│   │   │   ├── gmock.dir</span><br><span class="line">│   │   │   │   ├── build.make</span><br><span class="line">│   │   │   │   ├── cmake_clean.cmake</span><br><span class="line">│   │   │   │   ├── DependInfo.cmake</span><br><span class="line">│   │   │   │   ├── depend.make</span><br><span class="line">│   │   │   │   ├── flags.make</span><br><span class="line">│   │   │   │   ├── link.txt</span><br><span class="line">│   │   │   │   ├── progress.make</span><br><span class="line">│   │   │   │   ├── src</span><br><span class="line">│   │   │   │   └── usr</span><br><span class="line">│   │   │   │       └── src</span><br><span class="line">│   │   │   │           └── gtest</span><br><span class="line">│   │   │   │               └── src</span><br><span class="line">│   │   │   ├── gmock_main.dir</span><br><span class="line">│   │   │   │   ├── build.make</span><br><span class="line">│   │   │   │   ├── cmake_clean.cmake</span><br><span class="line">│   │   │   │   ├── DependInfo.cmake</span><br><span class="line">│   │   │   │   ├── depend.make</span><br><span class="line">│   │   │   │   ├── flags.make</span><br><span class="line">│   │   │   │   ├── link.txt</span><br><span class="line">│   │   │   │   ├── progress.make</span><br><span class="line">│   │   │   │   ├── src</span><br><span class="line">│   │   │   │   └── usr</span><br><span class="line">│   │   │   │       └── src</span><br><span class="line">│   │   │   │           └── gtest</span><br><span class="line">│   │   │   │               └── src</span><br><span class="line">│   │   │   └── progress.marks</span><br><span class="line">│   │   ├── cmake_install.cmake</span><br><span class="line">│   │   ├── CTestTestfile.cmake</span><br><span class="line">│   │   ├── gtest</span><br><span class="line">│   │   │   ├── CMakeFiles</span><br><span class="line">│   │   │   │   ├── CMakeDirectoryInformation.cmake</span><br><span class="line">│   │   │   │   ├── gtest.dir</span><br><span class="line">│   │   │   │   │   ├── build.make</span><br><span class="line">│   │   │   │   │   ├── cmake_clean.cmake</span><br><span class="line">│   │   │   │   │   ├── DependInfo.cmake</span><br><span class="line">│   │   │   │   │   ├── depend.make</span><br><span class="line">│   │   │   │   │   ├── flags.make</span><br><span class="line">│   │   │   │   │   ├── link.txt</span><br><span class="line">│   │   │   │   │   ├── progress.make</span><br><span class="line">│   │   │   │   │   └── src</span><br><span class="line">│   │   │   │   ├── gtest_main.dir</span><br><span class="line">│   │   │   │   │   ├── build.make</span><br><span class="line">│   │   │   │   │   ├── cmake_clean.cmake</span><br><span class="line">│   │   │   │   │   ├── DependInfo.cmake</span><br><span class="line">│   │   │   │   │   ├── depend.make</span><br><span class="line">│   │   │   │   │   ├── flags.make</span><br><span class="line">│   │   │   │   │   ├── link.txt</span><br><span class="line">│   │   │   │   │   ├── progress.make</span><br><span class="line">│   │   │   │   │   └── src</span><br><span class="line">│   │   │   │   └── progress.marks</span><br><span class="line">│   │   │   ├── cmake_install.cmake</span><br><span class="line">│   │   │   ├── CTestTestfile.cmake</span><br><span class="line">│   │   │   └── Makefile</span><br><span class="line">│   │   └── Makefile</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   └── test_results</span><br><span class="line">├── devel</span><br><span class="line">│   ├── cmake.lock</span><br><span class="line">│   ├── env.sh</span><br><span class="line">│   ├── lib</span><br><span class="line">│   ├── local_setup.bash</span><br><span class="line">│   ├── local_setup.sh</span><br><span class="line">│   ├── local_setup.zsh</span><br><span class="line">│   ├── setup.bash</span><br><span class="line">│   ├── setup.sh</span><br><span class="line">│   ├── _setup_util.py</span><br><span class="line">│   └── setup.zsh</span><br><span class="line">└── src</span><br><span class="line">  └── CMakeLists.txt -&gt; /opt/ros/kinetic/share/catkin/cmake/toplevel.cmake</span><br><span class="line"></span><br><span class="line">43 directories, 123 files</span><br></pre></td></tr></table></figure><p>  <strong>package 软件包</strong></p><p>  package是catkin编译的最小单元，我们调用catkin_make编译的对象就是一个个package,所以package也是ROS源码存放的地方。</p><p>  一个package常见的结构有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists.txt #package的编译规则(必须)</span><br><span class="line">├── package.xml #package的描述信息(必须)</span><br><span class="line">├── src/ #源代码文件</span><br><span class="line">├── include/ #C++头文件</span><br><span class="line">├── scripts/ #可执行脚本</span><br><span class="line">├── msg/ #自定义消息</span><br><span class="line">├── srv/ #自定义服务</span><br><span class="line">├── models/ #3D模型文件</span><br><span class="line">├── urdf/ #urdf文件</span><br><span class="line">├── launch/ #launch文件</span><br></pre></td></tr></table></figure><p>  通常ROS文件组织都是按照以上的形式，这是约定俗成的命名习惯，建议遵守。以上路径<strong>只有 CMakeLists.txt 和 package.xml 是必须的，其余路径根据软件包是否需要来决定</strong>。</p><p><strong>package创建</strong></p><p>创建package需要工作空间的src目录下，使用catkin_create_pkg  package  depends</p><p>其中package 是包名，depends是依赖的包名（如roscpp、rospy、std_msgs）执行命令后会自动完成软件包的初始化，并将依赖包按格式写入CMakeList.txt、package.xml.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">gaocancan@ubuntu:~/catkin_test/src$ catkin_create_pkg catkin_test_pkg roscpp rospy std_msg</span><br><span class="line">Created file catkin_test_pkg/CMakeLists.txt</span><br><span class="line">Created file catkin_test_pkg/package.xml</span><br><span class="line">Created folder catkin_test_pkg/include/catkin_test_pkg</span><br><span class="line">Created folder catkin_test_pkg/src</span><br><span class="line">Successfully created files in /home/gaocancan/catkin_test/src/catkin_test_pkg. Please adjust the values in package.xml.</span><br><span class="line">gaocancan@ubuntu:~/catkin_test/src$ tree</span><br><span class="line">.</span><br><span class="line">├── catkin_test_pkg</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   └── catkin_test_pkg</span><br><span class="line">│   ├── package.xml</span><br><span class="line">│   └── src</span><br><span class="line">└── CMakeLists.txt -&gt; /opt/ros/kinetic/share/catkin/cmake/toplevel.cmake</span><br><span class="line"></span><br><span class="line">4 directories, 3 files</span><br><span class="line">gaocancan@ubuntu:~/catkin_test/src$</span><br></pre></td></tr></table></figure><blockquote><p>常用ros 命令：</p><p>如果不指定 [package]默认为当前目录</p><p>rospack list  #列出本机所有package</p><p>rospack find  [package]  #定位某个package</p><p>rospack profile  [package] #刷新所有package位置记录</p><p>rospack depends  [package] #显示package依赖包</p><p>roscd [package] #打开package</p><p>rosls  [package]  #相当于ls</p><p>rosdep check  [package]  #检查package依赖是否满足</p><p>rosdep install  [package]  #安装package的依赖</p><p>rosdep db #生成和显示依赖数据库</p><p>rosdep init #初始化/etc/ros/rosdep中的源</p><p>rosdep keys  检查package的依赖是否满足</p><p>rosdep update 更新本地的rosdep数据库</p></blockquote><ul><li><p><strong>cmakelists.txt、package.xml文件介绍</strong></p><p>CMakeList.txt指定源码到目标文件的规则，该文件规定了package要依赖的包，编译目标文件、编译流程等。</p><p><strong>cmakelists.txt写法：</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required() #CMake的版本号</span><br><span class="line">project() #项目名称</span><br><span class="line">find_package() #找到编译需要的其他CMake/Catkin package</span><br><span class="line">catkin_python_setup() #catkin新加宏，打开catkin的Python Module的支持</span><br><span class="line">add_message_files() #catkin新加宏，添加自定义Message/Service/Action文件</span><br><span class="line">add_service_files()</span><br><span class="line">add_action_files()</span><br><span class="line">generate_message() #catkin新加宏，生成不同语言版本的msg/srv/action接口 --重要</span><br><span class="line">catkin_package() #catkin新加宏，生成当前package的cmake配置，供依赖本包的其他软件包调用 --重要</span><br><span class="line">add_library() #生成库</span><br><span class="line">add_executable() #生成可执行二进制文件</span><br><span class="line">add_dependencies() #定义目标文件依赖于其他目标文件，确保其他目标已被构建</span><br><span class="line">target_link_libraries() #链接</span><br><span class="line">catkin_add_gtest() #catkin新加宏，生成测试</span><br><span class="line">install() #安装至本机</span><br></pre></td></tr></table></figure><p>语法推荐：<a href="https://github.com/Akagi201/learning-cmake/blob/master/docs/cmake-practice.pdf">https://github.com/Akagi201/learning-cmake/blob/master/docs/cmake-practice.pdf</a> 。作者写的很直白，掌握CMake语法可以加深理解ROS工程</p><p>package.xml 包含了package 的名称、版本号、内容、编译依赖、运行依赖等信息，实际上rospack find 、rosdep命令也是读取该文件。</p><p><strong>package.xml写法：</strong></p><p>package.xml有两个版本，目前主流版本都支持。</p><p>版本一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;pacakge&gt; 根标记文件</span><br><span class="line">&lt;name&gt; 包名</span><br><span class="line">&lt;version&gt; 版本号</span><br><span class="line">&lt;description&gt; 内容描述</span><br><span class="line">&lt;maintainer&gt; 维护者</span><br><span class="line">&lt;license&gt; 软件许可证</span><br><span class="line">&lt;buildtool_depend&gt; 编译构建工具，通常为catkin --重要</span><br><span class="line">&lt;build_depend&gt; 编译依赖项，与Catkin中的  --总要</span><br><span class="line">&lt;run_depend&gt; 运行依赖项  --重要</span><br></pre></td></tr></table></figure><p>版本二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;pacakge&gt; 根标记文件</span><br><span class="line">&lt;name&gt; 包名</span><br><span class="line">&lt;version&gt; 版本号</span><br><span class="line">&lt;description&gt; 内容描述</span><br><span class="line">&lt;maintainer&gt; 维护者</span><br><span class="line">&lt;license&gt; 软件许可证</span><br><span class="line">&lt;buildtool_depend&gt; 编译构建工具，通常为catkin</span><br><span class="line">#用depend来整合build_depend和run_depend</span><br><span class="line">&lt;depend&gt; 指定依赖项为编译、导出、运行需要的依赖，最常用 --重要</span><br><span class="line">&lt;build_depend&gt; 编译依赖项  --重要</span><br><span class="line">&lt;build_export_depend&gt; 导出依赖项  --重要</span><br><span class="line">#用depend来整合build_depend和run_depend</span><br><span class="line">&lt;exec_depend&gt; 运行依赖项  --重要</span><br><span class="line">&lt;test_depend&gt; 测试用例依赖项</span><br><span class="line">&lt;doc_depend&gt; 文档依赖项</span><br></pre></td></tr></table></figure><p>入门脉络主要由几个部分组成，包括：ros简介、ros文件系统、ros通信架构、常用工具、roscpp和rospy。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;入门脉络主要由几个部分组成，包括：ros简介、ros文件系统、ros通信架构、常用工具、roscpp和rospy。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="ROS" scheme="http://yuanquanquan.top/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>ROS在WSL2环境下的配置记录笔记</title>
    <link href="http://yuanquanquan.top/2022/20220607/"/>
    <id>http://yuanquanquan.top/2022/20220607/</id>
    <published>2022-06-06T20:45:33.000Z</published>
    <updated>2022-06-06T20:57:41.283Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>WSL(Window Subsystem Linux)越发成熟了，WSL2更是直接在Window系统下嵌入了一个完整的Linux内核，所以我们在非生产环境下，完全可以使用WSL替代Linux系统完成日常的需求，根据我目前的使用体验，初期通过它学习Linux，还挺方便。</p></blockquote><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image-20220607043225729.png" alt=""></p><p>先放结果，小乌龟能跑了……</p><p>前置操作：</p><p>win11（win10也行，win10需要自行安装linux的gui），WSL2，ubuntu18.04，g++，python</p><p>上述环境基本搜一搜都有教程</p><p>（推荐一个安装wsl教程：<a href="https://blog.51cto.com/3chou/2294231）">https://blog.51cto.com/3chou/2294231）</a></p><p>1.先更新下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update  </span><br><span class="line">sudo apt-get upgrade  </span><br></pre></td></tr></table></figure><p>2.添加ros源（选一个）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#清华源sudo sh -c &#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;#中科大源sudo sh -c &#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.ustc.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span><br></pre></td></tr></table></figure><p>3.设置密钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br></pre></td></tr></table></figure><p>4.更新一下源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>5.安装（时间较长）</p><p>18.04装这个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-melodic-desktop-full</span><br></pre></td></tr></table></figure><p>16.04装这个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-kinetic-desktop-full</span><br></pre></td></tr></table></figure><p>6.初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rosdep initrosdep update</span><br></pre></td></tr></table></figure><p>初始化报错<code>ERROR: cannot download default sources list from</code>时，两个办法</p><p>1）换网….对，解决不了问题就解决网络</p><p>2）互联网一堆类似的问题，这里给出一个参考链接</p><p><a href="https://blog.csdn.net/u014662384/article/details/106916673">https://blog.csdn.net/u014662384/article/details/106916673</a></p><p>7.环境变量</p><p>18.04</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><p>16.04</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source /opt/ros/kinetic/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><p>8.刷新下环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>9.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essential</span><br></pre></td></tr></table></figure><p>到这里，安装应该结束了</p><p>可以使用下面命令去检测是否成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure><p>如何把小乌龟跑起来呢？</p><p>开三个Terminal</p><p>分别依次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure><p>不出意外，屏幕上小乌龟会根据上下左右方向键可以操控了</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image-20220607043425697.png" alt=""></p><p>顺利启动rviz</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image-20220607043445889.png" alt=""></p><p>不得不说，在window下通过WSL使用Linux，对于轻度使用linux用户还挺香的……</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;WSL(Window Subsystem Linux)越发成熟了，WSL2更是直接在Window系统下嵌入了一个完整的Linux内核，所以我们在非生产环境下，完全可以使用WSL替代Linux系统完成日常的需求，根据我目前的使用体验，初期通过它学习Linux，还挺方便。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="slam" scheme="http://yuanquanquan.top/tags/slam/"/>
    
      <category term="ros" scheme="http://yuanquanquan.top/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>ArcGIS Pro 功能介绍</title>
    <link href="http://yuanquanquan.top/2022/2202202221/"/>
    <id>http://yuanquanquan.top/2022/2202202221/</id>
    <published>2022-04-24T16:54:44.000Z</published>
    <updated>2022-07-18T01:46:10.603Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前使用的是ArcMap，最近因为一些需求转了ArcGIS Pro，ArcMap中提供的大多数功能在 ArcGIS Pro 中同样可用。随即面临的挑战是在重新设计的应用程序中找到熟悉的命令并遵循熟悉的工作流。ArcMap 中的下拉菜单、工具条和对话框替换为 ArcGIS Pro 中的功能区和窗格。ArcGIS Pro 基于工程的结构也是一项全新体验。ArcMap 中提供的大多数功能在 ArcGIS Pro 中同样可用。随即面临的挑战是在重新设计的应用程序中找到熟悉的命令并遵循熟悉的工作流。ArcMap 中的下拉菜单、工具条和对话框替换为 ArcGIS Pro 中的功能区和窗格。ArcGIS Pro 基于工程的结构也是一项全新体验。ArcMap 中提供的大多数功能在 ArcGIS Pro 中同样可用。随即面临的挑战是在重新设计的应用程序中找到熟悉的命令并遵循熟悉的工作流。ArcMap 中的下拉菜单、工具条和对话框替换为 ArcGIS Pro 中的功能区和窗格。ArcGIS Pro 基于工程的结构也是一项全新体验。</p></blockquote><span id="more"></span><h2 id="ArcGIS-Pro-2-7亮点"><a href="#ArcGIS-Pro-2-7亮点" class="headerlink" title="ArcGIS Pro 2.7亮点"></a>ArcGIS Pro 2.7亮点</h2><p>亮点部分包含此版本的特色功能更新。</p><h3 id="GNSS-设备位置支持"><a href="#GNSS-设备位置支持" class="headerlink" title="GNSS 设备位置支持"></a>GNSS 设备位置支持</h3><p>可将 GNSS (GPS) 设备连接到 ArcGIS Pro 以在地图或场景中查看设备的位置。行进时，设备的位置会在视图中自动更新。</p><p>在打开位置后，可根据 GNSS 设备的当前地理位置创建要素，也可以设置点要素类以在位置更新时自动记录设备中的数据。</p><h3 id="移动地理数据库"><a href="#移动地理数据库" class="headerlink" title="移动地理数据库"></a>移动地理数据库</h3><p>移动地理数据库 是 ArcGIS Pro 2.7 中的新型地理数据库。与其他地理数据库一样，可创建移动地理数据库来存储地理数据集，执行数据建模任务以及用作地理处理工具和脚本的输入。</p><p>移动地理数据库存储在 SQLite 数据库，它具有以下优势：</p><ul><li>SQLite 是一个适用范围广、稳定且可靠的数据库。</li><li>SQLite 是公共域中的开源数据库，因此不需要许可。</li><li>SQLite 数据库支持跨平台并且存储在磁盘上的单个文件中，因此可移植并且是一种高效的数据交换格式。</li><li>SQLite 是功能齐全的关系数据库，用于通过 SQL 查询和报告工作流。</li></ul><p>移动地理数据库是在 ArcGIS Pro 和 ArcGIS Runtime 之间实现完全互操作工作流的第一步，并将增强 ArcGIS Runtime 和 Esri 移动应用程序套件中的工作流和应用程序。</p><h3 id="图层和要素混合"><a href="#图层和要素混合" class="headerlink" title="图层和要素混合"></a>图层和要素混合</h3><p>现在可以将混合模式应用于地图中的图层。例如，可增亮或加深图层，以引起人们注意地图各种颜色范围的增强或变暗。混合模式常用于图像编辑和图形设计工作流，可增强要素的可视化并更改设计要发布的地图的方式。</p><p>将混合模式应用于图层后，根据地图绘制顺序位于该图层下方的图层的视觉效果将发生改变。大多数混合模式将独立应用于每个颜色通道。</p><p>为了进一步控制，也可以将混合模式应用于单个要素图层中的要素。在这种情况下，符号化的要素将在图层中相互混合。</p><h3 id="线性参考"><a href="#线性参考" class="headerlink" title="线性参考"></a>线性参考</h3><p>线性参考系 (LRS) 可使用路径对线性距离和相关事件进行建模。这些路径将创建为包含 m 值的折线中心线要素，每个折点处都存在 m 值，用于存储独立于线几何的测量值。</p><p>现在可以基于所选线要素创建路径，使用指定的两个或多个校准点校准所选路线以及通过追踪并单击路径沿线的两个点定义一部分线性路径。</p><p>新的线性参考编辑功能是核心 ArcGIS Pro 应用程序的一部分。无需 Roads and Highways 或 Pipeline Referencing 等扩展模块产品即可使用它们。</p><h3 id="3D-对象要素图层"><a href="#3D-对象要素图层" class="headerlink" title="3D 对象要素图层"></a>3D 对象要素图层</h3><p>3D 对象要素类是 ArcGIS Pro 2.7 中的新数据类型。与多面体一样，3D 对象表示占据 3D 空间的要素的外壳，但是它们具有更丰富的属性集。例如，它们可以显示反射、阴影和粗糙度等特征。3D 对象要素类存储在文件地理数据库、企业级地理数据库或移动地理数据库中。文件地理数据库 3D 对象要素可以在许多第三方建模应用程序中直接打开和编辑，包括 Maya 和 Blender。</p><p>由多面体要素（左）和 3D 对象要素（右）表示的球体</p><p>将 3D 对象要素图层添加到 ArcGIS Pro 中的场景时，可使用适用于多面体的相同编辑和分析工具。可使用地理处理工具将多面体要素类和 3D 对象要素类相互转换。</p><h3 id="移动分析工具"><a href="#移动分析工具" class="headerlink" title="移动分析工具"></a>移动分析工具</h3><p>移动工具使用点轨迹数据来分析和可视化对象在空间和时间上的移动。点轨迹数据由按时间顺序排列的点位置组成，这些点位置按唯一设备（例如 GPS 或其他移动设备）进行分组。下面是四个移动分析补充工具：</p><ul><li>查找同行者用于确定哪些设备（例如移动电话）可能在同一地点和同一时间同行。</li><li>查找汇合位置用于确定几个设备停留较长时间的区域 - 表示可能的汇合位置。</li><li>比较区域用于查找同一地点和同一时间在已知区域运行的唯一设备。</li><li>分类移动事件用于识别点轨迹数据中的移动特定事件。</li></ul><p>分类移动事件是四个工具中的最新工具。该工具使用转弯信息（包括 U 形转弯）、停靠点以及有关加速和减速的信息对点轨迹数据进行归类，从而简化检查轨迹点以弄清实体在某个位置的移动方式这一耗时过程。这对于从事运输遥测、监控流量源或检查 GPS 设备指标的分析人员非常有用。</p><h3 id="开始页面资源"><a href="#开始页面资源" class="headerlink" title="开始页面资源"></a>开始页面资源</h3><p>可通过 ArcGIS Pro 开始页面快速访问相关资源来了解该软件。</p><ul><li>了解 ArcGIS Pro 最新版本的新特性 。</li><li>在“了解 ArcGIS” 站点上使用快速入门教程  学习技能并在解决实际问题时进行应用。</li><li>通过自学和 Esri 学院  提供的讲师指导课程提高 ArcGIS Pro 专业水平。</li><li>在 GeoNet  上提问、分享知识并与世界各地的 Esri 社区交换看法。</li><li>阅读 ArcGIS 博客  查看 Esri 产品工程师撰写的文章、公告和实用工作流。</li><li>获取有关 ArcGIS Pro 的各个方面的详细帮助 。</li></ul><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><ul><li>系统管理员可通过 Pro.settingsConfig 文件代表用户管理应用程序设置。在 ArcGIS Pro 2.7 中，管理员可以为索引和本地帮助选项设置和锁定默认值。</li><li>ArcGIS Pro 开始页面已更新。请参阅“亮点”部分中开始页面资源。</li></ul><h2 id="分析和地理处理"><a href="#分析和地理处理" class="headerlink" title="分析和地理处理"></a>分析和地理处理</h2><h3 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h3><ul><li>地理处理工具上的运行拆分菜单按钮具有重置参数命令 ，用于将打开工具的所有参数恢复为其初始状态。</li><li>创建脚本工具时，可基于模板创建脚本文件 (.py)，以使用符合 Python 脚本工具模块的最佳做法的函数、参数处理和样式设置脚本。</li><li>新的地理处理选项以简称的形式显示数据路径用于控制地理处理工具上的数据路径是仅显示文件名还是显示完整的数据路径。</li><li>新的地理处理选项默认打开启用撤消用于控制支持撤消的地理处理工具是否自动打开启用撤消功能。</li></ul><h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3><ul><li>新的图表类型矩阵热点图用于可视化分类变量之间的关系，也可用于可视化随时间的变化。</li></ul><ul><li><p>图表现在可以导出为汇总数据表。</p></li><li><p>散点图矩阵具有新的布局选项，包括将绘图显示为表示每种关系的强度和方向的皮尔逊相关系数 ( Pearson’s r) 的能力。</p></li></ul><ul><li><p>现在可以将移动平均叠加添加到时间条形图，以平滑时间趋势。</p></li><li><p>可右键单击内容窗格中的任何图表，然后单击复制来创建图表的副本。</p></li><li><p>除了数值字段之外，现在还可以通过右键单击字段，然后单击统计数据，直接基于属性表汇总字符串和日期字段。</p></li><li><p>栅格时间序列的时间分布图已增强，现可支持新的时间序列选项、每个位置的像素值统计数据以及位置和线颜色的默认配色方案。</p></li></ul><h3 id="地理处理历史"><a href="#地理处理历史" class="headerlink" title="地理处理历史"></a>地理处理历史</h3><ul><li>可基于工具中使用的输入数据过滤地理处理历史记录。例如，可以查找使用 Roads 图层作为输入的所有工具。</li><li>可以将地理处理历史记录中的工具添加到历史记录窗格的收藏夹部分。</li><li>新的地理处理选项将地理处理操作写入地理处理历史记录用于控制对工程中的地理处理历史记录的日志记录。</li><li>从地理处理历史记录中的工具获取 Python 命令时，如果该工具使用任何地理处理环境，则 Python 命令将包括一个 arcpy.EnvManager 代码块，用于帮助您高效设置环境。</li></ul><h3 id="地理处理服务"><a href="#地理处理服务" class="headerlink" title="地理处理服务"></a>地理处理服务</h3><ul><li>已添加一条消息，用于指示 GeoAnalytics Desktop、Portal 和 Intelligence 移动工具不支持发布到 ArcGIS Server。</li></ul><h3 id="链接分析"><a href="#链接分析" class="headerlink" title="链接分析"></a>链接分析</h3><ul><li>使用特征向量和页面等级中心性分析方法在链接图表中查找新的中心节点。</li><li>使用选择已连接工具  展开链接图表选择。该工具会将已连接实体添加至当前链接和实体选择集。</li><li>基于独立表以及要素类创建实体类型，并将其添加到新的或现有链接图表。</li></ul><h3 id="ModelBuilder"><a href="#ModelBuilder" class="headerlink" title="ModelBuilder"></a>ModelBuilder</h3><ul><li>可使用新的迭代图层工具在地图中的图层上进行迭代并使用图层的工作空间或图层类型分支化模型。可使用图层属性（例如图层可见性及其状态）过滤和限制模型处理。</li></ul><ul><li>模型输出现在具有以下增强功能：</li></ul><ul><li><ul><li>可使用添加到显示命令将输出添加到地图中。</li><li>输出将在内容窗格 ModelBuilder 图层组中显示。</li><li>输出图层名称包含 ModelBuilder 变量名称和变量值。</li></ul></li><li><p>模型构建器 报表视图支持交互式双向编辑和同步。</p></li><li><p>将工具添加到模型对话框包含以下增强功能：</p></li><li><ul><li>改进的图标</li><li>支持查找迭代器、实用程序和逻辑工具</li><li>显示工具所属的工具箱</li><li>支持选择多个工具并将其拖至模型窗口</li></ul></li></ul><h3 id="栅格函数"><a href="#栅格函数" class="headerlink" title="栅格函数"></a>栅格函数</h3><p>栅格函数套件的参考帮助从影像和栅格部分移动到了分析和地理处理部分。</p><p>可以将栅格函数合并为处理链，以在平移和漫游地图中的影像和栅格数据集时动态显示分析结果。</p><ul><li><p>向“波段算术”函数添加了六个波段指数。其中几个非常适合用于分析和绘制野火事件：</p></li><li><ul><li>燃烧面积指数 (BAI) - 使用光谱红光和 NIR 部分的反射率值来识别受火灾影响的地形面积。</li><li>归一化燃烧比率指数 (NBRI) - 使用 NIR 和 SWIR 波段来突出燃烧面积，同时减少光照和大气效应。</li><li>归一化差值建筑用地指数 (NDBI) - 使用 NIR 和 SWIR 波段来突出生产建筑用地开发。</li><li>归一化差值含水指数 (NDMI) - 检测植被的不同水分含量。用于监测干旱情况以及监测火灾多发区域的可燃物情况。</li><li>归一化差分雪盖指数 (NDSI) - 专门用于在忽略云覆盖的情况下， 使用 MODIS（波段 4 和波段 6）和 Landsat TM（波段 2 和波段 5）识别积雪覆盖范围。</li><li>归一化差值水体指数 (NDWI) - 用于描绘和监测地表含水量变化的指数。</li></ul></li><li><p>添加了三个新的栅格函数：</p></li><li><ul><li>边界清理 - 平滑栅格数据中区域之间的边界。这需要 Spatial Analyst 扩展模块。</li><li>LandTrendr 分析 - 使用基于 Landsat 的干扰和恢复趋势检测 (LandTrendr) 方法评估像素值随时间的变化，并生成包含模型结果的变化分析栅格。这需要 ArcGIS Image Analyst 扩展模块。</li><li>聚合多维 - 通过沿维度合并现有多维栅格变量数据来创建多维栅格图层。这需要 Image Analyst 或 Spatial Analyst 扩展模块。</li></ul></li><li><p>现有栅格函数具有以下增强功能：</p></li><li><ul><li>计算变化 - 支持使用过滤方法参数过滤要为分类变化检测生成的类。</li><li>使用变化分析检测变化 - 支持新的 LandTrendr 分析栅格函数的输出。</li><li>距离累积和距离分配 - 已提高将距离方法参数设置为平面时的性能。</li><li>生成趋势 - 支持使用 Mann-Kendall 和 Seasonal-Kendall 趋势分析方法检测趋势。</li><li>核密度 - 可使用新参数输入障碍在计算密度时改变要素的影响。这需要 Spatial Analyst 扩展模块。</li><li>最低成本路径 - 已提高性能。</li><li>合并栅格 - 支持在空间上或跨变量和维度合并多维栅格数据集。</li><li>统计数据 - 支持其他统计数据填充方法，包括众数和少数。</li><li>分区统计 - 支持适用于浮点值栅格的中位数和百分位数统计数据类型。新参数百分位数插值类型用于定义输入栅格中要计算的值数量为偶数时使用的百分位数插值方法。该函数现在还支持对具有不同维度的输入进行多维处理。这需要 Image Analyst 或 Spatial Analyst 扩展模块。</li></ul></li></ul><h3 id="空间统计"><a href="#空间统计" class="headerlink" title="空间统计"></a>空间统计</h3><ul><li><p>有关在此版本中添加的新地理处理工具的信息，请参阅空间统计工具箱。</p><p>|                                                            |<br>| ———————————————————- |<br>| 可使用新的“邻域汇总统计数据”工具计算处理邻域中点的平均值。 |</p></li></ul><h3 id="3D-Analyst-扩展模块"><a href="#3D-Analyst-扩展模块" class="headerlink" title="3D Analyst 扩展模块"></a>3D Analyst 扩展模块</h3><ul><li>可以将 LAS 点过滤为按类代码交互选择，这有助于以交互的方式对激光雷达点进行分类。</li><li>可使用 可见点按钮 仅选择您可以看到的点，而不是遮挡的点。这可防止意外选择远处的背景点。</li><li>可使用体积 3D 框、球体或圆柱选择 LAS 点。</li><li>可使用电力线选择工具根据预设参数沿线选择一系列点。</li><li>已缩短 LAS 数据集金字塔构建时间。</li><li>已提高应用了 Eye-Dome 照明 (EDL) 的场景中 LAS 数据集的渲染性能。</li></ul><p>有关地理处理工具增强功能，请参阅 3D Analyst 工具箱。</p><h3 id="Business-Analyst-扩展模块"><a href="#Business-Analyst-扩展模块" class="headerlink" title="Business Analyst 扩展模块"></a>Business Analyst 扩展模块</h3><ul><li>可通过目标营销改进功能通过向导创建报表。</li><li>业务搜索支持将 SafeGraph 作为数据源。</li></ul><p>有关地理处理工具增强功能，请参阅 Business Analyst 工具箱。</p><h3 id="Geostatistical-Analyst-扩展模块"><a href="#Geostatistical-Analyst-扩展模块" class="headerlink" title="Geostatistical Analyst 扩展模块"></a>Geostatistical Analyst 扩展模块</h3><p>有关地理处理工具的增强功能，请参阅地统计分析工具箱。</p><h3 id="Image-Analyst-扩展模块"><a href="#Image-Analyst-扩展模块" class="headerlink" title="Image Analyst 扩展模块"></a>Image Analyst 扩展模块</h3><h4 id="变化检测"><a href="#变化检测" class="headerlink" title="变化检测"></a>变化检测</h4><ul><li><p>新的变化检测向导将使用地理处理工具和栅格函数指导您完成以下变化检测工作流：</p></li><li><ul><li>分类变化检测</li><li>时间序列变化检测</li><li>像素值变化检测</li></ul></li></ul><ul><li>已向 Image Analyst 工具箱添加一个新的变化检测工具集。</li><li>LandTrendr 分析栅格函数使用 基于 Landsat 的干扰和恢复趋势检测 (LandTrendr) 方法评估像素值随时间的变化，并生成包含模型结果的变化分析栅格。</li></ul><h4 id="多维分析"><a href="#多维分析" class="headerlink" title="多维分析"></a>多维分析</h4><ul><li>有关用于多维分析的新地理处理工具，请参阅 Image Analyst 工具箱下的“多维分析工具集”部分。</li><li>新的聚合多维栅格函数用于通过沿维度合并现有多维栅格变量数据来创建多维栅格图层。</li><li>现在，可直接将处理模板附加到采用云栅格格式的多维数据集 (.crf) 进行快速处理。</li></ul><h4 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h4><ul><li>有关新的和增强的地理处理工具，请参阅 Image Analyst 工具箱下的“深度学习工具集”部分。</li></ul><h4 id="全动态视频"><a href="#全动态视频" class="headerlink" title="全动态视频"></a>全动态视频</h4><ul><li>可以为从快速启动工具条启动的诸多活动创建和显示时间轴指示器。选择书签、导出帧、导出 PPT、导出帧、元数据转 CSV、导出片段、记录片段和录制视频时，将在时间轴上创建指示器。可通过右键单击时间轴，然后显示指示器表来显示指示器类型。显示表后，可选择行项目以打开或关闭指示器。活动矩形框将出现在指示器周围。</li></ul><table><thead><tr><th></th></tr></thead><tbody><tr><td>系统会在时间轴上指示各种视频播放器运算符的位置和持续时间。</td></tr></tbody></table><ul><li><p>可将视频内容导出到 PowerPoint。导出的内容可以包括当前帧、帧轮廓的全图范围，以及帧中心、帧轮廓和传感器平台的全图范围。</p></li><li><p>可自定义快速启动工具条以使用所需的控件配置视频播放器。</p></li><li><p>已对快速启动工具条和功能区视频播放器工具的标注和名称进行以下更改：</p></li><li><ul><li>创建点注记 - 替换添加图形。该工具将通过单击视频或地图上的帧轮廓创建点注记。</li><li>移除点注记 - 替换移除图形。该工具将移除未保存的点注记。</li><li>保存点注记 - 替换保存图形。该工具会将点注记保存到要素类。</li><li>导出帧 - 替换帧快照。该工具会将当前视频帧导出为图像。</li><li>导出多帧 - 替换帧转图像。该工具会将视频帧导出为图像。</li></ul></li></ul><p>有关地理处理工具的增强功能，请参阅 Image Analyst 工具箱。</p><h3 id="Network-Analyst-扩展模块"><a href="#Network-Analyst-扩展模块" class="headerlink" title="Network Analyst 扩展模块"></a>Network Analyst 扩展模块</h3><ul><li>此 GetNASublayer() 函数用于返回指定网络分析图层的指定子图层或子表的图层或表对象。</li><li>使用 saveAsLayerFile() 方法将求解器对象的分析结果另存为图层包。使用 .lpkx 扩展名指定输出图层路径。</li><li>求解器对象具有一个新方法 addFields()，用于将自定义字段添加到指定的输入类。</li><li>对于 NetworkDataset 类，可指定出行模式，并在检索边、交汇点或转弯时检索汇总的 COST、TIME、DISTANCE 和 ISRESTRICTED 属性。</li><li>可使用 ArcGIS Pro 中的编辑工具来创建新的转弯要素或修改现有转弯要素。</li><li>搜索条件和搜索查询参数现在位于添加位置和计算位置工具中。</li><li>ArcGIS Pro 2.7 中引入了更新的 VehicleRoutingProblem 对象方案，用于提供增强的可用性以及更紧密地匹配 ArcGIS Pro 2.6 中引入的车辆配送图层方案。</li></ul><h3 id="Spatial-Analyst-扩展模块"><a href="#Spatial-Analyst-扩展模块" class="headerlink" title="Spatial Analyst 扩展模块"></a>Spatial Analyst 扩展模块</h3><p>此版本提供了新的和改进的地理处理工具、栅格函数、ArcPy 函数以及地理处理函数。</p><h4 id="Spatial-Analyst-地理处理工具"><a href="#Spatial-Analyst-地理处理工具" class="headerlink" title="Spatial Analyst 地理处理工具"></a>Spatial Analyst 地理处理工具</h4><ul><li><p>新的存储容量工具将计算一系列高程增量处基础区域的表面积和总体积。</p></li><li><p>新的表面参数工具将使用用户指定的邻域和基于局部地形的自适应邻域来计算栅格表面的属性。</p></li></ul><ul><li>与以前的版本相比，边界清理和查找区域工具的性能显著提高。已提高使用平面距离方法时距离累积、距离分配和最佳区域连接工具的性能。</li></ul><p>有关地理处理工具增强功能的完整列表，请参阅 Spatial Analyst 工具箱。</p><h4 id="栅格函数-1"><a href="#栅格函数-1" class="headerlink" title="栅格函数"></a>栅格函数</h4><p>需要 Spatial Analyst 扩展模块许可才能使用以下新的和改进的栅格函数：</p><ul><li>新的边界清理栅格函数用于平滑栅格数据中区域之间的边界。</li><li>对于距离累积和距离分配栅格函数，已提高将距离方法参数设置为平面时二者的性能。还提高了最低成本路径栅格函数的性能。</li><li>核密度栅格函数具有一个新的输障碍垒参数，计算密度时可用于改变要素的影响。</li><li>分区统计栅格函数现在支持适用于浮点值栅格的中位数和百分位数统计数据类型。添加了新参数百分位数插值类型；用于定义输入栅格中要计算的值数量为偶数时使用的百分位数插值方法。该函数现在还支持对具有不同维度的输入进行多维处理。</li></ul><h4 id="ArcPy-函数"><a href="#ArcPy-函数" class="headerlink" title="ArcPy 函数"></a>ArcPy 函数</h4><p>有关新的 ArcPy 函数， 请参阅 Python Spatial Analyst。</p><h4 id="地理处理函数"><a href="#地理处理函数" class="headerlink" title="地理处理函数"></a>地理处理函数</h4><p>有关新的地理处理函数， 请参阅 Python Spatial Analyst。</p><h2 id="地理处理工具"><a href="#地理处理工具" class="headerlink" title="地理处理工具"></a>地理处理工具</h2><h3 id="3D-Analyst-工具箱"><a href="#3D-Analyst-工具箱" class="headerlink" title="3D Analyst 工具箱"></a>3D Analyst 工具箱</h3><h4 id="3D-要素工具集"><a href="#3D-要素工具集" class="headerlink" title="3D 要素工具集"></a>3D 要素工具集</h4><p>提取工具集包含以下新工具：</p><ul><li>从点云中提取供电力线 - 从已分类点云数据中提取用于对电力线进行建模的 3D 线要素。</li></ul><h4 id="栅格工具集"><a href="#栅格工具集" class="headerlink" title="栅格工具集"></a>栅格工具集</h4><p>表面工具集包含以下新工具：</p><ul><li>表面参数 - 通过拟合二次或四次表面来计算坡度、坡向和各种曲率。它支持用户指定的邻域距离和基于局部地表的自适应邻域。</li></ul><h4 id="可见性工具集"><a href="#可见性工具集" class="headerlink" title="可见性工具集"></a>可见性工具集</h4><p>已增强以下工具：</p><ul><li>通视性 - 支持集成网格，包括已应用修改的网格。</li><li>视线 - 支持已应用修改的集成网格。</li></ul><h3 id="分析工具箱"><a href="#分析工具箱" class="headerlink" title="分析工具箱"></a>分析工具箱</h3><h4 id="叠加分析工具集"><a href="#叠加分析工具集" class="headerlink" title="叠加分析工具集"></a>叠加分析工具集</h4><p>新工具：</p><ul><li>分配面 - 基于目标面图层的空间叠加来汇总输入面图层的属性，并将汇总的属性分配给目标面。</li><li>移除重叠（多个）- 移除多个输入图层中包含的面之间的重叠。</li></ul><h4 id="成对叠加工具集"><a href="#成对叠加工具集" class="headerlink" title="成对叠加工具集"></a>成对叠加工具集</h4><p>成对叠加工具集包含一些工具，出于功能和性能方面的考虑，这些工具可作为许多经典叠加工具的替代工具使用。新增以下工具：</p><ul><li>成对擦除 - 计算输入和擦除要素的成对交集。</li><li>成对裁剪 - 提取与裁剪要素重叠的输入要素。</li><li>成对整合 - 分析一个或多个要素类中要素之间的要素折点的坐标位置。</li></ul><h3 id="Aviation-工具箱"><a href="#Aviation-工具箱" class="headerlink" title="Aviation 工具箱"></a>Aviation 工具箱</h3><h4 id="机场工具集"><a href="#机场工具集" class="headerlink" title="机场工具集"></a>机场工具集</h4><p>障碍标识表面工具集包含以下增强功能：</p><ul><li><p>以下工具添加了适用于位移阈值点要素的新参数：</p></li><li><ul><li>FAA 13A</li><li>ICAO Annex 15</li><li>ICAO Annex 4</li><li>PAPI 障碍清除</li><li>光信号清除</li></ul></li><li><p>光信号清除工具具有一个新参数，用于根据 PAPI 灯光的位置设置在跑道横向侧生成的表面。</p></li></ul><p>新的直升机场障碍标识表面工具集中添加了以下工具：</p><ul><li>FAA 2C - 根据 FAA 咨询通告 150/5390-2C 的规定，为直升机停机坪生成障碍标识表面 (OIS)。</li></ul><h4 id="图表工具集"><a href="#图表工具集" class="headerlink" title="图表工具集"></a>图表工具集</h4><p>数据交换工具集包含以下新工具：</p><ul><li>导入数字障碍文件 - 使用输入数字障碍文件 (DOF) 在输入障碍要素类中添加、删除和更新障碍点要素。</li></ul><p>数据管理工具集包含以下新工具：</p><ul><li>处理空中交通服务路径 - 识别、概化和偏移重叠的空中交通服务 (ATS) 路径。</li><li>生成航线 - 在空域面的重合边中添加、修改或删除折线要素。</li><li>报告航空图变更 - 比较两个企业级地理数据库版本中的要素类并以报表的形式返回差异。</li></ul><h3 id="Business-Analyst-工具箱"><a href="#Business-Analyst-工具箱" class="headerlink" title="Business Analyst 工具箱"></a>Business Analyst 工具箱</h3><ul><li>多个工具现在支持 Arcade 表达式。这可提高根据数据中的任何字段值构建动态贸易区的灵活性。</li></ul><p>提供了两种新的环境设置：</p><ul><li>网络源 - 允许使用任何网络数据集进行网络计算和行驶时间分析，而与用于人口统计内容的 Business Analyst 数据源无关。</li><li>使用详细聚合 - 将详细的数据聚合方法用于较小的区域以及在超出指定半径时用于加快处理速度。</li></ul><h4 id="贸易区工具集"><a href="#贸易区工具集" class="headerlink" title="贸易区工具集"></a>贸易区工具集</h4><p>新工具：</p><ul><li>生成大致行驶时间 - 估计任何现有贸易区或边界的形式距离。</li><li>移除重叠（多个）- 移除多个输入图层中包含的面之间的重叠。</li></ul><p>已增强工具：</p><ul><li>移除重叠 - 已将新的中心线选项添加到方法参数。</li><li>生成阈值行驶时间和生成大致行驶时间 - 已添加两个新参数最小时间步和阈值差异百分比，用于控制行驶时间值的准确性。</li></ul><h3 id="制图工具箱"><a href="#制图工具箱" class="headerlink" title="制图工具箱"></a>制图工具箱</h3><h4 id="注记工具集"><a href="#注记工具集" class="headerlink" title="注记工具集"></a>注记工具集</h4><ul><li>等值线注记 - 已向等值线对齐参数添加新的将文本顶部朝下对齐选项。指定此选项后，文本顶部将朝下。这在等深线制图中非常有用。</li></ul><h4 id="栅格综合工具集"><a href="#栅格综合工具集" class="headerlink" title="栅格综合工具集"></a>栅格综合工具集</h4><ul><li>聚合面 - 已添加聚合字段可选参数。指定字段后，要素必须具有相同的属性值才能进行聚合。</li></ul><h3 id="转换工具箱"><a href="#转换工具箱" class="headerlink" title="转换工具箱"></a>转换工具箱</h3><h4 id="Excel-工具集"><a href="#Excel-工具集" class="headerlink" title="Excel 工具集"></a>Excel 工具集</h4><ul><li>Excel 转表 - 包含许多新参数，用于建立要导出的单元格范围以及定义 Excel 工作表中包含字段名称的行。</li></ul><h4 id="KML-工具集"><a href="#KML-工具集" class="headerlink" title="KML 工具集"></a>KML 工具集</h4><ul><li>地图转 KML - 此新工具用于将地图转换为包含几何和符号系统的 KML 文件。</li></ul><h4 id="转为栅格工具集"><a href="#转为栅格工具集" class="headerlink" title="转为栅格工具集"></a>转为栅格工具集</h4><ul><li>点转栅格、面转栅格和折线转栅格 - 此新参数用于指定是否为输出整型栅格创建栅格属性表。</li></ul><h3 id="数据管理工具箱"><a href="#数据管理工具箱" class="headerlink" title="数据管理工具箱"></a>数据管理工具箱</h3><h4 id="3D-对象工具集"><a href="#3D-对象工具集" class="headerlink" title="3D 对象工具集"></a>3D 对象工具集</h4><p>此工具集是 ArcGIS Pro 2.7 中的新工具集。</p><ul><li>将 3D 格式添加到多面体 - 通过链接要素类与一种或多种 3D 模型格式，将多面体转换为 3D 对象要素图层。</li><li>从多面体中移除 3D 格式 - 移除与已转换为 3D 对象要素图层的多面体关联的 3D 模型格式。</li></ul><h4 id="存档工具集"><a href="#存档工具集" class="headerlink" title="存档工具集"></a>存档工具集</h4><ul><li>修剪存档历史记录 - 现在支持从 SAP HANA 地理数据库中启用了存档的表和要素类中删除不需要的存档记录。</li></ul><h4 id="要素工具集"><a href="#要素工具集" class="headerlink" title="要素工具集"></a>要素工具集</h4><ul><li>检查几何和修复几何 - 现在支持存储在企业级地理数据库中的要素类。</li></ul><h4 id="字段工具集"><a href="#字段工具集" class="headerlink" title="字段工具集"></a>字段工具集</h4><ul><li><p>计算字段 - 已提高 SQL 表达式的性能。</p></li><li><p>编码字段 - 此新工具用于将分类值（字符串、整数或日期）转换为多个数值字段，每个字段表示一个类别。编码的数值字段可用于大多数数据科学和统计工作流，包括回归模型。</p></li><li><p>重分类字段 - 此新工具用于根据手动定义的边界或使用重分类方法将数值字段或文本字段中的值重分类为多个类。</p></li><li><p>标准化字段 - 此新工具通过将字段中的值转换为遵循指定比例的值来标准化这些值。标准化方法包括 z 得分、最小值-最大值、最大绝对值和稳健标准化。</p></li><li><p>转换字段 - 此新工具通过对每个值应用数学函数并更改分布的形状来转换一个或多个字段中的连续值。</p></li></ul><h4 id="打包工具集"><a href="#打包工具集" class="headerlink" title="打包工具集"></a>打包工具集</h4><ul><li><p>提取包工具具有两个新参数：</p></li><li><ul><li>储存格式类型 - 指定提取的缓存的存储格式。压缩选项用于对包文件中的切片进行分组，以提高在网络共享和云存储目录上的性能。松散选项用于将每个切片存储为单独的文件。仅当提取矢量切片包 (.vtpk) 时，此参数才可用。</li><li>创建即用型缓存数据集 - 使用提取的缓存创建即用型文件夹结构，以在 ArcGIS Enterprise 中创建切片层。仅当提取切片包 (.tpkx) 或矢量切片包 (.vtpk) 时， 此参数才可用。</li></ul></li></ul><h4 id="栅格工具集-1"><a href="#栅格工具集-1" class="headerlink" title="栅格工具集"></a>栅格工具集</h4><p>正射映射工具集包含以下新工具：</p><ul><li>导出帧和照相机参数 - 从镶嵌数据集中导出帧和照相机参数。</li></ul><p>栅格数据集工具集包含以下工具增强功能：</p><ul><li>创建随机栅格 - 此新参数用于指定当输出栅格值为整数时是否创建栅格属性表。</li></ul><h3 id="Defense-工具箱"><a href="#Defense-工具箱" class="headerlink" title="Defense 工具箱"></a>Defense 工具箱</h3><h4 id="距离和方向工具集"><a href="#距离和方向工具集" class="headerlink" title="距离和方向工具集"></a>距离和方向工具集</h4><ul><li>基于要素创建扇形视域 - 此新工具使用派生自点要素类或 shapefile 中的字段的属性来创建扇形视域。</li><li>基于要素创建环形视域 - 此新工具使用派生自点要素类或 shapefile 中的字段的属性来创建环形视域。</li></ul><h3 id="GeoAnalytics-Desktop-工具箱"><a href="#GeoAnalytics-Desktop-工具箱" class="headerlink" title="GeoAnalytics Desktop 工具箱"></a>GeoAnalytics Desktop 工具箱</h3><ul><li>以下工具中添加了新的 Arcade 表达式，用于计算轨迹上的速度、加速度和距离：重新构建轨迹（汇总数据）、计算字段（管理数据）和检测事件（查找位置）。</li></ul><h4 id="数据丰富工具集"><a href="#数据丰富工具集" class="headerlink" title="数据丰富工具集"></a>数据丰富工具集</h4><ul><li>计算动态统计数据 - 此新工具通过速度、加速度和方位角等统计数据丰富启用时间的点数据。</li></ul><h4 id="汇总数据工具集"><a href="#汇总数据工具集" class="headerlink" title="汇总数据工具集"></a>汇总数据工具集</h4><ul><li>汇总中心和离差 - 此新工具用于查找中心要素和方向分布并根据点数据计算平均和中位数位置。</li><li>重新构建轨迹 - 已添加了用于设置如何表示拆分轨迹的选项，包括使用 Arcade 表达式的选项。可使用拆分类型参数确定如何绘制和汇总轨迹。</li><li>连接要素 - 已添加一个选项，用于保留所有目标要素（称为左外连接）。</li></ul><h4 id="邻近分析工具集"><a href="#邻近分析工具集" class="headerlink" title="邻近分析工具集"></a>邻近分析工具集</h4><ul><li>追踪邻域事件 - 此新工具用于分析表示在空间和时间上移动的实体并且启用时间的点要素，以确定与其他实体的交互。</li></ul><h3 id="GeoAnalytics-Server-工具箱"><a href="#GeoAnalytics-Server-工具箱" class="headerlink" title="GeoAnalytics Server 工具箱"></a>GeoAnalytics Server 工具箱</h3><ul><li>以下工具中添加了新的 Arcade 表达式，用于计算轨迹上的速度、加速度和距离：重新构建轨迹（汇总数据）、计算字段（管理数据）和检测事件（查找位置）。</li></ul><h4 id="数据丰富工具集-1"><a href="#数据丰富工具集-1" class="headerlink" title="数据丰富工具集"></a>数据丰富工具集</h4><ul><li>计算动态统计数据 - 此新工具通过速度、加速度和方位角等统计数据丰富启用时间的点数据。</li></ul><h4 id="汇总数据工具集-1"><a href="#汇总数据工具集-1" class="headerlink" title="汇总数据工具集"></a>汇总数据工具集</h4><ul><li>汇总中心和离差 - 此新工具用于查找中心要素和方向分布并根据点数据计算平均和中位数位置。</li><li>重新构建轨迹 - 已添加了用于设置如何表示拆分轨迹的选项，包括使用 Arcade 表达式的选项。可使用拆分类型参数确定如何绘制和汇总轨迹。</li><li>连接要素 - 已添加一个选项，用于保留所有目标要素（称为左外连接）。</li></ul><h4 id="邻近分析工具集-1"><a href="#邻近分析工具集-1" class="headerlink" title="邻近分析工具集"></a>邻近分析工具集</h4><ul><li>追踪邻域事件 - 此新工具用于分析表示在空间和时间上移动的实体并且启用时间的点要素，以确定与其他实体的交互。</li></ul><h3 id="地理编码工具箱"><a href="#地理编码工具箱" class="headerlink" title="地理编码工具箱"></a>地理编码工具箱</h3><ul><li>创建要素定位器 - 已添加对连接数据的支持。</li><li>地理编码地址 - 已添加新的输出字段参数。</li><li>反向地理编码 - 当定位器参与复合定位器时，现在支持要素类型。如果参与的定位器支持多种要素类型，则此设置将限制在反向地理编码中返回的要素的类型。</li></ul><h4 id="传统工具集"><a href="#传统工具集" class="headerlink" title="传统工具集"></a>传统工具集</h4><ul><li>从 ArcGIS Pro 2.7 开始，已弃用创建地址定位器工具。</li></ul><h4 id="门户工具集"><a href="#门户工具集" class="headerlink" title="门户工具集"></a>门户工具集</h4><ul><li>地理编码文件 - 已添加新的输出字段参数。</li><li>对表中的位置进行地理编码 - 已添加新的输出字段参数。</li></ul><h3 id="Geostatistical-Analyst-工具箱"><a href="#Geostatistical-Analyst-工具箱" class="headerlink" title="Geostatistical Analyst 工具箱"></a>Geostatistical Analyst 工具箱</h3><h4 id="使用地统计图层工具集"><a href="#使用地统计图层工具集" class="headerlink" title="使用地统计图层工具集"></a>使用地统计图层工具集</h4><ul><li>3D GA 图层转 NetCDF - 此新输入研究区域面参数用于定义分析的研究区域。可创建符合研究区域的体素图层，而不是创建完整 3D 范围的立方体。</li></ul><h3 id="Image-Analyst-工具箱"><a href="#Image-Analyst-工具箱" class="headerlink" title="Image Analyst 工具箱"></a>Image Analyst 工具箱</h3><h4 id="变化检测工具集"><a href="#变化检测工具集" class="headerlink" title="变化检测工具集"></a>变化检测工具集</h4><p>新变化检测工具集包含以下工具，用于在两个栅格数据集之间执行变化检测。</p><ul><li>计算变化栅格 - 计算两个栅格数据集之间的绝对、相对或分类差异。</li></ul><h4 id="深度学习工具集"><a href="#深度学习工具集" class="headerlink" title="深度学习工具集"></a>深度学习工具集</h4><ul><li><p>计算对象检测的精度 - 此新工具用于计算使用深度学习检测对象工具的输出的精度。</p></li><li><p>导出训练数据进行深度学习 - 元数据格式参数中添加了两个新选项：</p></li><li><ul><li>MultiLabeled_Tiles</li><li>Export_Tiles</li></ul></li><li><p>训练深度学习模型 - 具有以下增强功能：</p></li><li><ul><li>现在支持更快的 R-CNN、YOLO 和 DeepLab 模型类型。</li><li>骨干模型参数支持新选项 DarkNet-53。</li><li>预训练模型参数现在接受深度学习包文件 (.dlpk) 作为输入。</li></ul></li><li><p>使用深度学习分类像素 - 现在支持生成分类栅格集合。</p></li></ul><h4 id="多维分析工具集"><a href="#多维分析工具集" class="headerlink" title="多维分析工具集"></a>多维分析工具集</h4><ul><li>使用 LandTrendr 工具分析变化 - 此新工具使用基于 Landsat 的干扰和恢复趋势检测 (LandTrendr) 方法评估像素值随时间的变化。</li><li>汇总分类栅格 - 此新工具用于生成一个表，其中包含多维分类栅格中每个剖切片的每个类别的像素计数和面积。</li><li>使用变化分析栅格检测变化 - 现在支持从使用 LandTrendr 分析变化工具的输出中提取变化信息。</li><li>生成趋势栅格 - 现在支持使用 Mann-Kendall 和 Seasonal-Kendall 趋势类型选项来检测趋势。</li></ul><h4 id="统计工具集"><a href="#统计工具集" class="headerlink" title="统计工具集"></a>统计工具集</h4><ul><li>分区统计和以表格显示分区统计 - 现在支持适用于浮点值栅格的中位数和百分位数统计数据类型。新参数百分位数插值类型用于定义输入栅格中要计算的值数量为偶数时使用的百分位数插值方法。这些工具现在还支持对具有不同维度的输入进行多维处理。</li></ul><h3 id="Indoors-工具箱"><a href="#Indoors-工具箱" class="headerlink" title="Indoors 工具箱"></a>Indoors 工具箱</h3><ul><li><p>将 BIM 导入室内数据集 - 此新工具用于将现有 BIM 楼层平面图从 Revit 文件导入室内数据集，无需先将其导出到 CAD 或文件地理数据库。</p></li><li><p>生成单元开口 - 此新工具用于将单元开口创建为对入口的位置和物理范围进行建模的线要素，以准备导出到 IMDF。</p></li><li><p>将楼层平面图导入 Indoors 地理数据库 - 具有以下增强功能：</p></li><li><ul><li>可以为每个楼层具有多个工程图的楼层平面图按设施点楼层导入多个 CAD 源文件。</li><li>新参数面积测量单位用于定义在导入楼层平面图时用于计算面积的测量单位。</li><li>将根据要素的相对高程计算楼层、单元、地区和区域的 Z 值。</li><li>配置电子表格包含在 ArcGIS Pro 安装的 Resources\Indoors 文件夹中。需要此电子表格才能将 CAD 图层映射到相应的 Indoors 要素类。</li></ul></li><li><p>创建室内数据库 - 可使用新参数创建室内网络有选择地创建不含网络数据集的 Indoors 工作空间。</p></li></ul><h4 id="Indoors-网络工具集"><a href="#Indoors-网络工具集" class="headerlink" title="Indoors 网络工具集"></a>Indoors 网络工具集</h4><ul><li>稀疏化室内路径 - 除了点要素之外，现在还接受面要素作为可路由位置参数。</li></ul><h3 id="情报工具箱"><a href="#情报工具箱" class="headerlink" title="情报工具箱"></a>情报工具箱</h3><h4 id="移动工具集"><a href="#移动工具集" class="headerlink" title="移动工具集"></a>移动工具集</h4><ul><li>分类移动事件 - 此新工具使用点轨迹数据确定移动事件，例如加速、转弯、停靠点和 U 形转弯。该信息可用于取证分析，以了解事故发生前车辆的移动方式，或者由海事机构用于监视拥挤或海盗多发的海道中的船舶交通情况。请参阅“亮点”部分中的移动分析工具。</li></ul><h3 id="多维工具箱"><a href="#多维工具箱" class="headerlink" title="多维工具箱"></a>多维工具箱</h3><ul><li>合并多维栅格 - 此新工具用于在空间上或跨变量和维度合并多个多维栅格数据集。</li><li>构建多维转置 - 现在支持删除现有转置。</li><li>管理多维栅格 - 现在支持更新统计数据以及将转置更新到修改后的多维数据集。</li></ul><h3 id="网络逻辑示意图工具箱"><a href="#网络逻辑示意图工具箱" class="headerlink" title="网络逻辑示意图工具箱"></a>网络逻辑示意图工具箱</h3><h4 id="配置工具集"><a href="#配置工具集" class="headerlink" title="配置工具集"></a>配置工具集</h4><ul><li>创建逻辑示意图图层定义 - 可使用新选项覆盖所有图层通过添加新的逻辑示意图子图层或覆盖某些现有逻辑示意图子图层上的设置同时保留其他逻辑示意图子图层来优化逻辑示意图图层定义。</li><li>按属性添加逻辑示意图要素功能规则 - 支持两个新功能：阻止减少交汇点和允许减少交汇点。可通过这些功能标记逻辑示意图交汇点，以通过规则序列中稍后执行的“减少交汇点”规则确定是否将其放弃。</li></ul><h4 id="布局工具集"><a href="#布局工具集" class="headerlink" title="布局工具集"></a>布局工具集</h4><ul><li>应用旋转树布局 - 可使用新选项以相同角度旋转交汇点符号将角度参数值添加到每个已处理逻辑示意图交汇点的元素旋转字段值。这允许您使用该字段值通过旋转来更改示意图交汇点符号，以便属于一个或多个树的逻辑示意图交汇点的符号也按照相同的旋转角度进行旋转。</li></ul><h3 id="宗地工具箱"><a href="#宗地工具箱" class="headerlink" title="宗地工具箱"></a>宗地工具箱</h3><ul><li>生成宗地结构链接 - 此新工具用于为在指定时间段内更改位置的宗地结构点生成位移链接。该工具只能在发布为要素服务的宗地结构上使用。</li><li>合并共线宗地边界 - 此新工具用于将连接的共线宗地线合并为单个宗地线。</li></ul><h4 id="管理工具集"><a href="#管理工具集" class="headerlink" title="管理工具集"></a>管理工具集</h4><ul><li>创建宗地记录 - 此新参数允许您使用 ArcGIS Arcade 表达式定义记录名称。可以使用字段、字符串运算符和数学运算符的组合来定义记录名称。</li></ul><h3 id="Raster-Analysis-工具箱"><a href="#Raster-Analysis-工具箱" class="headerlink" title="Raster Analysis 工具箱"></a>Raster Analysis 工具箱</h3><p>注：</p><p>仅当您登录到具有已针对栅格分析配置的 ArcGIS Image Server 的 ArcGIS Enterprise 时，这些工具才可用。</p><h4 id="分析模式工具集"><a href="#分析模式工具集" class="headerlink" title="分析模式工具集"></a>分析模式工具集</h4><ul><li>计算密度 - 已添加新的输入障碍要素参数。在计算密度时，可以使用障碍来改变要素的影响。</li></ul><h4 id="深度学习工具集-1"><a href="#深度学习工具集-1" class="headerlink" title="深度学习工具集"></a>深度学习工具集</h4><ul><li>使用深度学习分类对象 - 此新工具用于在输入栅格和可选要素类上运行训练深度学习模型，以生成所有输入对象或要素均分配有类或类别标注的要素类或表。</li></ul><h4 id="汇总数据工具集-2"><a href="#汇总数据工具集-2" class="headerlink" title="汇总数据工具集"></a>汇总数据工具集</h4><ul><li>汇总范围内的栅格和以表格显示分区统计 - 现在支持适用于浮点值栅格的中位数和百分位数统计数据类型。新参数百分位数插值类型用于定义输入栅格中要计算的值数量为偶数时使用的百分位数插值方法。这些工具现在还支持对具有不同维度的输入进行多维处理。</li></ul><h4 id="邻近分析工具集-2"><a href="#邻近分析工具集-2" class="headerlink" title="邻近分析工具集"></a>邻近分析工具集</h4><ul><li>最佳路径为线 - 新参数创建网络路径用于指定是否计算从目的地到源的完整（可能重叠）路径，或者是否创建不重叠的网络路径。</li><li>距离累积、距离分配和最佳区域连接 - 已提高将距离方法参数设置为平面时的性能。</li></ul><h4 id="邻近分析（旧版本）工具集"><a href="#邻近分析（旧版本）工具集" class="headerlink" title="邻近分析（旧版本）工具集"></a>邻近分析（旧版本）工具集</h4><ul><li>计算距离 - 已提高将距离方法参数设置为平面时的性能。</li><li>计算行程成本、确定最佳行程成本网络和确定行程成本路径折线 - 已提高性能。</li></ul><h3 id="时空模式挖掘工具箱"><a href="#时空模式挖掘工具箱" class="headerlink" title="时空模式挖掘工具箱"></a>时空模式挖掘工具箱</h3><p>已添加以下增强功能：</p><h4 id="“时间序列预测”工具集"><a href="#“时间序列预测”工具集" class="headerlink" title="“时间序列预测”工具集"></a>“时间序列预测”工具集</h4><ul><li>曲线拟合预测、指数平滑预测和基于森林的预测 - 这三个新参数用于检测和识别时空立方体的每个位置处时间序列中的异常值。可以使用输出要素上的交互式弹出图表查看识别的异常值。</li></ul><h4 id="实用工具工具集"><a href="#实用工具工具集" class="headerlink" title="实用工具工具集"></a>实用工具工具集</h4><ul><li>在 2D 模式下显示时空立方体和在 3D 模式下显示时空立方体工具均包含一个新的显示主题，用于显示和探索时空立方体的时间序列异常值。</li></ul><h3 id="Spatial-Analyst-工具箱"><a href="#Spatial-Analyst-工具箱" class="headerlink" title="Spatial Analyst 工具箱"></a>Spatial Analyst 工具箱</h3><h4 id="密度分析工具集"><a href="#密度分析工具集" class="headerlink" title="密度分析工具集"></a>密度分析工具集</h4><ul><li>核密度 - 现在支持使用测地线方法计算障碍要素的密度。</li></ul><h4 id="距离分析工具集"><a href="#距离分析工具集" class="headerlink" title="距离分析工具集"></a>距离分析工具集</h4><ul><li>最佳路径为线 - 已添加新的创建网络路径参数。使用新参数时，结果可用于联网。</li><li>距离累积、距离分配和最佳区域连接 - 已提高将距离方法参数设置为平面时的性能。</li></ul><h4 id="栅格综合工具集-1"><a href="#栅格综合工具集-1" class="headerlink" title="栅格综合工具集"></a>栅格综合工具集</h4><ul><li>边界清理 - 现在支持并行处理，以提高处理大型数据集时的性能。</li></ul><h4 id="水文分析工具集"><a href="#水文分析工具集" class="headerlink" title="水文分析工具集"></a>水文分析工具集</h4><ul><li>存储容量 - 此工具可用于为输入表面栅格创建高程和对应的存储容量表和图表。</li></ul><h4 id="影像分割和分类工具集"><a href="#影像分割和分类工具集" class="headerlink" title="影像分割和分类工具集"></a>影像分割和分类工具集</h4><ul><li>导出训练数据进行深度学习工具的元数据格式参数具有两个新选项，即 MultiLabeled_Tiles 和 Export_Tiles。</li></ul><h4 id="表面分析工具集"><a href="#表面分析工具集" class="headerlink" title="表面分析工具集"></a>表面分析工具集</h4><ul><li>新工具表面参数通过拟合二次或四次表面来计算坡度、坡向和各种曲率。它支持用户指定的邻域距离和基于局部地表的自适应邻域。</li><li>3D Analyst 工具箱中的添加表面信息和插值 Shape 工具现在 Spatial Analyst 中可用。</li></ul><h4 id="区域分析工具集"><a href="#区域分析工具集" class="headerlink" title="区域分析工具集"></a>区域分析工具集</h4><ul><li>分区统计和以表格显示分区统计工具现在支持适用于浮点值栅格的中位数和百分位数统计数据类型。添加了新参数百分位数插值类型，用于定义输入栅格中要计算的值数量为偶数时使用的百分位数插值方法。这些工具现在还支持对具有不同维度的输入进行多维处理。</li></ul><h3 id="空间统计工具箱"><a href="#空间统计工具箱" class="headerlink" title="空间统计工具箱"></a>空间统计工具箱</h3><p>已添加以下新工具：</p><h4 id="聚类分布制图工具集"><a href="#聚类分布制图工具集" class="headerlink" title="聚类分布制图工具集"></a>聚类分布制图工具集</h4><ul><li>空间异常值检测 - 此新工具通过计算每个要素的局部异常值因子 (LOF) 来识别点要素中的空间异常值。LOF 是一种测量，用于描述某个位置与其局部相邻要素之间的隔离程度。</li></ul><h4 id="度量地理分布工具集"><a href="#度量地理分布工具集" class="headerlink" title="度量地理分布工具集"></a>度量地理分布工具集</h4><ul><li>邻域汇总统计数据 - 此新工具使用邻域计算点或面要素的一个或多个数值字段的局部汇总统计数据。局部统计数据包括平均值、中位数、标准差、四分位距、偏度和分位数不平衡。</li></ul><h4 id="“空间关系建模”工具集"><a href="#“空间关系建模”工具集" class="headerlink" title="“空间关系建模”工具集"></a>“空间关系建模”工具集</h4><ul><li>区域之间的空间关联 - 此新工具用于测量同一研究区域的两个区域化之间的空间关联程度，其中每个区域化由一组类别（称为区域）组成。例如，该工具可用于测量同一研究区域的森林类型与土壤类之间的关联。</li></ul><h4 id="实用工具工具集-1"><a href="#实用工具工具集-1" class="headerlink" title="实用工具工具集"></a>实用工具工具集</h4><ul><li>降维 - 此新工具使用主成分分析 (PCA) 或降级线性判别分析 (LDA) 将尽可能高的方差量聚合成更少的分量，来降低连续变量集的维数。</li></ul><h3 id="Territory-Design-工具箱"><a href="#Territory-Design-工具箱" class="headerlink" title="Territory Design 工具箱"></a>Territory Design 工具箱</h3><p>已增强以下工具：</p><h4 id="地区解决方案工具集"><a href="#地区解决方案工具集" class="headerlink" title="地区解决方案工具集"></a>地区解决方案工具集</h4><ul><li><p>创建地区解决方案 - 已提高求解大型数据集基于点的地区时的性能。</p></li><li><p>生成地区报表 - 提供了两个新报表：</p></li><li><ul><li>重新对齐 - 包含重新分配的要素的汇总重新对齐报表。</li><li>详细的重新对齐 - 包含重新分配的要素的完整列表。</li></ul></li></ul><h3 id="地形生产工具箱"><a href="#地形生产工具箱" class="headerlink" title="地形生产工具箱"></a>地形生产工具箱</h3><h4 id="制图工具集"><a href="#制图工具集" class="headerlink" title="制图工具集"></a>制图工具集</h4><p>要素工具集包含以下新工具：</p><ul><li>计算磁分量 - 计算磁分量。</li></ul><h3 id="Workflow-Manager-工具箱"><a href="#Workflow-Manager-工具箱" class="headerlink" title="Workflow Manager 工具箱"></a>Workflow Manager 工具箱</h3><h4 id="配置工具集-1"><a href="#配置工具集-1" class="headerlink" title="配置工具集"></a>配置工具集</h4><ul><li>发布工作流服务 - 此新工具用于为 ArcGIS Workflow Manager (Classic) 资料档案库上传和共享作业位置的工作流服务和地图服务。</li></ul><h2 id="数据管理和工作流"><a href="#数据管理和工作流" class="headerlink" title="数据管理和工作流"></a>数据管理和工作流</h2><h3 id="BIM"><a href="#BIM" class="headerlink" title="BIM"></a>BIM</h3><ul><li>Revit 建筑物的 ExteriorShell 要素类概览表示现在是单个复杂对象。这可提高性能并简化建筑图层概览的使用。</li><li>ArcGIS Pro 会在读取内存中的 Revit 文件之前将其升级到最新版本。可使用新选项保存文件的升级版本。这将显著减少打开文件所需的时间。</li></ul><h3 id="CAD"><a href="#CAD" class="headerlink" title="CAD"></a>CAD</h3><p>现在支持将 AutoCAD 和 MicroStation 文件中的以下 CAD 对象和 3D CAD 实体作为多面体要素：</p><ul><li><p>表面</p></li><li><ul><li>放样</li><li>规划器</li><li>拉伸</li><li>旋转</li><li>扫掠</li><li>NURBS</li></ul></li><li><p>面网格</p></li><li><p>主体</p></li><li><p>区域</p></li></ul><p>现在支持将以下 Autodesk Civil 3D 实体作为多面体要素：</p><ul><li><p>压力网络</p></li><li><ul><li>配件</li><li>附属物</li><li>压力管道</li></ul></li><li><p>重力网络</p></li><li><ul><li>结构</li><li>管线</li></ul></li></ul><p>已改进对 MTEXT 实体的多行格式化的支持。（CAD 文件通常使用 MTEXT 实体将多行文本显示为单个实体。）</p><h3 id="Data-Reviewer"><a href="#Data-Reviewer" class="headerlink" title="Data Reviewer"></a>Data Reviewer</h3><p>此更新包括用于自动验证的新方法以及错误检查器窗格中的过滤器增强功能。</p><h4 id="自动验证方法"><a href="#自动验证方法" class="headerlink" title="自动验证方法"></a>自动验证方法</h4><p>检查海报已更新，现以多种语言提供，以使用 Data Reviewer 中的自动校验帮助规划和实施质量控制工作流。</p><p>下图和下表介绍了可用于自动验证具有启用 Data Reviewer 的属性规则的数据的新方法：</p><table><thead><tr><th>编号</th><th>校验</th><th>说明</th></tr></thead><tbody><tr><td></td><td>属性域</td><td>查找不符合与属性字段关联的编码值或范围域的属性值。</td></tr><tr><td></td><td>重复要素</td><td>查找被组合且共享属性（可选）的几何类型相同的要素。</td></tr><tr><td></td><td>子类型</td><td>查找包含错误或空子类型值的要素或行。</td></tr><tr><td></td><td>表-表属性</td><td>查找包含某些属性值的要素或行，这些属性值满足与另一个要素类或独立表中的值的定义关系。</td></tr><tr><td></td><td>不必要的结点</td><td>查找共享结点并包含相同属性值的折线要素。</td></tr><tr><td></td><td>不必要的面边界</td><td>查找共享公共边界并包含相同属性值的面要素。</td></tr></tbody></table><h4 id="错误检查器"><a href="#错误检查器" class="headerlink" title="错误检查器"></a>错误检查器</h4><p>错误检查器窗格已增强，现可基于一种或多种选定过滤器类型（例如生命周期阶段、状态或严重性）进行过滤。</p><h3 id="地理编码"><a href="#地理编码" class="headerlink" title="地理编码"></a>地理编码</h3><p>定位器增强功能：</p><ul><li><p>以下定位器属性适用于基于线的定位器：</p></li><li><ul><li>单侧偏移 - 确定地理编码结果的位置距街道线段的距离。</li><li>末端偏移 - 防止位于线段末端的地址编码结果落在其他要素（例如，十字路街道）的顶部。</li><li>交叉路口连接器 - 分隔作为交叉路口地址一部分的两个街道名称所需的字符。可以将自己的交叉路口连接器添加到属性。</li></ul></li><li><p>可以使用以下新选项调整参与复合定位器的定位器的结果顺序：</p></li><li><ul><li>使用定位器顺序 - 参与定位器将按其添加到创建复合地址定位器工具的顺序进行使用。</li><li>按角色和分数排序 - 参与定位器将按角色和回退顺序进行分组。</li><li>自定义顺序 - 可以在多角色定位器的角色之间插入定位器。</li></ul></li><li><p>存储在 ArcGIS Online 和 ArcGIS Enterprise 门户中的定位器可以作为参与定位器添加到本地复合定位器中。</p></li><li><p>中块匹配用于搜索表示一个或多个城市街区的一组门牌号，例如加利福尼亚州雷德兰兹的纽约街 100 街区或旧金山泰勒街 200-500 街区。</p></li></ul><p>重新匹配增强功能：</p><ul><li>可使用除用于批量地理编码的定位器之外的定位器查看和重新匹配地理编码结果。</li><li>重新匹配时，可修改定位器的地理编码选项。</li></ul><p>定位窗格增强功能：</p><ul><li>可以将添加到地图的独立表配置为搜索表中的记录。</li><li>可基于图层中所有字段或单个字段包含的值在地图图层中搜索要素。</li></ul><p>有关地理处理工具的增强功能，请参阅地理编码工具箱。有关 ArcPy 增强功能，请参阅 Python。</p><h3 id="地理数据库和数据库"><a href="#地理数据库和数据库" class="headerlink" title="地理数据库和数据库"></a>地理数据库和数据库</h3><p>ArcGIS Pro 2.7 提供了以下更改和新功能：</p><h4 id="常规-1"><a href="#常规-1" class="headerlink" title="常规"></a>常规</h4><ul><li>有一种新型地理数据库，称为移动地理数据库。这是存储在 SQLite 数据库的地理数据库的实施并具有文件扩展名 .geodatabase。请参阅“亮点”部分中的移动地理数据库。</li></ul><ul><li><p>创建要素类和创建表向导包含将输出数据集添加到当前地图的选项。有关详细信息，请参阅创建要素类。</p></li><li><p>创建复本工具支持仅注册现有数据功能。</p></li><li><p>为响应客户请求，提供了以下可用性和可访问性增强功能：</p></li><li><ul><li>在表格的“字段”视图中，可使用空格键切换选定行的可见性。</li><li>在“版本”视图中，可在管理版本时选择多个版本。</li><li>视图的属性页面包含定义选项卡，其中显示用于创建视图的查询定义。</li><li>M 和 Z 范围将显示在要素类的属性页面上。</li><li>在创建要素类和创建表向导中，可编辑系统维护的 OBJECTID 和 Shape 字段的别名。</li><li>管理子类型对话框具有快捷菜单、键盘快捷键和更佳的键盘导航。</li><li>启用企业级地理数据库工具可以从目录窗格的数据库的关联菜单打开。</li><li>移除命令  适用于内容窗格中的多个选定图层。同时适用于按数据源列出选项卡  中具有相同数据源的图层。</li><li>可通过右键单击属性域行访问属性域用法窗格。该窗格仍可从功能区上的属性域用法按钮  进行访问。</li><li>属性域用法窗格中的查看用法命令  用于在“子类型”或“字段”视图打开时突出显示选定属性域。要了解详细信息，请参阅识别属性域用法。</li><li>已将新命令添加到“字段”、“子类型”和“属性域”视图的关联菜单，以减少鼠标遍历。</li></ul></li></ul><h4 id="属性规则"><a href="#属性规则" class="headerlink" title="属性规则"></a>属性规则</h4><ul><li>可在评估属性规则时在文件地理数据库中评估批处理计算和验证。</li><li>结果字典关键字功能已扩展为允许更新具有属性规则的要素的多个字段。</li><li>可使用编辑字典关键字通过将 className 定义为 ^UN_Association 编辑任何公共设施网络关联。</li></ul><h4 id="企业级地理数据库和数据库"><a href="#企业级地理数据库和数据库" class="headerlink" title="企业级地理数据库和数据库"></a>企业级地理数据库和数据库</h4><ul><li>检查几何和修复几何工具支持存储在企业级地理数据库中的要素类。</li><li>可在 SAP HANA 地理数据库中启用存档的数据集上运行修剪存档历史记录工具。</li><li>从 ArcGIS Pro 2.7 开始，无法升级 Oracle 中的用户方案地理数据库；但是，在此版本中，可继续连接并使用用户方案地理数据库。了解有关将用户方案地理数据库移至 Oracle 中的独立地理数据库。</li><li>支持 SQLite 3.32.1 和 3.32.3。</li><li>IBM Db2 Version 11.1 Mod 4 Fix Pack 5 是 ArcGIS Pro 2.7 支持的最低版本。</li><li>Microsoft SQL Server 2016 是 ArcGIS Pro 2.7 支持的最低版本。</li><li>可在 Oracle 云端的虚拟机中安装 ArcGIS Pro 2.7 以连接并使用 Autonomous Transaction Processing database in Oracle Cloud 和协同管理的系统虚拟机数据库系统中的数据。</li></ul><h3 id="Indoors"><a href="#Indoors" class="headerlink" title="Indoors"></a>Indoors</h3><p>已添加以下新函数：</p><ul><li><p>现在可以在活动地图中基于面和点图层创建类别。</p></li><li><p>可在新的配置 Indoors 启动操作窗格中查看应用程序启动操作。可在此窗格中使用新的创建 Indoors 启动操作向导创建应用程序启动操作。</p></li><li><p>现在可在配置 Indoors 类别窗格的图层视图中查看、管理和创建按地图图层组织的类别。在“图层”视图中对类别所做的更改将反映在“类别”和“浏览”视图中。</p></li><li><p>创建默认 Indoors 类别向导可指导您完成简化工作流以根据基于图层符号系统的地图图层自动创建类别。</p></li><li><p>以下文件现包含在 ArcGIS Pro 安装的 Resources\Indoors 文件夹中。</p></li><li><ul><li>配置电子表格 - 需要该电子表格才能将 CAD 图层映射到相应的 Indoors 要素类。</li><li>最终网络模板 - 此模板用于创建 Indoors 网络。</li></ul></li></ul><p>已弃用以下功能：</p><ul><li><p>不再需要 Indoors 配置表即可配置应用程序启动操作。现在可使用创建 Indoors 启动动作向导配置 Indoors 启动操作。</p></li><li><p>Indoors 移动应用不再要求在 Indoors 配置表中配置底图。可在共享之前直接将底图添加到地图中为移动地图包配置底图。</p></li><li><p>已通过移除以下要素类字段简化 ArcGIS Indoors 信息模型：</p><p>注：</p><p>移除这些字段不会影响 Indoors 工具或客户端应用程序的行为。</p></li><li><ul><li>地标：UID_、FACILITY_ID、FACILITY_NAME、LEVEL_NAME、LEVEL_NUMBER、NAME、NAME_LONG、NAME_SUBTITLE、SECTION_ID、SECTION_NAME、SITE_ID、SITE_NAME、SOURCE_METHOD、SOURCE_NAME、SOURCE_PATH、SOURCE_TYPE、UNIT_ID、UNIT_NAME、USE_TYPE</li><li>路径和初步路径：UID_、ACCESS_PEDESTRIAN、ACCESS_WHEELCHAIR、HEIGHT_FROM、HEIGHT_TO、LOCATION_TYPE</li><li>过渡和初步过渡：UID_、ACCESS_PEDESTRIAN、ACCESS_WHEELCHAIR、LOCATION_TYPE</li></ul></li></ul><h3 id="Workflow-Manager"><a href="#Workflow-Manager" class="headerlink" title="Workflow Manager"></a>Workflow Manager</h3><p>ArcGIS Workflow Manager 是 ArcGIS Pro 的新扩展模块，用于您在服务驱动的 ArcGIS Workflow Manager Server 实施中创建和使用作业。</p><h3 id="Workflow-Manager-Classic"><a href="#Workflow-Manager-Classic" class="headerlink" title="Workflow Manager (Classic)"></a>Workflow Manager (Classic)</h3><ul><li>ArcGIS Workflow Manager (Classic) Administrator for ArcGIS Pro 提供了用于配置 Workflow Manager (Classic) 资料档案库的工具和组件，并且可以从 My Esri 单独下载。</li><li>已向工作流视图添加刷新作业列表按钮 ，用于刷新作业列表中的作业查询结果。</li></ul><h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><h3 id="常规-2"><a href="#常规-2" class="headerlink" title="常规"></a>常规</h3><ul><li>在创建要素窗格中，要素模板可基于连接的 GNSS 设备提供的位置创建要素。</li><li>正多边形 工具用于在指定的中心点和指定的径向外接距离处创建等边多边形。边数将作为构造工具的属性进行指定。</li><li>对齐和分布工具用于对齐要素的边或中心，或对其进行平均分布。可相对于彼此或指定的参考位置对它们进行对齐和分布。</li><li>草绘几何时，可打开推断约束  并使用推断的几何约束。</li><li>可创建和编辑 3D 对象要素。3D 对象要素类在地理数据库中存储和管理要素，使用已定义的地理位置且引用 3D 几何网格。要素引用的几何可以多种格式存储，并支持许多集成来自其他应用程序的 3D 模型文件的工作流。</li><li>可使用构造大地测量要素  工具创建符合大地测量学准则的要素作为增密线、弧和椭圆。</li><li>如果在草绘几何时切换要素构造工具或编辑工具，系统会提示您应用或放弃未完成的草绘。</li><li>在模板属性中，可为预设模板移除组件要素模板。</li><li>在属性窗格中，可通过在选择树视图中选择现有记录创建表模板。</li><li>在模板组中，可选择设置每个折点处的点（折线）构建器  以创建与偏移线要素或构造对象（主要线要素除外）重合的偏移点要素。</li><li>现在可使用线性参考编辑工具基于所选线要素创建路径、校准所选路径以及定义一部分路径。</li><li>在绘制线或面要素时，可添加具有相同的 x、y、z 和 m 值的折点作为右键单击折点。</li><li>当反转折线要素的方向时，则将根据反向方位角（如果存在）重新计算 COGO方向属性值。</li><li>可设置对齐 和简单对齐 尺寸注记工具以在每次连续点击后创建连续尺寸注记。</li><li>系统会在编辑工具主动过滤选择内容时发送弹出通知提醒您。</li><li>移动拓扑边时，工具窗格将包含缩放到边工具 。</li><li>修整工具  包含一个可选设置，用于选择要保留的要素。</li><li>数组工具  用于创建在矩形数组中分布的选定要素的多个副本。</li><li>导线工具  支持创建面。输入导线时，请在修改要素窗格中选择面要素图层。</li><li>导线工具  支持适用于曲线的增强数据输入选项。</li></ul><h3 id="宗地结构"><a href="#宗地结构" class="headerlink" title="宗地结构"></a>宗地结构</h3><ul><li>功能区的宗地选项卡下的质量选项卡在工具库中包含使用于质量驱动工作流的工具。其中包括新的合并边界 和合并点 工具。</li><li>使用合并点工具  可将两个或多个选定宗地结构点合并为单个点。</li><li>创建或升级宗地结构时，将在宗地结构要素类上创建了两个属性规则用于数据质量管理。</li><li>可使用预定义可选属性规则集进行宗地结构数据质量管理。可以为您的组织导入和配置这些可选规则。</li><li>对齐宗地工具  支持对齐曲线、重叠宗地以及交互删除链接和锚点。</li></ul><h2 id="影像和栅格数据"><a href="#影像和栅格数据" class="headerlink" title="影像和栅格数据"></a>影像和栅格数据</h2><ul><li>处理模板现在适用于所有栅格数据集，因此可存储处理模板以基于栅格数据动态生成信息图层。</li></ul><h3 id="栅格函数-2"><a href="#栅格函数-2" class="headerlink" title="栅格函数"></a>栅格函数</h3><ul><li>栅格函数套件的参考帮助从影像和栅格部分移动到了分析和地理处理部分。</li></ul><h3 id="多维栅格"><a href="#多维栅格" class="headerlink" title="多维栅格"></a>多维栅格</h3><ul><li>对于采用云栅格格式的多维栅格 (.crf)，可在栅格属性窗口中设置处理和显示的默认变量。</li></ul><p>有关新的和增强的地理处理工具，请参阅多维工具箱。</p><h3 id="正射映射"><a href="#正射映射" class="headerlink" title="正射映射"></a>正射映射</h3><ul><li>导出帧和照相机参数 - 此新工具用于从镶嵌数据集中导出帧和照相机参数。</li></ul><h2 id="制图和可视化"><a href="#制图和可视化" class="headerlink" title="制图和可视化"></a>制图和可视化</h2><h3 id="常规-3"><a href="#常规-3" class="headerlink" title="常规"></a>常规</h3><ul><li>访问调色板时，可使用取色器工具  从活动视图中选取一种颜色，然后将其应用于当前项目。</li></ul><ul><li><p>地图和场景的内容窗格的快捷菜单包含新的命令，用于打开和关闭选定图层。</p></li><li><p>现在，可过滤地图或场景以仅显示空要素图层。在内容窗格中，单击过滤器按钮 ，然后单击空要素图层。</p></li></ul><h3 id="3D-对象要素图层-1"><a href="#3D-对象要素图层-1" class="headerlink" title="3D 对象要素图层"></a>3D 对象要素图层</h3><ul><li>3D 对象要素图层是 ArcGIS Pro 中的新数据类型。请参阅“亮点”部分中的 3D 对象要素图层。</li></ul><h3 id="3D-场景和场景图层"><a href="#3D-场景和场景图层" class="headerlink" title="3D 场景和场景图层"></a>3D 场景和场景图层</h3><ul><li>现在可以使用投影工具将场景图层包投影到任何坐标系。</li><li>点场景图层在 I3S 1.7 版本中使用创建点场景图层包工具进行创建。</li><li>可以将自定义坐标系中的局部场景共享到 ArcGIS Enterprise10.9 或 ArcGIS Online。</li><li>可使用新图层属性使用预定义细节层次选择在任何场景图层类型的 I3S LoD 选择或 ArcGIS Pro LoD 选择之间进行切换。</li></ul><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><ul><li>动画属性窗格现在支持动画演示体素图层的属性，包括数据过滤、可见性和位置。</li></ul><h3 id="注记和标注"><a href="#注记和标注" class="headerlink" title="注记和标注"></a>注记和标注</h3><ul><li><p>等值线放置标注样式具有以下改进：</p></li><li><ul><li>等值线放置样式现在具有朝下标注对齐选项，可用于等深线制图。</li><li>非阶梯式等值线标注现放置在更宽、更平坦的等值线延长线上，并且放置在拐角或折弯处的可能性较低。</li><li>现在，阶梯中的最低等值线标注将放置在其先前放置的位置，即使其他等值线标注未过于靠近也是如此。</li><li>速度加快且标注的等值线数量增加。</li><li>等值线标注的直观朝上对齐。</li></ul></li><li><p>除了用作自适应策略之外，键编号现在还可用作放置策略，其中所有要素使用键进行标注。</p></li><li><p>设置注释的锚点位置时，现在可在使用面轮廓上最接近的点选项时在面内部插入锚点。这在标注面之间的边界时非常有用。</p></li><li><p>现在，ArcGIS Pro 文本符号和基于字体的形状标记支持可变字体。除了预设样式之外，还可以通过可变字体自定义字体变化，例如宽度、粗细、倾斜度等。</p></li></ul><ul><li><p>现在，Arcade 控制台函数在编写和调试标注表达式时受持。</p></li><li><p>将 Arcade 表达式用于标注表达式、标注旋转和备用表达式时，现在可以向表达式添加标题。</p></li></ul><p>有关地理处理工具的增强功能，请参阅“制图”工具箱。</p><h3 id="Arcade"><a href="#Arcade" class="headerlink" title="Arcade"></a>Arcade</h3><ul><li>ArcGIS Pro 支持 Arcade 1.12 版本。有关新功能的汇总，请参阅适用于高于 1.11 版本的版本的发行说明。</li></ul><h3 id="坐标系和变换"><a href="#坐标系和变换" class="headerlink" title="坐标系和变换"></a>坐标系和变换</h3><ul><li>现在可以基于地图的预期范围和内容生成建议的投影坐标系。指定要保留的投影属性（等距、等角、与点等距、沿子午线或折衷），以为指定范围创建自定义投影坐标系。</li><li>已改进从一个地理坐标系投影到另一个地理坐标系时指定变换的体验。</li></ul><h3 id="探索性分析工具"><a href="#探索性分析工具" class="headerlink" title="探索性分析工具"></a>探索性分析工具</h3><ul><li>使用新的高程剖面图工具在地图或场景中生成线性路径沿线的地面高程高度图。可通过单击视图手动定义线，也可以使用选定的线性要素。</li><li>运行新对象检测工具以在场景中显示的影像中查找感兴趣的实际对象。该工具需要在运行之前安装深度学习库以及 ArcGIS Pro Advanced 许可级别。</li></ul><h3 id="导出地图和布局"><a href="#导出地图和布局" class="headerlink" title="导出地图和布局"></a>导出地图和布局</h3><ul><li>GeoTIFF 导出现在适用于布局。以前，此功能仅在导出地图时可用。对于包含多个地图框的布局，可选择用于写入 GeoTIFF 标签的地图框。</li></ul><h3 id="要素图格"><a href="#要素图格" class="headerlink" title="要素图格"></a>要素图格</h3><ul><li>将启用要素图格的图层发布为 ArcGIS Enterprise 10.9 中的地图服务时，现在可以将其作为要素图层在 ArcGIS Pro 中使用。在此要素图层中，可通过更改符号系统和其他图格属性来更改图格的外观。在早期版本中，只能将该图层作为地图图像图层在ArcGIS Pro 中进行使用。无法在此地图图像图层中更改图格的符号系统或其他外观属性。</li></ul><h3 id="信息图表"><a href="#信息图表" class="headerlink" title="信息图表"></a>信息图表</h3><ul><li>比较信息图表可用于对任何信息图表模板中的多个要素执行并排比较。</li></ul><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><ul><li>可通过新的图例自适应策略手动列设置图例中的列数并在特定列中放置每个图例项目。</li><li>用于将格网转换为要素的新选项可针对高级编辑或放置情况基于格网组件创建要素。将格网转换为要素时，格网的组件将生成为要素类，这些要素类将作为图层添加到地图中。符号将应用于图层以与格网格组件相匹配。</li></ul><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><ul><li><p>书签包括以下改进：</p></li><li><ul><li>在书签库中，可使用新的关联菜单命令移除或更新书签。</li><li>在缩放至书签时用于在视图中显示该书签名称的新选项。</li><li>为了支持缩放到书签的任何子组件属性，已将新命令添加到书签窗格中书签的关联菜单。例如，仅照相机位置、仅时间值或仅范围值。</li><li>书签窗格现在支持文件夹结构以改进组织方式。</li></ul></li><li><p>在 2D 地图中，转到 XY 现在支持放置点、标注点和标注注释图形以在视图中标记位置。</p></li><li><p>地图导航现在可以通过提供仅在缩放时显示这些比例选项捕捉到比例。</p></li><li><p>全球或局部场景中提供了三个新的体积选择命令：按框选择 、按球体选择 和按圆柱选择 。</p></li><li><p>两个可选导航工具矩形放大 和矩形缩小 可通过自定义功能区或快速访问工具条进行添加。</p></li></ul><h3 id="弹出窗口"><a href="#弹出窗口" class="headerlink" title="弹出窗口"></a>弹出窗口</h3><ul><li>弹出窗口具有新的默认外观。这些改进包括字段元素中的替换行颜色、图像和图表元素的说明文字位置、饼图剖切片标注以及匹配的深色主题。选项对话框的导航选项卡上有一个选项可用于查看经典弹出窗口外观。</li><li>在配置弹出窗口时与元素进行交互并对其重新排列的常规改进。</li><li>已将新按钮添加到配置弹出窗口窗格，用于将元素顺时针旋转 90 度，从而提高将垂直堆叠的元素并排显示的能力。</li><li>图像元素现在支持 360 度全景图像。可以在常规或 360 度图像查看器中打开图像。</li><li>现在，可以在配置弹出窗口时嵌入图像元素的独立数据 URL 以及文本元素的 HTML。</li><li>新打印按钮可提高打印在弹出窗口中列出的属性信息图像的能力。</li></ul><h3 id="报告"><a href="#报告" class="headerlink" title="报告"></a>报告</h3><ul><li>现在可以将布局添加为报告之前和之后的补充页面。导出为 PDF 时，补充页面将包含在结果文件中。</li><li>新的报表文档视图可用于对报表部分进行重新排序以及添加或移除补充页面。</li></ul><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><ul><li><p>已将新符号添加到 ArcGIS 2D 系统样式，如下所示：</p><p>许多上述新符号可显示不同的符号效果和标记放置。与所有系统样式符号一样，可随时将其复制到“收藏夹”样式并根据需要进行修改。</p></li><li><ul><li>81 个新的点符号，包括基本几何形状和各种箭头。下面是此集合的示例。</li></ul></li></ul><ul><li>57 个新的线符号，包括更多虚线变体和带箭头的线。下面是此集合的示例。</li></ul><ul><li>24 个新的面符号。下面是此集合的示例。</li></ul><ul><li>已添加八个新的系统样式，包含 PANTONE® 颜色；下表概述了这样样式。Pantone 颜色是专色的一种特殊情况。它们是 Pantone 开发的专利标准色彩再现系统的一部分，用于确保色彩的一致性，无论用于显示或输出的介质为何。</li></ul><table><thead><tr><th>Pantone 色册和 ArcGIS Pro 样式名称</th><th>色册说明</th></tr></thead><tbody><tr><td>PANTONE® Formula Guide Solid Coated</td><td>铜版纸上的专色油墨</td></tr><tr><td>PANTONE® Formula Guide Solid Uncoated</td><td>未涂布纸上的专色油墨</td></tr><tr><td>PANTONE® Pastels &amp; Neons Coated</td><td>铜版纸上的纯色粉彩和霓虹油墨</td></tr><tr><td>PANTONE® Pastels &amp; Neons Uncoated</td><td>未涂布纸上的纯色粉彩和霓虹油墨</td></tr><tr><td>PANTONE® Metallics Coated Guide</td><td>铜版纸上的金属效果油墨</td></tr><tr><td>PANTONE® Extended Gamut Guide Coated</td><td>涂布纸上的 CMYK + OGV 四色油墨</td></tr><tr><td>PANTONE® Color Bridge Coated</td><td>铜版纸上的专色和四色油墨</td></tr><tr><td>PANTONE® Color Bridge Uncoated</td><td>未涂布纸上的专色和四色油墨</td></tr></tbody></table><ul><li>Intelligence 系统样式中共有 60 个新符号，每个符号具有 3 种大小。</li></ul><h3 id="符号系统"><a href="#符号系统" class="headerlink" title="符号系统"></a>符号系统</h3><ul><li>现在，可以在选择多个点符号时访问简单点符号周围轮廓的颜色和宽度。</li></ul><ul><li>选择多个符号后，符号预览将指示当前集中的符号数量。</li></ul><ul><li>新圆扇形 符号效果使用距该点的指定半径创建动态面。起始角和终止角用于定义扇形的宽度。</li></ul><ul><li>新面周围 标记放置用于将面周围的单个标记放置在 位置属性指定的位置处。</li></ul><ul><li><p>以下标记放置具有一个新按部件放置属性，用于控制如何在多部件要素上放置标记：</p></li><li><ul><li>沿线(大小可变)</li><li>面周围</li><li>居中</li><li>在端点处</li><li>采用测量单位</li><li>位于比例位置</li><li>在线上</li><li>在折点上</li></ul></li><li><p>现在可通过设置属性改变图片标记符号图层中使用的图像。</p></li></ul><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><ul><li>Web 要素图层中日期字段的时区信息将显示在日历控件中以及属性表字段标题的工具提示中。从 ArcGIS Enterprise 10.9 版开始，可使用首选时区或未知时区配置地图和要素服务。将支持这些设置。</li></ul><h3 id="矢量切片"><a href="#矢量切片" class="headerlink" title="矢量切片"></a>矢量切片</h3><ul><li><p>矢量切片创建现在支持以下设置：有关详细信息，请参阅矢量切片中的符号系统和在矢量切片中进行标注。</p></li><li><ul><li>设置为随地图旋转进行旋转的点符号以及点和面标注。</li><li>文本符号中的可变字体。</li><li>其他源内容（例如 attribution、bounds、minzoom、maxzoom 和 scheme）将写入矢量切片样式，以供使用这些属性的非 Esri 客户端使用。</li><li>使用从路径添加数据命令时，通过包含不符合 Esri URL 模式的 URL 的样式渲染矢量切片。</li></ul></li></ul><h2 id="生产"><a href="#生产" class="headerlink" title="生产"></a>生产</h2><h3 id="Airports"><a href="#Airports" class="headerlink" title="Airports"></a>Airports</h3><p>Airports 扩展模块中新增了以下功能和增强功能：</p><ul><li>已向包含有关 GeoNet 的实用操作演示视频的文档添加链接。</li><li>为了清楚起见，已编辑用于创建机场指示牌的工作流。</li><li>已向“地形和障碍物剖面”元素工具添加一个按钮，用于在对其属性进行更改后刷新剖面图元素。</li></ul><h3 id="Aviation-Charting"><a href="#Aviation-Charting" class="headerlink" title="Aviation Charting"></a>Aviation Charting</h3><p>ArcGIS Aviation Charting 扩展模块中新增了以下功能和增强功能：</p><ul><li>AIXM 4.5 中未使用的要素已从 AIS 地理数据库方案中移除。从 My Esri 下载更新的 Charting 产品数据文件。</li><li>航空首选项工具用于设置首选项，以决定 Aviation Charting 地理处理工具如何创建航线、处理路径以及在 ArcGIS Pro 中执行变化检测。</li><li>图表变更工具用于识别、验证、分组和过滤两个企业级地理数据库版本之间不同的要素类和表。可使用 图表变更工具查看 报告航空图变更地理处理工具生成的报表。</li></ul><h3 id="Defense-Mapping"><a href="#Defense-Mapping" class="headerlink" title="Defense Mapping"></a>Defense Mapping</h3><ul><li>已增强 MGCP 地形图 (MTM) 和地形图 (TM) 样式。</li></ul><h4 id="产品文件"><a href="#产品文件" class="headerlink" title="产品文件"></a>产品文件</h4><ul><li>已添加运行模型以将数据概化到指定比例的自动概化工作流。</li><li>已添加用于替换数据和边匹配数据的自动化工作流。它将替换现有数据，并将替换后的数据与权威数据存储中的现有数据进行边匹配。</li><li>已增强用于创建复本和发布的工作流，现在可以自动运行。</li><li>现在已改进 ArcGIS Workflow Manager (Classic) 中的扩展属性的组织、排序和一致行为。</li><li>已将验证规则添加到概化规则文件中，以支持特定字段的下拉选项和验证。</li><li>添加了用于验证规则文件并报告需要注意的错误和不一致的地理处理工具。</li><li>已提高概化模型的性能，以消除先前发行版中某些数据集的特定瓶颈问题。</li><li>向模型添加了新工具，用于支持概化工作流。这些工具包括用于替换现有数据和对替换数据进行边匹配的工具。</li><li>已增强针对农村和城市密度的交通主题。</li><li>已对“结构”主题进行增强，以改进建成区面生成。</li><li>已对“地球皮肤”主题进行增强，以提高“填充间隙”逻辑的性能和灵活性。</li></ul><h3 id="Maritime"><a href="#Maritime" class="headerlink" title="Maritime"></a>Maritime</h3><ul><li>引入 S-57 关系管理器后，您现在可以检查和管理等级（结构-设备）和点对点（集合）关系。</li><li>S-57 编辑组可用于设置编译范围，以在编译新数据源时自动赋予要素比例属性。</li><li>S-57 固定比例范围可用于按比例范围和产品类型在数据上设置过滤器。这有助于可视化中央数据库中哪些数据将出现在不同规模的产品中。</li><li>可在属性窗格中查看和编辑按逻辑分组的要素属性。</li></ul><h3 id="Pipeline-Referencing"><a href="#Pipeline-Referencing" class="headerlink" title="Pipeline Referencing"></a>Pipeline Referencing</h3><p>ArcGIS Pipeline Referencing 包含对软件和文档的以下增强功能：</p><ul><li><p>新增了对垂直路径几何的支持。</p><p>了解有关 Pipeline Referencing 中的垂直路径的详细信息</p></li><li><ul><li>可以在 ArcGIS Pro 中使用局部场景在 3D 模式下可视化和编辑具有垂直段的中心线、路径和事件。</li><li>具有垂直段的中心线可用于创建和编辑 LRS 网络中的现有路径。事件也可以位于这些垂直路段上，以用于分析和报告 LRS 数据。</li><li>垂直路径或具有垂直段的路径可以使用追加路径工具加载到 LRS 中。</li></ul></li><li><p>当 LRS 数据采用地理坐标系并且 x,y 空间参考单位不同于 z 测量单位时，额外添加了对 3D LRS 计算的支持。这些计算如下：</p><p>了解有关 Pipeline Referencing 中 3D 支持的详细信息</p></li><li><ul><li>LRS 编辑工具中提供的建议措施，例如创建路径、重新对齐路径和添加校准点</li><li>测量插值，用于在 LRS 网络中的路径和 LRS 事件中的事件的每个折点上填充 m 值</li></ul></li><li><p>新增了对复杂路径形状的支持：</p><p>了解有关 Pipeline Referencing 中的复杂形状的详细信息</p></li><li><ul><li>循环</li><li>棒棒糖</li><li>Alpha</li><li>分支</li><li>杠铃</li><li>在整个 Pipeline Referencing 中都支持形成复杂形状的路径，例如自闭合和自相交几何。</li><li>支持的复杂几何如下：</li></ul></li><li><p>新增了对将多部分中心线分割为单部分要素的支持：</p></li><li><ul><li>将中心线分割为单部分要素工具可用于将多部分中心线分解成单部分要素，从而可以更轻松地编辑和校准具有复杂形状的路径。</li></ul></li></ul><h3 id="Production-Mapping"><a href="#Production-Mapping" class="headerlink" title="Production Mapping"></a>Production Mapping</h3><p>Production Mapping 扩展模块中新增了以下功能和增强功能：</p><ul><li>已添加运行模型以将数据概化到指定比例的自动概化工作流。</li><li>已添加用于替换数据和边匹配数据的自动化工作流。它将替换现有数据，并将替换后的数据与权威数据存储中的现有数据进行边匹配。</li><li>已增强用于创建复本和发布的工作流，现在可以自动运行。</li><li>现在已改进 ArcGIS Workflow Manager (Classic) 中的扩展属性的组织、排序和一致行为。</li><li>已将验证规则添加到概化规则文件中，以支持特定字段的下拉选项和验证。</li><li>添加了用于验证规则文件并报告需要注意的错误和不一致的地理处理工具。</li><li>概化模型中新增了性能增强功能，以消除先前发行版中某些数据集的特定瓶颈问题。</li><li>向模型添加了新工具，用于支持概化工作流。这些工具包括用于替换现有数据和对替换数据进行边匹配的工具。</li><li>已增强针对农村和城市密度的交通主题。</li><li>已对“结构”主题进行增强，以改进建成区面生成。</li><li>已对“地球皮肤”主题进行增强，以提高“填充间隙”逻辑的性能和灵活性。</li></ul><h3 id="Roads-and-Highways"><a href="#Roads-and-Highways" class="headerlink" title="Roads and Highways"></a>Roads and Highways</h3><p>ArcGIS Roads and Highways 包含对软件和文档的以下增强功能：</p><ul><li><p>新增了对复杂路径形状的支持：</p><p>了解有关 Roads and Highways 中的复杂形状的详细信息</p></li><li><ul><li>循环</li><li>棒棒糖（死巷）</li><li>Alpha（坡道）</li><li>分支</li><li>杠铃</li><li>在整个 Roads and Highways 中都支持形成复杂形状的路径，例如自闭合和自相交几何。</li><li>支持的复杂几何如下：</li></ul></li><li><p>当 LRS 数据采用地理坐标系并且 x,y 空间参考单位不同于 z 测量单位时，额外添加了对 3D LRS 计算的支持。这些计算如下：</p><p>了解有关 Roads and Highways 中 3D 支持的详细信息</p></li><li><ul><li>LRS 编辑工具中提供的建议措施，例如创建路径、重新对齐路径和添加校准点</li><li>测量插值，用于在 LRS 网络中的路径和 LRS 事件中的事件的每个折点上填充 m 值。</li></ul></li><li><p>新增了对将多部分中心线分割为单部分要素的支持：</p></li><li><ul><li>将中心线分割为单部分要素工具可用于将多部分中心线分解成单部分要素，从而可以更轻松地编辑和校准具有复杂形状的路径。</li></ul></li></ul><h2 id="工程"><a href="#工程" class="headerlink" title="工程"></a>工程</h2><h3 id="常规-4"><a href="#常规-4" class="headerlink" title="常规"></a>常规</h3><ul><li>ArcGIS Pro 开始页面具有指向学习资源的直接链接。请参阅“亮点”部分中开始页面资源。</li><li>您可以将 GNSS (GPS) 设备连接到 ArcGIS Pro。请参阅“亮点”部分中的 GNSS 设备位置支持。</li></ul><ul><li>更新工程中的数据源时，现在可选择按原样应用更改，也可以先验证目标源，然后再应用更改。将光标悬停在数据源上时，现在可以看到数据类型和完整路径名称，如果是企业数据，还可以看到服务器信息。数据源无法更新的项目现在在不支持的项目标题下列出。查找并替换框中的文本字符串不再区分大小写。</li></ul><h2 id="共享工作"><a href="#共享工作" class="headerlink" title="共享工作"></a>共享工作</h2><ul><li><p>您现在可以保存 Web 图层和地图服务的服务定义以稍后共享到 ArcGIS Online、ArcGIS Enterprise 门户或独立 ArcGIS Server。</p></li><li><p>现在，您可以将包含关联 Web 要素图层的建筑场景图层发布到 ArcGIS Online 以支持编辑工作流。</p></li><li><p>替换 Web 图层工具已扩展，现支持将 Web 场景图层从文件夹或云数据存储中引用的场景缓存发布到 ArcGIS Enterprise10.8.1 及更高版本。</p></li><li><p>您现在可以将子类型图层组共享为 web 要素图层、切片图层和矢量切片图层，以及在 web 地图共享到 ArcGIS Online 或 ArcGIS Enterprise 10.9 及更高版本。</p></li><li><p>自动建议已添加为共享Web 切片图层、地图图像图层、web 影像图层和地图服务时的切片方案选项。此选项会根据地图或场景的坐标系（如果是 Web 影像图层，则根据数据的坐标系）自动建议缓存的切片方案。</p></li><li><p>现在可通过使用与所有客户端兼容的符号类型选项更好地控制 web 地图的符号系统。可通过在较新的客户端使用的 Web 地图中保留 2D 点标记符号来选择使用高级符号系统。</p></li><li><p>现在，您可以在共享 web 地图或场景时更新现有 web 图层的共享设置。</p></li><li><p>已通过其他选项增强共享移动地图包体验：</p></li><li><ul><li>引用在线内容可用于在地图中包含服务图层，以在连接到 Internet 的设备上使用。</li><li>如果拥有 ArcGIS Publisher 扩展模块，可使用设置地图到期设置到期日期，指定地图在到期时是否可以访问，以及包含到期消息。</li></ul></li><li><p>将 web 样式共享到 ArcGIS Online 或 ArcGIS Enterprise 10.9 及更高版本时，还会将自定义样式的副本作为桌面样式项目共享到您的门户。</p></li></ul><h2 id="追踪网络"><a href="#追踪网络" class="headerlink" title="追踪网络"></a>追踪网络</h2><ul><li>可使用新的结果类型参数选项网络图层创建输出图层组，以包含具有追踪返回的要素选择集的要素图层。有关详细信息，请参阅控制返回的内容。</li><li>现在支持将表作为追踪操作的起点和障碍的输入。</li></ul><p>需要使用追踪网路版本 2 才能支持以下功能：</p><p>注：</p><p>使用企业级地理数据库时，ArcGIS Pro 和 ArcGIS Enterprise 版本用于确定将创建和升级的追踪网络数据集的追踪网络版本。有关详细信息，请参阅 ArcGIS 平台兼容性。</p><ul><li>现在，企业级地理数据库支持追踪网络。使用 ArcGIS Enterprise 10.9 时，可使用要素访问服务共享分支版本化的追踪网络数据集。了解有关发布和使用追踪网络的详细信息。</li><li>使用追踪配置时，您现在可以在追踪网络中创建并存储复杂追踪，这些追踪可以通过 web 地图共享并在 web 应用程序、外业应用程序和 ArcGIS Pro 中使用。</li><li>FLOWDIRECTION 网络属性现在显示为网络中所有线要素类的可编辑字段。有关详细信息，请参阅追踪网络中的流向。</li></ul><h2 id="公共设施网络"><a href="#公共设施网络" class="headerlink" title="公共设施网络"></a>公共设施网络</h2><ul><li>现在，由门户联合服务器的版本确定使用创建公共设施网络工具创建的公共设施网络版本。这也适用于使用升级数据集工具升级公共设施网络。这可确保公共设施网络的版本与 ArcGIS Server 的版本兼容。有关详细信息，请参阅 ArcGIS 平台兼容性。</li><li>现在支持将表作为追踪操作的起点和障碍的输入。</li></ul><p>需要使用公共设施为网络版本 5 才能支持以下功能：</p><p>注：</p><p>使用企业级地理数据库时，ArcGIS Pro 和 ArcGIS Enterprise 版本用于确定将创建和升级的公共设施网络数据集的公共设施网络版本。有关详细信息，请参阅公共设施网络兼容性。</p><ul><li><p>使用追踪配置时，您现在可以在公共设施网络中创建并存储复杂追踪，这些追踪可以通过 web 地图共享并在 web 应用程序、外业应用程序和 ArcGIS Pro 中使用。</p></li><li><p>对子网管理进行了以下更改：</p></li><li><ul><li>已向所有域网络类（装配除外）添加新字段 Supporting Subnetwork Name，用于提供有关内容要素的信息以及支持要素的容器的子网名称。有关详细信息，请参阅支持的子网名称。</li><li>已将新属性 管理 IsDirty 添加到 层的子网定义的 “更新子网策略”。这样可以选择绕过管理子网表中 Is dirty 属性。</li><li>子网追踪配置中提供了新选项，用于控制如何更新、导出或追踪特定层的要素 - 包含容器、包含内容和包括结构。</li><li>已将更新结构和更新容器选项分别重新标记为更新结构网络容器和更新域网络容器，现在用于确定用作容器的要素或对象是否将在域和结构网络中更新其受支持的子网名称属性。</li><li>可使用追踪和设置子网定义工具中的验证可定位性新选项识别不用作内容或在结构上未附加到其关联层次结构中的另一个要素的对象。要了解详细信息，请参阅可定位性。</li></ul></li></ul><h3 id="网络逻辑示意图"><a href="#网络逻辑示意图" class="headerlink" title="网络逻辑示意图"></a>网络逻辑示意图</h3><ul><li>“旋转树”布局支持一个新选项，用于将逻辑示意图交汇点符号设置为以在执行布局期间应用的相同旋转角度进行变化。</li><li>现在，优化模板上的逻辑示意图图层定义变得更加灵活。创建逻辑示意图图层定义工具中新增了覆盖所有图层选项。如果在未选中该选项的情况下运行此工具，您可以在保留其他子图层的同时添加新的逻辑示意图子图层或覆盖现有逻辑示意图子图层上的设置。</li><li>添加逻辑示意图要素功能规则包括新功能，允许您标记逻辑示意图交汇点，以禁止或允许它们按稍后在逻辑示意图构建过程中执行的任何“缩减交汇点”规则进行缩减。</li><li>已增强“智能树”和“主线树”布局，以更好地管理结构附件。</li><li>网络逻辑示意图支持企业级地理数据库中的追踪网络版本 2。</li><li>您可以从追踪网络图层服务生成网络逻辑示意图。</li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="常规-5"><a href="#常规-5" class="headerlink" title="常规"></a>常规</h3><ul><li>ArcGIS Pro 中的 Python 版本已升级为 Python 3.7.9。</li><li>已添加 Python 代码格式化模块 black 和 Python 样式指南检查器模块 pycodestyle。</li></ul><h3 id="ArcGIS-Notebooks"><a href="#ArcGIS-Notebooks" class="headerlink" title="ArcGIS Notebooks"></a>ArcGIS Notebooks</h3><ul><li>现在支持可折叠的标题。</li><li>现已启用自动保存。</li><li>Notebook 命令现在可通过键盘快捷键使用，这些快捷键可通过 Esc 键进行模式切换来访问并在 Notebook 菜单中找到。</li><li>Shell 命令已在 ArcGIS Pro 2.6 部分启用，但现在在 ArcGIS Pro 2.7 中完全受支持。</li></ul><h3 id="ArcPy"><a href="#ArcPy" class="headerlink" title="ArcPy"></a>ArcPy</h3><ul><li>ArcPy (arcpy) 现在作为 conda 包提供，并且可通过 conda 进行安装。这意味着可以将 arcpy 和支持模块直接添加到您自己的自定义环境中。</li><li>数据访问游标（包括 InsertCursor、SearchCursor 和 UpdateCursor）现在支持通过 datum_transformation 新参数进行动态基准面转换。</li><li>已添加 GenerateOptimalCoordinateSystem 函数，以支持根据给定范围和其他条件动态选择最佳投影。</li><li>Locator 类具有新属性 multilineInputFields 和 SingleLineField，用于返回在进行地理编码时可以映射的输入字段列表。</li></ul><h3 id="Mapping-模块"><a href="#Mapping-模块" class="headerlink" title="Mapping 模块"></a>Mapping 模块</h3><p>在此版本中，对映射模块 (arcpy.mp) 进行了以下更改：</p><ul><li>添加了两个新的符号系统类：RasterStretchColorizer 和 UnclassedColorsRenderer。</li><li>LegendElement 类已扩展为允许修改各个 LegendItems。</li></ul><h3 id="“影像分析”模块"><a href="#“影像分析”模块" class="headerlink" title="“影像分析”模块"></a>“影像分析”模块</h3><p>Image Analyst 模块已重命名为 Image Analysis 模块 (arcpy.ia)；对现有脚本没有影响。</p><h4 id="ArcPy-函数-1"><a href="#ArcPy-函数-1" class="headerlink" title="ArcPy 函数"></a>ArcPy 函数</h4><p>已将以下新 ArcPy 函数添加到此版本中的 arcpy.ia 模块：</p><ul><li>分析 - ComputeChange、DetectChangeUsingChangeAnalysis、GenerateTrend 和 PredictUsingTrend</li><li>波段指数 - BAI、NBR、NDBI、NDMI 和 NDSI</li><li>分类 - Classify、LinearSpectralUnmixing、RegionGrow 和 SegMeanShift</li><li>转换 - RasterizeFeatures、RasterToXarray、TrendToRGB 和 XarrayToRaster</li><li>校正 - ApparentReflectance 和 Geometric</li><li>数据管理 - Buffered 和 Reproject</li><li>重分类 - ZonalRemap</li></ul><h4 id="地理处理函数-1"><a href="#地理处理函数-1" class="headerlink" title="地理处理函数"></a>地理处理函数</h4><p>Image Analysis 地理处理函数概览提供了功能类别表以及每个地理处理函数的链接。ArcGIS Image Analyst 扩展模块中新的可用地理处理工具也作为 arcpy.ia 模块中的新地理处理函数提供。新地理处理函数如下：</p><ul><li>变化检测 - ComputeChangeRaster</li><li>深度学习 - ComputeAccuracyForObjectDetection</li><li>多维分析 - AnalyzeChangesUsingLandTrendr 和 SummarizeCategoricalRaster</li></ul><h3 id="Spatial-Analyst-模块"><a href="#Spatial-Analyst-模块" class="headerlink" title="Spatial Analyst 模块"></a>Spatial Analyst 模块</h3><p>新 ArcPy 函数和地理处理函数适用于 arcpy.sa 模块。</p><h4 id="ArcPy-函数-2"><a href="#ArcPy-函数-2" class="headerlink" title="ArcPy 函数"></a>ArcPy 函数</h4><p>已将以下新 ArcPy 函数添加到此版本中的 arcpy.sa 模块：</p><ul><li>波段指数 - BAI、NBR、NDBI、NDMI 和 NDSI</li><li>分类 - Classify、LinearSpectralUnmixing、RegionGrow 和 SegMeanShift</li><li>转换 - RasterizeFeatures</li><li>重分类 - ZonalRemap</li></ul><h4 id="地理处理函数-2"><a href="#地理处理函数-2" class="headerlink" title="地理处理函数"></a>地理处理函数</h4><p>Spatial Analyst 地理处理函数概览提供了功能类别表以及每个地理处理函数的链接。ArcGIS Spatial Analyst 扩展模块中新的可用地理处理工具也作为 arcpy.sa 模块中的新地理处理函数提供。新地理处理函数如下：</p><ul><li>水文 - StorageCapacity</li><li>表面 - AddSurfaceInformation、InterpolateShape 和 SurfaceParameters</li></ul><h2 id="ArcGIS-Pro-SDK"><a href="#ArcGIS-Pro-SDK" class="headerlink" title="ArcGIS Pro SDK"></a>ArcGIS Pro SDK</h2><ul><li>ArcGIS Pro SDK for .NET 允许您通过 SDK 加载项和配置，使用您自己特有的工具和工作流来扩展 ArcGIS Pro。请参阅 2.7 版本面向开发人员的新特性。</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>有关近期、中期和长期开发目标的详细信息，请参考最新的 ArcGIS Pro 概述。</p><p><strong>软件下载</strong></p><p><strong>链接：<a href="https://pan.baidu.com/s/1H2Wgy5CvZ3fDDSghADKm6Q">https://pan.baidu.com/s/1H2Wgy5CvZ3fDDSghADKm6Q</a></strong></p><p><strong>提取码：ji0p</strong></p><p>阅读 3058</p><p>64ArcGIS Pro2.7下载和功能介绍</p><p>gisoracle <em>2021-03-19 08:08</em></p><p>关注微信号，回复：pro</p><p>申请账户：<a href="https://learn.arcgis.com/zh-cn/become-a-member/">https://learn.arcgis.com/zh-cn/become-a-member/</a></p><p><strong>ArcGIS Pro 2.7 提供的新功能和改进功能。</strong></p><h2 id="视频概览"><a href="#视频概览" class="headerlink" title="视频概览"></a>视频概览</h2><p>该视频汇编由 ArcGIS Pro 开发团队所创建，旨在突出显示该版本特有的新功能。</p><h2 id="亮点"><a href="#亮点" class="headerlink" title="亮点"></a>亮点</h2><p>亮点部分包含此版本的特色功能更新。</p><h3 id="GNSS-设备位置支持-1"><a href="#GNSS-设备位置支持-1" class="headerlink" title="GNSS 设备位置支持"></a>GNSS 设备位置支持</h3><p>可将 GNSS (GPS) 设备连接到 ArcGIS Pro 以在地图或场景中查看设备的位置。行进时，设备的位置会在视图中自动更新。</p><p>在打开位置后，可根据 GNSS 设备的当前地理位置创建要素，也可以设置点要素类以在位置更新时自动记录设备中的数据。</p><h3 id="移动地理数据库-1"><a href="#移动地理数据库-1" class="headerlink" title="移动地理数据库"></a>移动地理数据库</h3><p>移动地理数据库 是 ArcGIS Pro 2.7 中的新型地理数据库。与其他地理数据库一样，可创建移动地理数据库来存储地理数据集，执行数据建模任务以及用作地理处理工具和脚本的输入。</p><p>移动地理数据库存储在 SQLite 数据库，它具有以下优势：</p><ul><li>SQLite 是一个适用范围广、稳定且可靠的数据库。</li><li>SQLite 是公共域中的开源数据库，因此不需要许可。</li><li>SQLite 数据库支持跨平台并且存储在磁盘上的单个文件中，因此可移植并且是一种高效的数据交换格式。</li><li>SQLite 是功能齐全的关系数据库，用于通过 SQL 查询和报告工作流。</li></ul><p>移动地理数据库是在 ArcGIS Pro 和 ArcGIS Runtime 之间实现完全互操作工作流的第一步，并将增强 ArcGIS Runtime 和 Esri 移动应用程序套件中的工作流和应用程序。</p><h3 id="图层和要素混合-1"><a href="#图层和要素混合-1" class="headerlink" title="图层和要素混合"></a>图层和要素混合</h3><p>现在可以将混合模式应用于地图中的图层。例如，可增亮或加深图层，以引起人们注意地图各种颜色范围的增强或变暗。混合模式常用于图像编辑和图形设计工作流，可增强要素的可视化并更改设计要发布的地图的方式。</p><p>将混合模式应用于图层后，根据地图绘制顺序位于该图层下方的图层的视觉效果将发生改变。大多数混合模式将独立应用于每个颜色通道。</p><p>为了进一步控制，也可以将混合模式应用于单个要素图层中的要素。在这种情况下，符号化的要素将在图层中相互混合。</p><h3 id="线性参考-1"><a href="#线性参考-1" class="headerlink" title="线性参考"></a>线性参考</h3><p>线性参考系 (LRS) 可使用路径对线性距离和相关事件进行建模。这些路径将创建为包含 m 值的折线中心线要素，每个折点处都存在 m 值，用于存储独立于线几何的测量值。</p><p>现在可以基于所选线要素创建路径，使用指定的两个或多个校准点校准所选路线以及通过追踪并单击路径沿线的两个点定义一部分线性路径。</p><p>新的线性参考编辑功能是核心 ArcGIS Pro 应用程序的一部分。无需 Roads and Highways 或 Pipeline Referencing 等扩展模块产品即可使用它们。</p><h3 id="3D-对象要素图层-2"><a href="#3D-对象要素图层-2" class="headerlink" title="3D 对象要素图层"></a>3D 对象要素图层</h3><p>3D 对象要素类是 ArcGIS Pro 2.7 中的新数据类型。与多面体一样，3D 对象表示占据 3D 空间的要素的外壳，但是它们具有更丰富的属性集。例如，它们可以显示反射、阴影和粗糙度等特征。3D 对象要素类存储在文件地理数据库、企业级地理数据库或移动地理数据库中。文件地理数据库 3D 对象要素可以在许多第三方建模应用程序中直接打开和编辑，包括 Maya 和 Blender。</p><p>由多面体要素（左）和 3D 对象要素（右）表示的球体</p><p>将 3D 对象要素图层添加到 ArcGIS Pro 中的场景时，可使用适用于多面体的相同编辑和分析工具。可使用地理处理工具将多面体要素类和 3D 对象要素类相互转换。</p><h3 id="移动分析工具-1"><a href="#移动分析工具-1" class="headerlink" title="移动分析工具"></a>移动分析工具</h3><p>移动工具使用点轨迹数据来分析和可视化对象在空间和时间上的移动。点轨迹数据由按时间顺序排列的点位置组成，这些点位置按唯一设备（例如 GPS 或其他移动设备）进行分组。下面是四个移动分析补充工具：</p><ul><li>查找同行者用于确定哪些设备（例如移动电话）可能在同一地点和同一时间同行。</li><li>查找汇合位置用于确定几个设备停留较长时间的区域 - 表示可能的汇合位置。</li><li>比较区域用于查找同一地点和同一时间在已知区域运行的唯一设备。</li><li>分类移动事件用于识别点轨迹数据中的移动特定事件。</li></ul><p>分类移动事件是四个工具中的最新工具。该工具使用转弯信息（包括 U 形转弯）、停靠点以及有关加速和减速的信息对点轨迹数据进行归类，从而简化检查轨迹点以弄清实体在某个位置的移动方式这一耗时过程。这对于从事运输遥测、监控流量源或检查 GPS 设备指标的分析人员非常有用。</p><h3 id="开始页面资源-1"><a href="#开始页面资源-1" class="headerlink" title="开始页面资源"></a>开始页面资源</h3><p>可通过 ArcGIS Pro 开始页面快速访问相关资源来了解该软件。</p><ul><li>了解 ArcGIS Pro 最新版本的新特性 。</li><li>在“了解 ArcGIS” 站点上使用快速入门教程  学习技能并在解决实际问题时进行应用。</li><li>通过自学和 Esri 学院  提供的讲师指导课程提高 ArcGIS Pro 专业水平。</li><li>在 GeoNet  上提问、分享知识并与世界各地的 Esri 社区交换看法。</li><li>阅读 ArcGIS 博客  查看 Esri 产品工程师撰写的文章、公告和实用工作流。</li><li>获取有关 ArcGIS Pro 的各个方面的详细帮助 。</li></ul><h2 id="入门-1"><a href="#入门-1" class="headerlink" title="入门"></a>入门</h2><ul><li>系统管理员可通过 Pro.settingsConfig 文件代表用户管理应用程序设置。在 ArcGIS Pro 2.7 中，管理员可以为索引和本地帮助选项设置和锁定默认值。</li><li>ArcGIS Pro 开始页面已更新。请参阅“亮点”部分中开始页面资源。</li></ul><h2 id="分析和地理处理-1"><a href="#分析和地理处理-1" class="headerlink" title="分析和地理处理"></a>分析和地理处理</h2><h3 id="常规-6"><a href="#常规-6" class="headerlink" title="常规"></a>常规</h3><ul><li>地理处理工具上的运行拆分菜单按钮具有重置参数命令 ，用于将打开工具的所有参数恢复为其初始状态。</li><li>创建脚本工具时，可基于模板创建脚本文件 (.py)，以使用符合 Python 脚本工具模块的最佳做法的函数、参数处理和样式设置脚本。</li><li>新的地理处理选项以简称的形式显示数据路径用于控制地理处理工具上的数据路径是仅显示文件名还是显示完整的数据路径。</li><li>新的地理处理选项默认打开启用撤消用于控制支持撤消的地理处理工具是否自动打开启用撤消功能。</li></ul><h3 id="图表-1"><a href="#图表-1" class="headerlink" title="图表"></a>图表</h3><ul><li>新的图表类型矩阵热点图用于可视化分类变量之间的关系，也可用于可视化随时间的变化。</li></ul><ul><li><p>图表现在可以导出为汇总数据表。</p></li><li><p>散点图矩阵具有新的布局选项，包括将绘图显示为表示每种关系的强度和方向的皮尔逊相关系数 ( Pearson’s r) 的能力。</p></li></ul><ul><li><p>现在可以将移动平均叠加添加到时间条形图，以平滑时间趋势。</p></li><li><p>可右键单击内容窗格中的任何图表，然后单击复制来创建图表的副本。</p></li><li><p>除了数值字段之外，现在还可以通过右键单击字段，然后单击统计数据，直接基于属性表汇总字符串和日期字段。</p></li><li><p>栅格时间序列的时间分布图已增强，现可支持新的时间序列选项、每个位置的像素值统计数据以及位置和线颜色的默认配色方案。</p></li></ul><h3 id="地理处理历史-1"><a href="#地理处理历史-1" class="headerlink" title="地理处理历史"></a>地理处理历史</h3><ul><li>可基于工具中使用的输入数据过滤地理处理历史记录。例如，可以查找使用 Roads 图层作为输入的所有工具。</li><li>可以将地理处理历史记录中的工具添加到历史记录窗格的收藏夹部分。</li><li>新的地理处理选项将地理处理操作写入地理处理历史记录用于控制对工程中的地理处理历史记录的日志记录。</li><li>从地理处理历史记录中的工具获取 Python 命令时，如果该工具使用任何地理处理环境，则 Python 命令将包括一个 arcpy.EnvManager 代码块，用于帮助您高效设置环境。</li></ul><h3 id="地理处理服务-1"><a href="#地理处理服务-1" class="headerlink" title="地理处理服务"></a>地理处理服务</h3><ul><li>已添加一条消息，用于指示 GeoAnalytics Desktop、Portal 和 Intelligence 移动工具不支持发布到 ArcGIS Server。</li></ul><h3 id="链接分析-1"><a href="#链接分析-1" class="headerlink" title="链接分析"></a>链接分析</h3><ul><li>使用特征向量和页面等级中心性分析方法在链接图表中查找新的中心节点。</li><li>使用选择已连接工具  展开链接图表选择。该工具会将已连接实体添加至当前链接和实体选择集。</li><li>基于独立表以及要素类创建实体类型，并将其添加到新的或现有链接图表。</li></ul><h3 id="ModelBuilder-1"><a href="#ModelBuilder-1" class="headerlink" title="ModelBuilder"></a>ModelBuilder</h3><ul><li>可使用新的迭代图层工具在地图中的图层上进行迭代并使用图层的工作空间或图层类型分支化模型。可使用图层属性（例如图层可见性及其状态）过滤和限制模型处理。</li></ul><ul><li>模型输出现在具有以下增强功能：</li></ul><ul><li><ul><li>可使用添加到显示命令将输出添加到地图中。</li><li>输出将在内容窗格 ModelBuilder 图层组中显示。</li><li>输出图层名称包含 ModelBuilder 变量名称和变量值。</li></ul></li><li><p>模型构建器 报表视图支持交互式双向编辑和同步。</p></li><li><p>将工具添加到模型对话框包含以下增强功能：</p></li><li><ul><li>改进的图标</li><li>支持查找迭代器、实用程序和逻辑工具</li><li>显示工具所属的工具箱</li><li>支持选择多个工具并将其拖至模型窗口</li></ul></li></ul><h3 id="栅格函数-3"><a href="#栅格函数-3" class="headerlink" title="栅格函数"></a>栅格函数</h3><p>栅格函数套件的参考帮助从影像和栅格部分移动到了分析和地理处理部分。</p><p>可以将栅格函数合并为处理链，以在平移和漫游地图中的影像和栅格数据集时动态显示分析结果。</p><ul><li><p>向“波段算术”函数添加了六个波段指数。其中几个非常适合用于分析和绘制野火事件：</p></li><li><ul><li>燃烧面积指数 (BAI) - 使用光谱红光和 NIR 部分的反射率值来识别受火灾影响的地形面积。</li><li>归一化燃烧比率指数 (NBRI) - 使用 NIR 和 SWIR 波段来突出燃烧面积，同时减少光照和大气效应。</li><li>归一化差值建筑用地指数 (NDBI) - 使用 NIR 和 SWIR 波段来突出生产建筑用地开发。</li><li>归一化差值含水指数 (NDMI) - 检测植被的不同水分含量。用于监测干旱情况以及监测火灾多发区域的可燃物情况。</li><li>归一化差分雪盖指数 (NDSI) - 专门用于在忽略云覆盖的情况下， 使用 MODIS（波段 4 和波段 6）和 Landsat TM（波段 2 和波段 5）识别积雪覆盖范围。</li><li>归一化差值水体指数 (NDWI) - 用于描绘和监测地表含水量变化的指数。</li></ul></li><li><p>添加了三个新的栅格函数：</p></li><li><ul><li>边界清理 - 平滑栅格数据中区域之间的边界。这需要 Spatial Analyst 扩展模块。</li><li>LandTrendr 分析 - 使用基于 Landsat 的干扰和恢复趋势检测 (LandTrendr) 方法评估像素值随时间的变化，并生成包含模型结果的变化分析栅格。这需要 ArcGIS Image Analyst 扩展模块。</li><li>聚合多维 - 通过沿维度合并现有多维栅格变量数据来创建多维栅格图层。这需要 Image Analyst 或 Spatial Analyst 扩展模块。</li></ul></li><li><p>现有栅格函数具有以下增强功能：</p></li><li><ul><li>计算变化 - 支持使用过滤方法参数过滤要为分类变化检测生成的类。</li><li>使用变化分析检测变化 - 支持新的 LandTrendr 分析栅格函数的输出。</li><li>距离累积和距离分配 - 已提高将距离方法参数设置为平面时的性能。</li><li>生成趋势 - 支持使用 Mann-Kendall 和 Seasonal-Kendall 趋势分析方法检测趋势。</li><li>核密度 - 可使用新参数输入障碍在计算密度时改变要素的影响。这需要 Spatial Analyst 扩展模块。</li><li>最低成本路径 - 已提高性能。</li><li>合并栅格 - 支持在空间上或跨变量和维度合并多维栅格数据集。</li><li>统计数据 - 支持其他统计数据填充方法，包括众数和少数。</li><li>分区统计 - 支持适用于浮点值栅格的中位数和百分位数统计数据类型。新参数百分位数插值类型用于定义输入栅格中要计算的值数量为偶数时使用的百分位数插值方法。该函数现在还支持对具有不同维度的输入进行多维处理。这需要 Image Analyst 或 Spatial Analyst 扩展模块。</li></ul></li></ul><h3 id="空间统计-1"><a href="#空间统计-1" class="headerlink" title="空间统计"></a>空间统计</h3><ul><li><p>有关在此版本中添加的新地理处理工具的信息，请参阅空间统计工具箱。</p><p>|                                                            |<br>| ———————————————————- |<br>| 可使用新的“邻域汇总统计数据”工具计算处理邻域中点的平均值。 |</p></li></ul><h3 id="3D-Analyst-扩展模块-1"><a href="#3D-Analyst-扩展模块-1" class="headerlink" title="3D Analyst 扩展模块"></a>3D Analyst 扩展模块</h3><ul><li>可以将 LAS 点过滤为按类代码交互选择，这有助于以交互的方式对激光雷达点进行分类。</li><li>可使用 可见点按钮 仅选择您可以看到的点，而不是遮挡的点。这可防止意外选择远处的背景点。</li><li>可使用体积 3D 框、球体或圆柱选择 LAS 点。</li><li>可使用电力线选择工具根据预设参数沿线选择一系列点。</li><li>已缩短 LAS 数据集金字塔构建时间。</li><li>已提高应用了 Eye-Dome 照明 (EDL) 的场景中 LAS 数据集的渲染性能。</li></ul><p>有关地理处理工具增强功能，请参阅 3D Analyst 工具箱。</p><h3 id="Business-Analyst-扩展模块-1"><a href="#Business-Analyst-扩展模块-1" class="headerlink" title="Business Analyst 扩展模块"></a>Business Analyst 扩展模块</h3><ul><li>可通过目标营销改进功能通过向导创建报表。</li><li>业务搜索支持将 SafeGraph 作为数据源。</li></ul><p>有关地理处理工具增强功能，请参阅 Business Analyst 工具箱。</p><h3 id="Geostatistical-Analyst-扩展模块-1"><a href="#Geostatistical-Analyst-扩展模块-1" class="headerlink" title="Geostatistical Analyst 扩展模块"></a>Geostatistical Analyst 扩展模块</h3><p>有关地理处理工具的增强功能，请参阅地统计分析工具箱。</p><h3 id="Image-Analyst-扩展模块-1"><a href="#Image-Analyst-扩展模块-1" class="headerlink" title="Image Analyst 扩展模块"></a>Image Analyst 扩展模块</h3><h4 id="变化检测-1"><a href="#变化检测-1" class="headerlink" title="变化检测"></a>变化检测</h4><ul><li><p>新的变化检测向导将使用地理处理工具和栅格函数指导您完成以下变化检测工作流：</p></li><li><ul><li>分类变化检测</li><li>时间序列变化检测</li><li>像素值变化检测</li></ul></li></ul><ul><li>已向 Image Analyst 工具箱添加一个新的变化检测工具集。</li><li>LandTrendr 分析栅格函数使用 基于 Landsat 的干扰和恢复趋势检测 (LandTrendr) 方法评估像素值随时间的变化，并生成包含模型结果的变化分析栅格。</li></ul><h4 id="多维分析-1"><a href="#多维分析-1" class="headerlink" title="多维分析"></a>多维分析</h4><ul><li>有关用于多维分析的新地理处理工具，请参阅 Image Analyst 工具箱下的“多维分析工具集”部分。</li><li>新的聚合多维栅格函数用于通过沿维度合并现有多维栅格变量数据来创建多维栅格图层。</li><li>现在，可直接将处理模板附加到采用云栅格格式的多维数据集 (.crf) 进行快速处理。</li></ul><h4 id="深度学习-1"><a href="#深度学习-1" class="headerlink" title="深度学习"></a>深度学习</h4><ul><li>有关新的和增强的地理处理工具，请参阅 Image Analyst 工具箱下的“深度学习工具集”部分。</li></ul><h4 id="全动态视频-1"><a href="#全动态视频-1" class="headerlink" title="全动态视频"></a>全动态视频</h4><ul><li>可以为从快速启动工具条启动的诸多活动创建和显示时间轴指示器。选择书签、导出帧、导出 PPT、导出帧、元数据转 CSV、导出片段、记录片段和录制视频时，将在时间轴上创建指示器。可通过右键单击时间轴，然后显示指示器表来显示指示器类型。显示表后，可选择行项目以打开或关闭指示器。活动矩形框将出现在指示器周围。</li></ul><table><thead><tr><th></th></tr></thead><tbody><tr><td>系统会在时间轴上指示各种视频播放器运算符的位置和持续时间。</td></tr></tbody></table><ul><li><p>可将视频内容导出到 PowerPoint。导出的内容可以包括当前帧、帧轮廓的全图范围，以及帧中心、帧轮廓和传感器平台的全图范围。</p></li><li><p>可自定义快速启动工具条以使用所需的控件配置视频播放器。</p></li><li><p>已对快速启动工具条和功能区视频播放器工具的标注和名称进行以下更改：</p></li><li><ul><li>创建点注记 - 替换添加图形。该工具将通过单击视频或地图上的帧轮廓创建点注记。</li><li>移除点注记 - 替换移除图形。该工具将移除未保存的点注记。</li><li>保存点注记 - 替换保存图形。该工具会将点注记保存到要素类。</li><li>导出帧 - 替换帧快照。该工具会将当前视频帧导出为图像。</li><li>导出多帧 - 替换帧转图像。该工具会将视频帧导出为图像。</li></ul></li></ul><p>有关地理处理工具的增强功能，请参阅 Image Analyst 工具箱。</p><h3 id="Network-Analyst-扩展模块-1"><a href="#Network-Analyst-扩展模块-1" class="headerlink" title="Network Analyst 扩展模块"></a>Network Analyst 扩展模块</h3><ul><li>此 GetNASublayer() 函数用于返回指定网络分析图层的指定子图层或子表的图层或表对象。</li><li>使用 saveAsLayerFile() 方法将求解器对象的分析结果另存为图层包。使用 .lpkx 扩展名指定输出图层路径。</li><li>求解器对象具有一个新方法 addFields()，用于将自定义字段添加到指定的输入类。</li><li>对于 NetworkDataset 类，可指定出行模式，并在检索边、交汇点或转弯时检索汇总的 COST、TIME、DISTANCE 和 ISRESTRICTED 属性。</li><li>可使用 ArcGIS Pro 中的编辑工具来创建新的转弯要素或修改现有转弯要素。</li><li>搜索条件和搜索查询参数现在位于添加位置和计算位置工具中。</li><li>ArcGIS Pro 2.7 中引入了更新的 VehicleRoutingProblem 对象方案，用于提供增强的可用性以及更紧密地匹配 ArcGIS Pro 2.6 中引入的车辆配送图层方案。</li></ul><h3 id="Spatial-Analyst-扩展模块-1"><a href="#Spatial-Analyst-扩展模块-1" class="headerlink" title="Spatial Analyst 扩展模块"></a>Spatial Analyst 扩展模块</h3><p>此版本提供了新的和改进的地理处理工具、栅格函数、ArcPy 函数以及地理处理函数。</p><h4 id="Spatial-Analyst-地理处理工具-1"><a href="#Spatial-Analyst-地理处理工具-1" class="headerlink" title="Spatial Analyst 地理处理工具"></a>Spatial Analyst 地理处理工具</h4><ul><li><p>新的存储容量工具将计算一系列高程增量处基础区域的表面积和总体积。</p></li><li><p>新的表面参数工具将使用用户指定的邻域和基于局部地形的自适应邻域来计算栅格表面的属性。</p></li></ul><ul><li>与以前的版本相比，边界清理和查找区域工具的性能显著提高。已提高使用平面距离方法时距离累积、距离分配和最佳区域连接工具的性能。</li></ul><p>有关地理处理工具增强功能的完整列表，请参阅 Spatial Analyst 工具箱。</p><h4 id="栅格函数-4"><a href="#栅格函数-4" class="headerlink" title="栅格函数"></a>栅格函数</h4><p>需要 Spatial Analyst 扩展模块许可才能使用以下新的和改进的栅格函数：</p><ul><li>新的边界清理栅格函数用于平滑栅格数据中区域之间的边界。</li><li>对于距离累积和距离分配栅格函数，已提高将距离方法参数设置为平面时二者的性能。还提高了最低成本路径栅格函数的性能。</li><li>核密度栅格函数具有一个新的输障碍垒参数，计算密度时可用于改变要素的影响。</li><li>分区统计栅格函数现在支持适用于浮点值栅格的中位数和百分位数统计数据类型。添加了新参数百分位数插值类型；用于定义输入栅格中要计算的值数量为偶数时使用的百分位数插值方法。该函数现在还支持对具有不同维度的输入进行多维处理。</li></ul><h4 id="ArcPy-函数-3"><a href="#ArcPy-函数-3" class="headerlink" title="ArcPy 函数"></a>ArcPy 函数</h4><p>有关新的 ArcPy 函数， 请参阅 Python Spatial Analyst。</p><h4 id="地理处理函数-3"><a href="#地理处理函数-3" class="headerlink" title="地理处理函数"></a>地理处理函数</h4><p>有关新的地理处理函数， 请参阅 Python Spatial Analyst。</p><h2 id="地理处理工具-1"><a href="#地理处理工具-1" class="headerlink" title="地理处理工具"></a>地理处理工具</h2><h3 id="3D-Analyst-工具箱-1"><a href="#3D-Analyst-工具箱-1" class="headerlink" title="3D Analyst 工具箱"></a>3D Analyst 工具箱</h3><h4 id="3D-要素工具集-1"><a href="#3D-要素工具集-1" class="headerlink" title="3D 要素工具集"></a>3D 要素工具集</h4><p>提取工具集包含以下新工具：</p><ul><li>从点云中提取供电力线 - 从已分类点云数据中提取用于对电力线进行建模的 3D 线要素。</li></ul><h4 id="栅格工具集-2"><a href="#栅格工具集-2" class="headerlink" title="栅格工具集"></a>栅格工具集</h4><p>表面工具集包含以下新工具：</p><ul><li>表面参数 - 通过拟合二次或四次表面来计算坡度、坡向和各种曲率。它支持用户指定的邻域距离和基于局部地表的自适应邻域。</li></ul><h4 id="可见性工具集-1"><a href="#可见性工具集-1" class="headerlink" title="可见性工具集"></a>可见性工具集</h4><p>已增强以下工具：</p><ul><li>通视性 - 支持集成网格，包括已应用修改的网格。</li><li>视线 - 支持已应用修改的集成网格。</li></ul><h3 id="分析工具箱-1"><a href="#分析工具箱-1" class="headerlink" title="分析工具箱"></a>分析工具箱</h3><h4 id="叠加分析工具集-1"><a href="#叠加分析工具集-1" class="headerlink" title="叠加分析工具集"></a>叠加分析工具集</h4><p>新工具：</p><ul><li>分配面 - 基于目标面图层的空间叠加来汇总输入面图层的属性，并将汇总的属性分配给目标面。</li><li>移除重叠（多个）- 移除多个输入图层中包含的面之间的重叠。</li></ul><h4 id="成对叠加工具集-1"><a href="#成对叠加工具集-1" class="headerlink" title="成对叠加工具集"></a>成对叠加工具集</h4><p>成对叠加工具集包含一些工具，出于功能和性能方面的考虑，这些工具可作为许多经典叠加工具的替代工具使用。新增以下工具：</p><ul><li>成对擦除 - 计算输入和擦除要素的成对交集。</li><li>成对裁剪 - 提取与裁剪要素重叠的输入要素。</li><li>成对整合 - 分析一个或多个要素类中要素之间的要素折点的坐标位置。</li></ul><h3 id="Aviation-工具箱-1"><a href="#Aviation-工具箱-1" class="headerlink" title="Aviation 工具箱"></a>Aviation 工具箱</h3><h4 id="机场工具集-1"><a href="#机场工具集-1" class="headerlink" title="机场工具集"></a>机场工具集</h4><p>障碍标识表面工具集包含以下增强功能：</p><ul><li><p>以下工具添加了适用于位移阈值点要素的新参数：</p></li><li><ul><li>FAA 13A</li><li>ICAO Annex 15</li><li>ICAO Annex 4</li><li>PAPI 障碍清除</li><li>光信号清除</li></ul></li><li><p>光信号清除工具具有一个新参数，用于根据 PAPI 灯光的位置设置在跑道横向侧生成的表面。</p></li></ul><p>新的直升机场障碍标识表面工具集中添加了以下工具：</p><ul><li>FAA 2C - 根据 FAA 咨询通告 150/5390-2C 的规定，为直升机停机坪生成障碍标识表面 (OIS)。</li></ul><h4 id="图表工具集-1"><a href="#图表工具集-1" class="headerlink" title="图表工具集"></a>图表工具集</h4><p>数据交换工具集包含以下新工具：</p><ul><li>导入数字障碍文件 - 使用输入数字障碍文件 (DOF) 在输入障碍要素类中添加、删除和更新障碍点要素。</li></ul><p>数据管理工具集包含以下新工具：</p><ul><li>处理空中交通服务路径 - 识别、概化和偏移重叠的空中交通服务 (ATS) 路径。</li><li>生成航线 - 在空域面的重合边中添加、修改或删除折线要素。</li><li>报告航空图变更 - 比较两个企业级地理数据库版本中的要素类并以报表的形式返回差异。</li></ul><h3 id="Business-Analyst-工具箱-1"><a href="#Business-Analyst-工具箱-1" class="headerlink" title="Business Analyst 工具箱"></a>Business Analyst 工具箱</h3><ul><li>多个工具现在支持 Arcade 表达式。这可提高根据数据中的任何字段值构建动态贸易区的灵活性。</li></ul><p>提供了两种新的环境设置：</p><ul><li>网络源 - 允许使用任何网络数据集进行网络计算和行驶时间分析，而与用于人口统计内容的 Business Analyst 数据源无关。</li><li>使用详细聚合 - 将详细的数据聚合方法用于较小的区域以及在超出指定半径时用于加快处理速度。</li></ul><h4 id="贸易区工具集-1"><a href="#贸易区工具集-1" class="headerlink" title="贸易区工具集"></a>贸易区工具集</h4><p>新工具：</p><ul><li>生成大致行驶时间 - 估计任何现有贸易区或边界的形式距离。</li><li>移除重叠（多个）- 移除多个输入图层中包含的面之间的重叠。</li></ul><p>已增强工具：</p><ul><li>移除重叠 - 已将新的中心线选项添加到方法参数。</li><li>生成阈值行驶时间和生成大致行驶时间 - 已添加两个新参数最小时间步和阈值差异百分比，用于控制行驶时间值的准确性。</li></ul><h3 id="制图工具箱-1"><a href="#制图工具箱-1" class="headerlink" title="制图工具箱"></a>制图工具箱</h3><h4 id="注记工具集-1"><a href="#注记工具集-1" class="headerlink" title="注记工具集"></a>注记工具集</h4><ul><li>等值线注记 - 已向等值线对齐参数添加新的将文本顶部朝下对齐选项。指定此选项后，文本顶部将朝下。这在等深线制图中非常有用。</li></ul><h4 id="栅格综合工具集-2"><a href="#栅格综合工具集-2" class="headerlink" title="栅格综合工具集"></a>栅格综合工具集</h4><ul><li>聚合面 - 已添加聚合字段可选参数。指定字段后，要素必须具有相同的属性值才能进行聚合。</li></ul><h3 id="转换工具箱-1"><a href="#转换工具箱-1" class="headerlink" title="转换工具箱"></a>转换工具箱</h3><h4 id="Excel-工具集-1"><a href="#Excel-工具集-1" class="headerlink" title="Excel 工具集"></a>Excel 工具集</h4><ul><li>Excel 转表 - 包含许多新参数，用于建立要导出的单元格范围以及定义 Excel 工作表中包含字段名称的行。</li></ul><h4 id="KML-工具集-1"><a href="#KML-工具集-1" class="headerlink" title="KML 工具集"></a>KML 工具集</h4><ul><li>地图转 KML - 此新工具用于将地图转换为包含几何和符号系统的 KML 文件。</li></ul><h4 id="转为栅格工具集-1"><a href="#转为栅格工具集-1" class="headerlink" title="转为栅格工具集"></a>转为栅格工具集</h4><ul><li>点转栅格、面转栅格和折线转栅格 - 此新参数用于指定是否为输出整型栅格创建栅格属性表。</li></ul><h3 id="数据管理工具箱-1"><a href="#数据管理工具箱-1" class="headerlink" title="数据管理工具箱"></a>数据管理工具箱</h3><h4 id="3D-对象工具集-1"><a href="#3D-对象工具集-1" class="headerlink" title="3D 对象工具集"></a>3D 对象工具集</h4><p>此工具集是 ArcGIS Pro 2.7 中的新工具集。</p><ul><li>将 3D 格式添加到多面体 - 通过链接要素类与一种或多种 3D 模型格式，将多面体转换为 3D 对象要素图层。</li><li>从多面体中移除 3D 格式 - 移除与已转换为 3D 对象要素图层的多面体关联的 3D 模型格式。</li></ul><h4 id="存档工具集-1"><a href="#存档工具集-1" class="headerlink" title="存档工具集"></a>存档工具集</h4><ul><li>修剪存档历史记录 - 现在支持从 SAP HANA 地理数据库中启用了存档的表和要素类中删除不需要的存档记录。</li></ul><h4 id="要素工具集-1"><a href="#要素工具集-1" class="headerlink" title="要素工具集"></a>要素工具集</h4><ul><li>检查几何和修复几何 - 现在支持存储在企业级地理数据库中的要素类。</li></ul><h4 id="字段工具集-1"><a href="#字段工具集-1" class="headerlink" title="字段工具集"></a>字段工具集</h4><ul><li><p>计算字段 - 已提高 SQL 表达式的性能。</p></li><li><p>编码字段 - 此新工具用于将分类值（字符串、整数或日期）转换为多个数值字段，每个字段表示一个类别。编码的数值字段可用于大多数数据科学和统计工作流，包括回归模型。</p></li><li><p>重分类字段 - 此新工具用于根据手动定义的边界或使用重分类方法将数值字段或文本字段中的值重分类为多个类。</p></li><li><p>标准化字段 - 此新工具通过将字段中的值转换为遵循指定比例的值来标准化这些值。标准化方法包括 z 得分、最小值-最大值、最大绝对值和稳健标准化。</p></li><li><p>转换字段 - 此新工具通过对每个值应用数学函数并更改分布的形状来转换一个或多个字段中的连续值。</p></li></ul><h4 id="打包工具集-1"><a href="#打包工具集-1" class="headerlink" title="打包工具集"></a>打包工具集</h4><ul><li><p>提取包工具具有两个新参数：</p></li><li><ul><li>储存格式类型 - 指定提取的缓存的存储格式。压缩选项用于对包文件中的切片进行分组，以提高在网络共享和云存储目录上的性能。松散选项用于将每个切片存储为单独的文件。仅当提取矢量切片包 (.vtpk) 时，此参数才可用。</li><li>创建即用型缓存数据集 - 使用提取的缓存创建即用型文件夹结构，以在 ArcGIS Enterprise 中创建切片层。仅当提取切片包 (.tpkx) 或矢量切片包 (.vtpk) 时， 此参数才可用。</li></ul></li></ul><h4 id="栅格工具集-3"><a href="#栅格工具集-3" class="headerlink" title="栅格工具集"></a>栅格工具集</h4><p>正射映射工具集包含以下新工具：</p><ul><li>导出帧和照相机参数 - 从镶嵌数据集中导出帧和照相机参数。</li></ul><p>栅格数据集工具集包含以下工具增强功能：</p><ul><li>创建随机栅格 - 此新参数用于指定当输出栅格值为整数时是否创建栅格属性表。</li></ul><h3 id="Defense-工具箱-1"><a href="#Defense-工具箱-1" class="headerlink" title="Defense 工具箱"></a>Defense 工具箱</h3><h4 id="距离和方向工具集-1"><a href="#距离和方向工具集-1" class="headerlink" title="距离和方向工具集"></a>距离和方向工具集</h4><ul><li>基于要素创建扇形视域 - 此新工具使用派生自点要素类或 shapefile 中的字段的属性来创建扇形视域。</li><li>基于要素创建环形视域 - 此新工具使用派生自点要素类或 shapefile 中的字段的属性来创建环形视域。</li></ul><h3 id="GeoAnalytics-Desktop-工具箱-1"><a href="#GeoAnalytics-Desktop-工具箱-1" class="headerlink" title="GeoAnalytics Desktop 工具箱"></a>GeoAnalytics Desktop 工具箱</h3><ul><li>以下工具中添加了新的 Arcade 表达式，用于计算轨迹上的速度、加速度和距离：重新构建轨迹（汇总数据）、计算字段（管理数据）和检测事件（查找位置）。</li></ul><h4 id="数据丰富工具集-2"><a href="#数据丰富工具集-2" class="headerlink" title="数据丰富工具集"></a>数据丰富工具集</h4><ul><li>计算动态统计数据 - 此新工具通过速度、加速度和方位角等统计数据丰富启用时间的点数据。</li></ul><h4 id="汇总数据工具集-3"><a href="#汇总数据工具集-3" class="headerlink" title="汇总数据工具集"></a>汇总数据工具集</h4><ul><li>汇总中心和离差 - 此新工具用于查找中心要素和方向分布并根据点数据计算平均和中位数位置。</li><li>重新构建轨迹 - 已添加了用于设置如何表示拆分轨迹的选项，包括使用 Arcade 表达式的选项。可使用拆分类型参数确定如何绘制和汇总轨迹。</li><li>连接要素 - 已添加一个选项，用于保留所有目标要素（称为左外连接）。</li></ul><h4 id="邻近分析工具集-3"><a href="#邻近分析工具集-3" class="headerlink" title="邻近分析工具集"></a>邻近分析工具集</h4><ul><li>追踪邻域事件 - 此新工具用于分析表示在空间和时间上移动的实体并且启用时间的点要素，以确定与其他实体的交互。</li></ul><h3 id="GeoAnalytics-Server-工具箱-1"><a href="#GeoAnalytics-Server-工具箱-1" class="headerlink" title="GeoAnalytics Server 工具箱"></a>GeoAnalytics Server 工具箱</h3><ul><li>以下工具中添加了新的 Arcade 表达式，用于计算轨迹上的速度、加速度和距离：重新构建轨迹（汇总数据）、计算字段（管理数据）和检测事件（查找位置）。</li></ul><h4 id="数据丰富工具集-3"><a href="#数据丰富工具集-3" class="headerlink" title="数据丰富工具集"></a>数据丰富工具集</h4><ul><li>计算动态统计数据 - 此新工具通过速度、加速度和方位角等统计数据丰富启用时间的点数据。</li></ul><h4 id="汇总数据工具集-4"><a href="#汇总数据工具集-4" class="headerlink" title="汇总数据工具集"></a>汇总数据工具集</h4><ul><li>汇总中心和离差 - 此新工具用于查找中心要素和方向分布并根据点数据计算平均和中位数位置。</li><li>重新构建轨迹 - 已添加了用于设置如何表示拆分轨迹的选项，包括使用 Arcade 表达式的选项。可使用拆分类型参数确定如何绘制和汇总轨迹。</li><li>连接要素 - 已添加一个选项，用于保留所有目标要素（称为左外连接）。</li></ul><h4 id="邻近分析工具集-4"><a href="#邻近分析工具集-4" class="headerlink" title="邻近分析工具集"></a>邻近分析工具集</h4><ul><li>追踪邻域事件 - 此新工具用于分析表示在空间和时间上移动的实体并且启用时间的点要素，以确定与其他实体的交互。</li></ul><h3 id="地理编码工具箱-1"><a href="#地理编码工具箱-1" class="headerlink" title="地理编码工具箱"></a>地理编码工具箱</h3><ul><li>创建要素定位器 - 已添加对连接数据的支持。</li><li>地理编码地址 - 已添加新的输出字段参数。</li><li>反向地理编码 - 当定位器参与复合定位器时，现在支持要素类型。如果参与的定位器支持多种要素类型，则此设置将限制在反向地理编码中返回的要素的类型。</li></ul><h4 id="传统工具集-1"><a href="#传统工具集-1" class="headerlink" title="传统工具集"></a>传统工具集</h4><ul><li>从 ArcGIS Pro 2.7 开始，已弃用创建地址定位器工具。</li></ul><h4 id="门户工具集-1"><a href="#门户工具集-1" class="headerlink" title="门户工具集"></a>门户工具集</h4><ul><li>地理编码文件 - 已添加新的输出字段参数。</li><li>对表中的位置进行地理编码 - 已添加新的输出字段参数。</li></ul><h3 id="Geostatistical-Analyst-工具箱-1"><a href="#Geostatistical-Analyst-工具箱-1" class="headerlink" title="Geostatistical Analyst 工具箱"></a>Geostatistical Analyst 工具箱</h3><h4 id="使用地统计图层工具集-1"><a href="#使用地统计图层工具集-1" class="headerlink" title="使用地统计图层工具集"></a>使用地统计图层工具集</h4><ul><li>3D GA 图层转 NetCDF - 此新输入研究区域面参数用于定义分析的研究区域。可创建符合研究区域的体素图层，而不是创建完整 3D 范围的立方体。</li></ul><h3 id="Image-Analyst-工具箱-1"><a href="#Image-Analyst-工具箱-1" class="headerlink" title="Image Analyst 工具箱"></a>Image Analyst 工具箱</h3><h4 id="变化检测工具集-1"><a href="#变化检测工具集-1" class="headerlink" title="变化检测工具集"></a>变化检测工具集</h4><p>新变化检测工具集包含以下工具，用于在两个栅格数据集之间执行变化检测。</p><ul><li>计算变化栅格 - 计算两个栅格数据集之间的绝对、相对或分类差异。</li></ul><h4 id="深度学习工具集-2"><a href="#深度学习工具集-2" class="headerlink" title="深度学习工具集"></a>深度学习工具集</h4><ul><li><p>计算对象检测的精度 - 此新工具用于计算使用深度学习检测对象工具的输出的精度。</p></li><li><p>导出训练数据进行深度学习 - 元数据格式参数中添加了两个新选项：</p></li><li><ul><li>MultiLabeled_Tiles</li><li>Export_Tiles</li></ul></li><li><p>训练深度学习模型 - 具有以下增强功能：</p></li><li><ul><li>现在支持更快的 R-CNN、YOLO 和 DeepLab 模型类型。</li><li>骨干模型参数支持新选项 DarkNet-53。</li><li>预训练模型参数现在接受深度学习包文件 (.dlpk) 作为输入。</li></ul></li><li><p>使用深度学习分类像素 - 现在支持生成分类栅格集合。</p></li></ul><h4 id="多维分析工具集-1"><a href="#多维分析工具集-1" class="headerlink" title="多维分析工具集"></a>多维分析工具集</h4><ul><li>使用 LandTrendr 工具分析变化 - 此新工具使用基于 Landsat 的干扰和恢复趋势检测 (LandTrendr) 方法评估像素值随时间的变化。</li><li>汇总分类栅格 - 此新工具用于生成一个表，其中包含多维分类栅格中每个剖切片的每个类别的像素计数和面积。</li><li>使用变化分析栅格检测变化 - 现在支持从使用 LandTrendr 分析变化工具的输出中提取变化信息。</li><li>生成趋势栅格 - 现在支持使用 Mann-Kendall 和 Seasonal-Kendall 趋势类型选项来检测趋势。</li></ul><h4 id="统计工具集-1"><a href="#统计工具集-1" class="headerlink" title="统计工具集"></a>统计工具集</h4><ul><li>分区统计和以表格显示分区统计 - 现在支持适用于浮点值栅格的中位数和百分位数统计数据类型。新参数百分位数插值类型用于定义输入栅格中要计算的值数量为偶数时使用的百分位数插值方法。这些工具现在还支持对具有不同维度的输入进行多维处理。</li></ul><h3 id="Indoors-工具箱-1"><a href="#Indoors-工具箱-1" class="headerlink" title="Indoors 工具箱"></a>Indoors 工具箱</h3><ul><li><p>将 BIM 导入室内数据集 - 此新工具用于将现有 BIM 楼层平面图从 Revit 文件导入室内数据集，无需先将其导出到 CAD 或文件地理数据库。</p></li><li><p>生成单元开口 - 此新工具用于将单元开口创建为对入口的位置和物理范围进行建模的线要素，以准备导出到 IMDF。</p></li><li><p>将楼层平面图导入 Indoors 地理数据库 - 具有以下增强功能：</p></li><li><ul><li>可以为每个楼层具有多个工程图的楼层平面图按设施点楼层导入多个 CAD 源文件。</li><li>新参数面积测量单位用于定义在导入楼层平面图时用于计算面积的测量单位。</li><li>将根据要素的相对高程计算楼层、单元、地区和区域的 Z 值。</li><li>配置电子表格包含在 ArcGIS Pro 安装的 Resources\Indoors 文件夹中。需要此电子表格才能将 CAD 图层映射到相应的 Indoors 要素类。</li></ul></li><li><p>创建室内数据库 - 可使用新参数创建室内网络有选择地创建不含网络数据集的 Indoors 工作空间。</p></li></ul><h4 id="Indoors-网络工具集-1"><a href="#Indoors-网络工具集-1" class="headerlink" title="Indoors 网络工具集"></a>Indoors 网络工具集</h4><ul><li>稀疏化室内路径 - 除了点要素之外，现在还接受面要素作为可路由位置参数。</li></ul><h3 id="情报工具箱-1"><a href="#情报工具箱-1" class="headerlink" title="情报工具箱"></a>情报工具箱</h3><h4 id="移动工具集-1"><a href="#移动工具集-1" class="headerlink" title="移动工具集"></a>移动工具集</h4><ul><li>分类移动事件 - 此新工具使用点轨迹数据确定移动事件，例如加速、转弯、停靠点和 U 形转弯。该信息可用于取证分析，以了解事故发生前车辆的移动方式，或者由海事机构用于监视拥挤或海盗多发的海道中的船舶交通情况。请参阅“亮点”部分中的移动分析工具。</li></ul><h3 id="多维工具箱-1"><a href="#多维工具箱-1" class="headerlink" title="多维工具箱"></a>多维工具箱</h3><ul><li>合并多维栅格 - 此新工具用于在空间上或跨变量和维度合并多个多维栅格数据集。</li><li>构建多维转置 - 现在支持删除现有转置。</li><li>管理多维栅格 - 现在支持更新统计数据以及将转置更新到修改后的多维数据集。</li></ul><h3 id="网络逻辑示意图工具箱-1"><a href="#网络逻辑示意图工具箱-1" class="headerlink" title="网络逻辑示意图工具箱"></a>网络逻辑示意图工具箱</h3><h4 id="配置工具集-2"><a href="#配置工具集-2" class="headerlink" title="配置工具集"></a>配置工具集</h4><ul><li>创建逻辑示意图图层定义 - 可使用新选项覆盖所有图层通过添加新的逻辑示意图子图层或覆盖某些现有逻辑示意图子图层上的设置同时保留其他逻辑示意图子图层来优化逻辑示意图图层定义。</li><li>按属性添加逻辑示意图要素功能规则 - 支持两个新功能：阻止减少交汇点和允许减少交汇点。可通过这些功能标记逻辑示意图交汇点，以通过规则序列中稍后执行的“减少交汇点”规则确定是否将其放弃。</li></ul><h4 id="布局工具集-1"><a href="#布局工具集-1" class="headerlink" title="布局工具集"></a>布局工具集</h4><ul><li>应用旋转树布局 - 可使用新选项以相同角度旋转交汇点符号将角度参数值添加到每个已处理逻辑示意图交汇点的元素旋转字段值。这允许您使用该字段值通过旋转来更改示意图交汇点符号，以便属于一个或多个树的逻辑示意图交汇点的符号也按照相同的旋转角度进行旋转。</li></ul><h3 id="宗地工具箱-1"><a href="#宗地工具箱-1" class="headerlink" title="宗地工具箱"></a>宗地工具箱</h3><ul><li>生成宗地结构链接 - 此新工具用于为在指定时间段内更改位置的宗地结构点生成位移链接。该工具只能在发布为要素服务的宗地结构上使用。</li><li>合并共线宗地边界 - 此新工具用于将连接的共线宗地线合并为单个宗地线。</li></ul><h4 id="管理工具集-1"><a href="#管理工具集-1" class="headerlink" title="管理工具集"></a>管理工具集</h4><ul><li>创建宗地记录 - 此新参数允许您使用 ArcGIS Arcade 表达式定义记录名称。可以使用字段、字符串运算符和数学运算符的组合来定义记录名称。</li></ul><h3 id="Raster-Analysis-工具箱-1"><a href="#Raster-Analysis-工具箱-1" class="headerlink" title="Raster Analysis 工具箱"></a>Raster Analysis 工具箱</h3><p>注：</p><p>仅当您登录到具有已针对栅格分析配置的 ArcGIS Image Server 的 ArcGIS Enterprise 时，这些工具才可用。</p><h4 id="分析模式工具集-1"><a href="#分析模式工具集-1" class="headerlink" title="分析模式工具集"></a>分析模式工具集</h4><ul><li>计算密度 - 已添加新的输入障碍要素参数。在计算密度时，可以使用障碍来改变要素的影响。</li></ul><h4 id="深度学习工具集-3"><a href="#深度学习工具集-3" class="headerlink" title="深度学习工具集"></a>深度学习工具集</h4><ul><li>使用深度学习分类对象 - 此新工具用于在输入栅格和可选要素类上运行训练深度学习模型，以生成所有输入对象或要素均分配有类或类别标注的要素类或表。</li></ul><h4 id="汇总数据工具集-5"><a href="#汇总数据工具集-5" class="headerlink" title="汇总数据工具集"></a>汇总数据工具集</h4><ul><li>汇总范围内的栅格和以表格显示分区统计 - 现在支持适用于浮点值栅格的中位数和百分位数统计数据类型。新参数百分位数插值类型用于定义输入栅格中要计算的值数量为偶数时使用的百分位数插值方法。这些工具现在还支持对具有不同维度的输入进行多维处理。</li></ul><h4 id="邻近分析工具集-5"><a href="#邻近分析工具集-5" class="headerlink" title="邻近分析工具集"></a>邻近分析工具集</h4><ul><li>最佳路径为线 - 新参数创建网络路径用于指定是否计算从目的地到源的完整（可能重叠）路径，或者是否创建不重叠的网络路径。</li><li>距离累积、距离分配和最佳区域连接 - 已提高将距离方法参数设置为平面时的性能。</li></ul><h4 id="邻近分析（旧版本）工具集-1"><a href="#邻近分析（旧版本）工具集-1" class="headerlink" title="邻近分析（旧版本）工具集"></a>邻近分析（旧版本）工具集</h4><ul><li>计算距离 - 已提高将距离方法参数设置为平面时的性能。</li><li>计算行程成本、确定最佳行程成本网络和确定行程成本路径折线 - 已提高性能。</li></ul><h3 id="时空模式挖掘工具箱-1"><a href="#时空模式挖掘工具箱-1" class="headerlink" title="时空模式挖掘工具箱"></a>时空模式挖掘工具箱</h3><p>已添加以下增强功能：</p><h4 id="“时间序列预测”工具集-1"><a href="#“时间序列预测”工具集-1" class="headerlink" title="“时间序列预测”工具集"></a>“时间序列预测”工具集</h4><ul><li>曲线拟合预测、指数平滑预测和基于森林的预测 - 这三个新参数用于检测和识别时空立方体的每个位置处时间序列中的异常值。可以使用输出要素上的交互式弹出图表查看识别的异常值。</li></ul><h4 id="实用工具工具集-2"><a href="#实用工具工具集-2" class="headerlink" title="实用工具工具集"></a>实用工具工具集</h4><ul><li>在 2D 模式下显示时空立方体和在 3D 模式下显示时空立方体工具均包含一个新的显示主题，用于显示和探索时空立方体的时间序列异常值。</li></ul><h3 id="Spatial-Analyst-工具箱-1"><a href="#Spatial-Analyst-工具箱-1" class="headerlink" title="Spatial Analyst 工具箱"></a>Spatial Analyst 工具箱</h3><h4 id="密度分析工具集-1"><a href="#密度分析工具集-1" class="headerlink" title="密度分析工具集"></a>密度分析工具集</h4><ul><li>核密度 - 现在支持使用测地线方法计算障碍要素的密度。</li></ul><h4 id="距离分析工具集-1"><a href="#距离分析工具集-1" class="headerlink" title="距离分析工具集"></a>距离分析工具集</h4><ul><li>最佳路径为线 - 已添加新的创建网络路径参数。使用新参数时，结果可用于联网。</li><li>距离累积、距离分配和最佳区域连接 - 已提高将距离方法参数设置为平面时的性能。</li></ul><h4 id="栅格综合工具集-3"><a href="#栅格综合工具集-3" class="headerlink" title="栅格综合工具集"></a>栅格综合工具集</h4><ul><li>边界清理 - 现在支持并行处理，以提高处理大型数据集时的性能。</li></ul><h4 id="水文分析工具集-1"><a href="#水文分析工具集-1" class="headerlink" title="水文分析工具集"></a>水文分析工具集</h4><ul><li>存储容量 - 此工具可用于为输入表面栅格创建高程和对应的存储容量表和图表。</li></ul><h4 id="影像分割和分类工具集-1"><a href="#影像分割和分类工具集-1" class="headerlink" title="影像分割和分类工具集"></a>影像分割和分类工具集</h4><ul><li>导出训练数据进行深度学习工具的元数据格式参数具有两个新选项，即 MultiLabeled_Tiles 和 Export_Tiles。</li></ul><h4 id="表面分析工具集-1"><a href="#表面分析工具集-1" class="headerlink" title="表面分析工具集"></a>表面分析工具集</h4><ul><li>新工具表面参数通过拟合二次或四次表面来计算坡度、坡向和各种曲率。它支持用户指定的邻域距离和基于局部地表的自适应邻域。</li><li>3D Analyst 工具箱中的添加表面信息和插值 Shape 工具现在 Spatial Analyst 中可用。</li></ul><h4 id="区域分析工具集-1"><a href="#区域分析工具集-1" class="headerlink" title="区域分析工具集"></a>区域分析工具集</h4><ul><li>分区统计和以表格显示分区统计工具现在支持适用于浮点值栅格的中位数和百分位数统计数据类型。添加了新参数百分位数插值类型，用于定义输入栅格中要计算的值数量为偶数时使用的百分位数插值方法。这些工具现在还支持对具有不同维度的输入进行多维处理。</li></ul><h3 id="空间统计工具箱-1"><a href="#空间统计工具箱-1" class="headerlink" title="空间统计工具箱"></a>空间统计工具箱</h3><p>已添加以下新工具：</p><h4 id="聚类分布制图工具集-1"><a href="#聚类分布制图工具集-1" class="headerlink" title="聚类分布制图工具集"></a>聚类分布制图工具集</h4><ul><li>空间异常值检测 - 此新工具通过计算每个要素的局部异常值因子 (LOF) 来识别点要素中的空间异常值。LOF 是一种测量，用于描述某个位置与其局部相邻要素之间的隔离程度。</li></ul><h4 id="度量地理分布工具集-1"><a href="#度量地理分布工具集-1" class="headerlink" title="度量地理分布工具集"></a>度量地理分布工具集</h4><ul><li>邻域汇总统计数据 - 此新工具使用邻域计算点或面要素的一个或多个数值字段的局部汇总统计数据。局部统计数据包括平均值、中位数、标准差、四分位距、偏度和分位数不平衡。</li></ul><h4 id="“空间关系建模”工具集-1"><a href="#“空间关系建模”工具集-1" class="headerlink" title="“空间关系建模”工具集"></a>“空间关系建模”工具集</h4><ul><li>区域之间的空间关联 - 此新工具用于测量同一研究区域的两个区域化之间的空间关联程度，其中每个区域化由一组类别（称为区域）组成。例如，该工具可用于测量同一研究区域的森林类型与土壤类之间的关联。</li></ul><h4 id="实用工具工具集-3"><a href="#实用工具工具集-3" class="headerlink" title="实用工具工具集"></a>实用工具工具集</h4><ul><li>降维 - 此新工具使用主成分分析 (PCA) 或降级线性判别分析 (LDA) 将尽可能高的方差量聚合成更少的分量，来降低连续变量集的维数。</li></ul><h3 id="Territory-Design-工具箱-1"><a href="#Territory-Design-工具箱-1" class="headerlink" title="Territory Design 工具箱"></a>Territory Design 工具箱</h3><p>已增强以下工具：</p><h4 id="地区解决方案工具集-1"><a href="#地区解决方案工具集-1" class="headerlink" title="地区解决方案工具集"></a>地区解决方案工具集</h4><ul><li><p>创建地区解决方案 - 已提高求解大型数据集基于点的地区时的性能。</p></li><li><p>生成地区报表 - 提供了两个新报表：</p></li><li><ul><li>重新对齐 - 包含重新分配的要素的汇总重新对齐报表。</li><li>详细的重新对齐 - 包含重新分配的要素的完整列表。</li></ul></li></ul><h3 id="地形生产工具箱-1"><a href="#地形生产工具箱-1" class="headerlink" title="地形生产工具箱"></a>地形生产工具箱</h3><h4 id="制图工具集-1"><a href="#制图工具集-1" class="headerlink" title="制图工具集"></a>制图工具集</h4><p>要素工具集包含以下新工具：</p><ul><li>计算磁分量 - 计算磁分量。</li></ul><h3 id="Workflow-Manager-工具箱-1"><a href="#Workflow-Manager-工具箱-1" class="headerlink" title="Workflow Manager 工具箱"></a>Workflow Manager 工具箱</h3><h4 id="配置工具集-3"><a href="#配置工具集-3" class="headerlink" title="配置工具集"></a>配置工具集</h4><ul><li>发布工作流服务 - 此新工具用于为 ArcGIS Workflow Manager (Classic) 资料档案库上传和共享作业位置的工作流服务和地图服务。</li></ul><h2 id="数据管理和工作流-1"><a href="#数据管理和工作流-1" class="headerlink" title="数据管理和工作流"></a>数据管理和工作流</h2><h3 id="BIM-1"><a href="#BIM-1" class="headerlink" title="BIM"></a>BIM</h3><ul><li>Revit 建筑物的 ExteriorShell 要素类概览表示现在是单个复杂对象。这可提高性能并简化建筑图层概览的使用。</li><li>ArcGIS Pro 会在读取内存中的 Revit 文件之前将其升级到最新版本。可使用新选项保存文件的升级版本。这将显著减少打开文件所需的时间。</li></ul><h3 id="CAD-1"><a href="#CAD-1" class="headerlink" title="CAD"></a>CAD</h3><p>现在支持将 AutoCAD 和 MicroStation 文件中的以下 CAD 对象和 3D CAD 实体作为多面体要素：</p><ul><li><p>表面</p></li><li><ul><li>放样</li><li>规划器</li><li>拉伸</li><li>旋转</li><li>扫掠</li><li>NURBS</li></ul></li><li><p>面网格</p></li><li><p>主体</p></li><li><p>区域</p></li></ul><p>现在支持将以下 Autodesk Civil 3D 实体作为多面体要素：</p><ul><li><p>压力网络</p></li><li><ul><li>配件</li><li>附属物</li><li>压力管道</li></ul></li><li><p>重力网络</p></li><li><ul><li>结构</li><li>管线</li></ul></li></ul><p>已改进对 MTEXT 实体的多行格式化的支持。（CAD 文件通常使用 MTEXT 实体将多行文本显示为单个实体。）</p><h3 id="Data-Reviewer-1"><a href="#Data-Reviewer-1" class="headerlink" title="Data Reviewer"></a>Data Reviewer</h3><p>此更新包括用于自动验证的新方法以及错误检查器窗格中的过滤器增强功能。</p><h4 id="自动验证方法-1"><a href="#自动验证方法-1" class="headerlink" title="自动验证方法"></a>自动验证方法</h4><p>检查海报已更新，现以多种语言提供，以使用 Data Reviewer 中的自动校验帮助规划和实施质量控制工作流。</p><p>下图和下表介绍了可用于自动验证具有启用 Data Reviewer 的属性规则的数据的新方法：</p><table><thead><tr><th>编号</th><th>校验</th><th>说明</th></tr></thead><tbody><tr><td></td><td>属性域</td><td>查找不符合与属性字段关联的编码值或范围域的属性值。</td></tr><tr><td></td><td>重复要素</td><td>查找被组合且共享属性（可选）的几何类型相同的要素。</td></tr><tr><td></td><td>子类型</td><td>查找包含错误或空子类型值的要素或行。</td></tr><tr><td></td><td>表-表属性</td><td>查找包含某些属性值的要素或行，这些属性值满足与另一个要素类或独立表中的值的定义关系。</td></tr><tr><td></td><td>不必要的结点</td><td>查找共享结点并包含相同属性值的折线要素。</td></tr><tr><td></td><td>不必要的面边界</td><td>查找共享公共边界并包含相同属性值的面要素。</td></tr></tbody></table><h4 id="错误检查器-1"><a href="#错误检查器-1" class="headerlink" title="错误检查器"></a>错误检查器</h4><p>错误检查器窗格已增强，现可基于一种或多种选定过滤器类型（例如生命周期阶段、状态或严重性）进行过滤。</p><h3 id="地理编码-1"><a href="#地理编码-1" class="headerlink" title="地理编码"></a>地理编码</h3><p>定位器增强功能：</p><ul><li><p>以下定位器属性适用于基于线的定位器：</p></li><li><ul><li>单侧偏移 - 确定地理编码结果的位置距街道线段的距离。</li><li>末端偏移 - 防止位于线段末端的地址编码结果落在其他要素（例如，十字路街道）的顶部。</li><li>交叉路口连接器 - 分隔作为交叉路口地址一部分的两个街道名称所需的字符。可以将自己的交叉路口连接器添加到属性。</li></ul></li><li><p>可以使用以下新选项调整参与复合定位器的定位器的结果顺序：</p></li><li><ul><li>使用定位器顺序 - 参与定位器将按其添加到创建复合地址定位器工具的顺序进行使用。</li><li>按角色和分数排序 - 参与定位器将按角色和回退顺序进行分组。</li><li>自定义顺序 - 可以在多角色定位器的角色之间插入定位器。</li></ul></li><li><p>存储在 ArcGIS Online 和 ArcGIS Enterprise 门户中的定位器可以作为参与定位器添加到本地复合定位器中。</p></li><li><p>中块匹配用于搜索表示一个或多个城市街区的一组门牌号，例如加利福尼亚州雷德兰兹的纽约街 100 街区或旧金山泰勒街 200-500 街区。</p></li></ul><p>重新匹配增强功能：</p><ul><li>可使用除用于批量地理编码的定位器之外的定位器查看和重新匹配地理编码结果。</li><li>重新匹配时，可修改定位器的地理编码选项。</li></ul><p>定位窗格增强功能：</p><ul><li>可以将添加到地图的独立表配置为搜索表中的记录。</li><li>可基于图层中所有字段或单个字段包含的值在地图图层中搜索要素。</li></ul><p>有关地理处理工具的增强功能，请参阅地理编码工具箱。有关 ArcPy 增强功能，请参阅 Python。</p><h3 id="地理数据库和数据库-1"><a href="#地理数据库和数据库-1" class="headerlink" title="地理数据库和数据库"></a>地理数据库和数据库</h3><p>ArcGIS Pro 2.7 提供了以下更改和新功能：</p><h4 id="常规-7"><a href="#常规-7" class="headerlink" title="常规"></a>常规</h4><ul><li>有一种新型地理数据库，称为移动地理数据库。这是存储在 SQLite 数据库的地理数据库的实施并具有文件扩展名 .geodatabase。请参阅“亮点”部分中的移动地理数据库。</li></ul><ul><li><p>创建要素类和创建表向导包含将输出数据集添加到当前地图的选项。有关详细信息，请参阅创建要素类。</p></li><li><p>创建复本工具支持仅注册现有数据功能。</p></li><li><p>为响应客户请求，提供了以下可用性和可访问性增强功能：</p></li><li><ul><li>在表格的“字段”视图中，可使用空格键切换选定行的可见性。</li><li>在“版本”视图中，可在管理版本时选择多个版本。</li><li>视图的属性页面包含定义选项卡，其中显示用于创建视图的查询定义。</li><li>M 和 Z 范围将显示在要素类的属性页面上。</li><li>在创建要素类和创建表向导中，可编辑系统维护的 OBJECTID 和 Shape 字段的别名。</li><li>管理子类型对话框具有快捷菜单、键盘快捷键和更佳的键盘导航。</li><li>启用企业级地理数据库工具可以从目录窗格的数据库的关联菜单打开。</li><li>移除命令  适用于内容窗格中的多个选定图层。同时适用于按数据源列出选项卡  中具有相同数据源的图层。</li><li>可通过右键单击属性域行访问属性域用法窗格。该窗格仍可从功能区上的属性域用法按钮  进行访问。</li><li>属性域用法窗格中的查看用法命令  用于在“子类型”或“字段”视图打开时突出显示选定属性域。要了解详细信息，请参阅识别属性域用法。</li><li>已将新命令添加到“字段”、“子类型”和“属性域”视图的关联菜单，以减少鼠标遍历。</li></ul></li></ul><h4 id="属性规则-1"><a href="#属性规则-1" class="headerlink" title="属性规则"></a>属性规则</h4><ul><li>可在评估属性规则时在文件地理数据库中评估批处理计算和验证。</li><li>结果字典关键字功能已扩展为允许更新具有属性规则的要素的多个字段。</li><li>可使用编辑字典关键字通过将 className 定义为 ^UN_Association 编辑任何公共设施网络关联。</li></ul><h4 id="企业级地理数据库和数据库-1"><a href="#企业级地理数据库和数据库-1" class="headerlink" title="企业级地理数据库和数据库"></a>企业级地理数据库和数据库</h4><ul><li>检查几何和修复几何工具支持存储在企业级地理数据库中的要素类。</li><li>可在 SAP HANA 地理数据库中启用存档的数据集上运行修剪存档历史记录工具。</li><li>从 ArcGIS Pro 2.7 开始，无法升级 Oracle 中的用户方案地理数据库；但是，在此版本中，可继续连接并使用用户方案地理数据库。了解有关将用户方案地理数据库移至 Oracle 中的独立地理数据库。</li><li>支持 SQLite 3.32.1 和 3.32.3。</li><li>IBM Db2 Version 11.1 Mod 4 Fix Pack 5 是 ArcGIS Pro 2.7 支持的最低版本。</li><li>Microsoft SQL Server 2016 是 ArcGIS Pro 2.7 支持的最低版本。</li><li>可在 Oracle 云端的虚拟机中安装 ArcGIS Pro 2.7 以连接并使用 Autonomous Transaction Processing database in Oracle Cloud 和协同管理的系统虚拟机数据库系统中的数据。</li></ul><h3 id="Indoors-1"><a href="#Indoors-1" class="headerlink" title="Indoors"></a>Indoors</h3><p>已添加以下新函数：</p><ul><li><p>现在可以在活动地图中基于面和点图层创建类别。</p></li><li><p>可在新的配置 Indoors 启动操作窗格中查看应用程序启动操作。可在此窗格中使用新的创建 Indoors 启动操作向导创建应用程序启动操作。</p></li><li><p>现在可在配置 Indoors 类别窗格的图层视图中查看、管理和创建按地图图层组织的类别。在“图层”视图中对类别所做的更改将反映在“类别”和“浏览”视图中。</p></li><li><p>创建默认 Indoors 类别向导可指导您完成简化工作流以根据基于图层符号系统的地图图层自动创建类别。</p></li><li><p>以下文件现包含在 ArcGIS Pro 安装的 Resources\Indoors 文件夹中。</p></li><li><ul><li>配置电子表格 - 需要该电子表格才能将 CAD 图层映射到相应的 Indoors 要素类。</li><li>最终网络模板 - 此模板用于创建 Indoors 网络。</li></ul></li></ul><p>已弃用以下功能：</p><ul><li><p>不再需要 Indoors 配置表即可配置应用程序启动操作。现在可使用创建 Indoors 启动动作向导配置 Indoors 启动操作。</p></li><li><p>Indoors 移动应用不再要求在 Indoors 配置表中配置底图。可在共享之前直接将底图添加到地图中为移动地图包配置底图。</p></li><li><p>已通过移除以下要素类字段简化 ArcGIS Indoors 信息模型：</p><p>注：</p><p>移除这些字段不会影响 Indoors 工具或客户端应用程序的行为。</p></li><li><ul><li>地标：UID_、FACILITY_ID、FACILITY_NAME、LEVEL_NAME、LEVEL_NUMBER、NAME、NAME_LONG、NAME_SUBTITLE、SECTION_ID、SECTION_NAME、SITE_ID、SITE_NAME、SOURCE_METHOD、SOURCE_NAME、SOURCE_PATH、SOURCE_TYPE、UNIT_ID、UNIT_NAME、USE_TYPE</li><li>路径和初步路径：UID_、ACCESS_PEDESTRIAN、ACCESS_WHEELCHAIR、HEIGHT_FROM、HEIGHT_TO、LOCATION_TYPE</li><li>过渡和初步过渡：UID_、ACCESS_PEDESTRIAN、ACCESS_WHEELCHAIR、LOCATION_TYPE</li></ul></li></ul><h3 id="Workflow-Manager-1"><a href="#Workflow-Manager-1" class="headerlink" title="Workflow Manager"></a>Workflow Manager</h3><p>ArcGIS Workflow Manager 是 ArcGIS Pro 的新扩展模块，用于您在服务驱动的 ArcGIS Workflow Manager Server 实施中创建和使用作业。</p><h3 id="Workflow-Manager-Classic-1"><a href="#Workflow-Manager-Classic-1" class="headerlink" title="Workflow Manager (Classic)"></a>Workflow Manager (Classic)</h3><ul><li>ArcGIS Workflow Manager (Classic) Administrator for ArcGIS Pro 提供了用于配置 Workflow Manager (Classic) 资料档案库的工具和组件，并且可以从 My Esri 单独下载。</li><li>已向工作流视图添加刷新作业列表按钮 ，用于刷新作业列表中的作业查询结果。</li></ul><h2 id="编辑-1"><a href="#编辑-1" class="headerlink" title="编辑"></a>编辑</h2><h3 id="常规-8"><a href="#常规-8" class="headerlink" title="常规"></a>常规</h3><ul><li>在创建要素窗格中，要素模板可基于连接的 GNSS 设备提供的位置创建要素。</li><li>正多边形 工具用于在指定的中心点和指定的径向外接距离处创建等边多边形。边数将作为构造工具的属性进行指定。</li><li>对齐和分布工具用于对齐要素的边或中心，或对其进行平均分布。可相对于彼此或指定的参考位置对它们进行对齐和分布。</li><li>草绘几何时，可打开推断约束  并使用推断的几何约束。</li><li>可创建和编辑 3D 对象要素。3D 对象要素类在地理数据库中存储和管理要素，使用已定义的地理位置且引用 3D 几何网格。要素引用的几何可以多种格式存储，并支持许多集成来自其他应用程序的 3D 模型文件的工作流。</li><li>可使用构造大地测量要素  工具创建符合大地测量学准则的要素作为增密线、弧和椭圆。</li><li>如果在草绘几何时切换要素构造工具或编辑工具，系统会提示您应用或放弃未完成的草绘。</li><li>在模板属性中，可为预设模板移除组件要素模板。</li><li>在属性窗格中，可通过在选择树视图中选择现有记录创建表模板。</li><li>在模板组中，可选择设置每个折点处的点（折线）构建器  以创建与偏移线要素或构造对象（主要线要素除外）重合的偏移点要素。</li><li>现在可使用线性参考编辑工具基于所选线要素创建路径、校准所选路径以及定义一部分路径。</li><li>在绘制线或面要素时，可添加具有相同的 x、y、z 和 m 值的折点作为右键单击折点。</li><li>当反转折线要素的方向时，则将根据反向方位角（如果存在）重新计算 COGO方向属性值。</li><li>可设置对齐 和简单对齐 尺寸注记工具以在每次连续点击后创建连续尺寸注记。</li><li>系统会在编辑工具主动过滤选择内容时发送弹出通知提醒您。</li><li>移动拓扑边时，工具窗格将包含缩放到边工具 。</li><li>修整工具  包含一个可选设置，用于选择要保留的要素。</li><li>数组工具  用于创建在矩形数组中分布的选定要素的多个副本。</li><li>导线工具  支持创建面。输入导线时，请在修改要素窗格中选择面要素图层。</li><li>导线工具  支持适用于曲线的增强数据输入选项。</li></ul><h3 id="宗地结构-1"><a href="#宗地结构-1" class="headerlink" title="宗地结构"></a>宗地结构</h3><ul><li>功能区的宗地选项卡下的质量选项卡在工具库中包含使用于质量驱动工作流的工具。其中包括新的合并边界 和合并点 工具。</li><li>使用合并点工具  可将两个或多个选定宗地结构点合并为单个点。</li><li>创建或升级宗地结构时，将在宗地结构要素类上创建了两个属性规则用于数据质量管理。</li><li>可使用预定义可选属性规则集进行宗地结构数据质量管理。可以为您的组织导入和配置这些可选规则。</li><li>对齐宗地工具  支持对齐曲线、重叠宗地以及交互删除链接和锚点。</li></ul><h2 id="影像和栅格数据-1"><a href="#影像和栅格数据-1" class="headerlink" title="影像和栅格数据"></a>影像和栅格数据</h2><ul><li>处理模板现在适用于所有栅格数据集，因此可存储处理模板以基于栅格数据动态生成信息图层。</li></ul><h3 id="栅格函数-5"><a href="#栅格函数-5" class="headerlink" title="栅格函数"></a>栅格函数</h3><ul><li>栅格函数套件的参考帮助从影像和栅格部分移动到了分析和地理处理部分。</li></ul><h3 id="多维栅格-1"><a href="#多维栅格-1" class="headerlink" title="多维栅格"></a>多维栅格</h3><ul><li>对于采用云栅格格式的多维栅格 (.crf)，可在栅格属性窗口中设置处理和显示的默认变量。</li></ul><p>有关新的和增强的地理处理工具，请参阅多维工具箱。</p><h3 id="正射映射-1"><a href="#正射映射-1" class="headerlink" title="正射映射"></a>正射映射</h3><ul><li>导出帧和照相机参数 - 此新工具用于从镶嵌数据集中导出帧和照相机参数。</li></ul><h2 id="制图和可视化-1"><a href="#制图和可视化-1" class="headerlink" title="制图和可视化"></a>制图和可视化</h2><h3 id="常规-9"><a href="#常规-9" class="headerlink" title="常规"></a>常规</h3><ul><li>访问调色板时，可使用取色器工具  从活动视图中选取一种颜色，然后将其应用于当前项目。</li></ul><ul><li><p>地图和场景的内容窗格的快捷菜单包含新的命令，用于打开和关闭选定图层。</p></li><li><p>现在，可过滤地图或场景以仅显示空要素图层。在内容窗格中，单击过滤器按钮 ，然后单击空要素图层。</p></li></ul><h3 id="3D-对象要素图层-3"><a href="#3D-对象要素图层-3" class="headerlink" title="3D 对象要素图层"></a>3D 对象要素图层</h3><ul><li>3D 对象要素图层是 ArcGIS Pro 中的新数据类型。请参阅“亮点”部分中的 3D 对象要素图层。</li></ul><h3 id="3D-场景和场景图层-1"><a href="#3D-场景和场景图层-1" class="headerlink" title="3D 场景和场景图层"></a>3D 场景和场景图层</h3><ul><li>现在可以使用投影工具将场景图层包投影到任何坐标系。</li><li>点场景图层在 I3S 1.7 版本中使用创建点场景图层包工具进行创建。</li><li>可以将自定义坐标系中的局部场景共享到 ArcGIS Enterprise10.9 或 ArcGIS Online。</li><li>可使用新图层属性使用预定义细节层次选择在任何场景图层类型的 I3S LoD 选择或 ArcGIS Pro LoD 选择之间进行切换。</li></ul><h3 id="动画-1"><a href="#动画-1" class="headerlink" title="动画"></a>动画</h3><ul><li>动画属性窗格现在支持动画演示体素图层的属性，包括数据过滤、可见性和位置。</li></ul><h3 id="注记和标注-1"><a href="#注记和标注-1" class="headerlink" title="注记和标注"></a>注记和标注</h3><ul><li><p>等值线放置标注样式具有以下改进：</p></li><li><ul><li>等值线放置样式现在具有朝下标注对齐选项，可用于等深线制图。</li><li>非阶梯式等值线标注现放置在更宽、更平坦的等值线延长线上，并且放置在拐角或折弯处的可能性较低。</li><li>现在，阶梯中的最低等值线标注将放置在其先前放置的位置，即使其他等值线标注未过于靠近也是如此。</li><li>速度加快且标注的等值线数量增加。</li><li>等值线标注的直观朝上对齐。</li></ul></li><li><p>除了用作自适应策略之外，键编号现在还可用作放置策略，其中所有要素使用键进行标注。</p></li><li><p>设置注释的锚点位置时，现在可在使用面轮廓上最接近的点选项时在面内部插入锚点。这在标注面之间的边界时非常有用。</p></li><li><p>现在，ArcGIS Pro 文本符号和基于字体的形状标记支持可变字体。除了预设样式之外，还可以通过可变字体自定义字体变化，例如宽度、粗细、倾斜度等。</p></li></ul><ul><li><p>现在，Arcade 控制台函数在编写和调试标注表达式时受持。</p></li><li><p>将 Arcade 表达式用于标注表达式、标注旋转和备用表达式时，现在可以向表达式添加标题。</p></li></ul><p>有关地理处理工具的增强功能，请参阅“制图”工具箱。</p><h3 id="Arcade-1"><a href="#Arcade-1" class="headerlink" title="Arcade"></a>Arcade</h3><ul><li>ArcGIS Pro 支持 Arcade 1.12 版本。有关新功能的汇总，请参阅适用于高于 1.11 版本的版本的发行说明。</li></ul><h3 id="坐标系和变换-1"><a href="#坐标系和变换-1" class="headerlink" title="坐标系和变换"></a>坐标系和变换</h3><ul><li>现在可以基于地图的预期范围和内容生成建议的投影坐标系。指定要保留的投影属性（等距、等角、与点等距、沿子午线或折衷），以为指定范围创建自定义投影坐标系。</li><li>已改进从一个地理坐标系投影到另一个地理坐标系时指定变换的体验。</li></ul><h3 id="探索性分析工具-1"><a href="#探索性分析工具-1" class="headerlink" title="探索性分析工具"></a>探索性分析工具</h3><ul><li>使用新的高程剖面图工具在地图或场景中生成线性路径沿线的地面高程高度图。可通过单击视图手动定义线，也可以使用选定的线性要素。</li><li>运行新对象检测工具以在场景中显示的影像中查找感兴趣的实际对象。该工具需要在运行之前安装深度学习库以及 ArcGIS Pro Advanced 许可级别。</li></ul><h3 id="导出地图和布局-1"><a href="#导出地图和布局-1" class="headerlink" title="导出地图和布局"></a>导出地图和布局</h3><ul><li>GeoTIFF 导出现在适用于布局。以前，此功能仅在导出地图时可用。对于包含多个地图框的布局，可选择用于写入 GeoTIFF 标签的地图框。</li></ul><h3 id="要素图格-1"><a href="#要素图格-1" class="headerlink" title="要素图格"></a>要素图格</h3><ul><li>将启用要素图格的图层发布为 ArcGIS Enterprise 10.9 中的地图服务时，现在可以将其作为要素图层在 ArcGIS Pro 中使用。在此要素图层中，可通过更改符号系统和其他图格属性来更改图格的外观。在早期版本中，只能将该图层作为地图图像图层在ArcGIS Pro 中进行使用。无法在此地图图像图层中更改图格的符号系统或其他外观属性。</li></ul><h3 id="信息图表-1"><a href="#信息图表-1" class="headerlink" title="信息图表"></a>信息图表</h3><ul><li>比较信息图表可用于对任何信息图表模板中的多个要素执行并排比较。</li></ul><h3 id="布局-1"><a href="#布局-1" class="headerlink" title="布局"></a>布局</h3><ul><li>可通过新的图例自适应策略手动列设置图例中的列数并在特定列中放置每个图例项目。</li><li>用于将格网转换为要素的新选项可针对高级编辑或放置情况基于格网组件创建要素。将格网转换为要素时，格网的组件将生成为要素类，这些要素类将作为图层添加到地图中。符号将应用于图层以与格网格组件相匹配。</li></ul><h3 id="导航-1"><a href="#导航-1" class="headerlink" title="导航"></a>导航</h3><ul><li><p>书签包括以下改进：</p></li><li><ul><li>在书签库中，可使用新的关联菜单命令移除或更新书签。</li><li>在缩放至书签时用于在视图中显示该书签名称的新选项。</li><li>为了支持缩放到书签的任何子组件属性，已将新命令添加到书签窗格中书签的关联菜单。例如，仅照相机位置、仅时间值或仅范围值。</li><li>书签窗格现在支持文件夹结构以改进组织方式。</li></ul></li><li><p>在 2D 地图中，转到 XY 现在支持放置点、标注点和标注注释图形以在视图中标记位置。</p></li><li><p>地图导航现在可以通过提供仅在缩放时显示这些比例选项捕捉到比例。</p></li><li><p>全球或局部场景中提供了三个新的体积选择命令：按框选择 、按球体选择 和按圆柱选择 。</p></li><li><p>两个可选导航工具矩形放大 和矩形缩小 可通过自定义功能区或快速访问工具条进行添加。</p></li></ul><h3 id="弹出窗口-1"><a href="#弹出窗口-1" class="headerlink" title="弹出窗口"></a>弹出窗口</h3><ul><li>弹出窗口具有新的默认外观。这些改进包括字段元素中的替换行颜色、图像和图表元素的说明文字位置、饼图剖切片标注以及匹配的深色主题。选项对话框的导航选项卡上有一个选项可用于查看经典弹出窗口外观。</li><li>在配置弹出窗口时与元素进行交互并对其重新排列的常规改进。</li><li>已将新按钮添加到配置弹出窗口窗格，用于将元素顺时针旋转 90 度，从而提高将垂直堆叠的元素并排显示的能力。</li><li>图像元素现在支持 360 度全景图像。可以在常规或 360 度图像查看器中打开图像。</li><li>现在，可以在配置弹出窗口时嵌入图像元素的独立数据 URL 以及文本元素的 HTML。</li><li>新打印按钮可提高打印在弹出窗口中列出的属性信息图像的能力。</li></ul><h3 id="报告-1"><a href="#报告-1" class="headerlink" title="报告"></a>报告</h3><ul><li>现在可以将布局添加为报告之前和之后的补充页面。导出为 PDF 时，补充页面将包含在结果文件中。</li><li>新的报表文档视图可用于对报表部分进行重新排序以及添加或移除补充页面。</li></ul><h3 id="样式-1"><a href="#样式-1" class="headerlink" title="样式"></a>样式</h3><ul><li><p>已将新符号添加到 ArcGIS 2D 系统样式，如下所示：</p><p>许多上述新符号可显示不同的符号效果和标记放置。与所有系统样式符号一样，可随时将其复制到“收藏夹”样式并根据需要进行修改。</p></li><li><ul><li>81 个新的点符号，包括基本几何形状和各种箭头。下面是此集合的示例。</li></ul></li></ul><ul><li>57 个新的线符号，包括更多虚线变体和带箭头的线。下面是此集合的示例。</li></ul><ul><li>24 个新的面符号。下面是此集合的示例。</li></ul><ul><li>已添加八个新的系统样式，包含 PANTONE® 颜色；下表概述了这样样式。Pantone 颜色是专色的一种特殊情况。它们是 Pantone 开发的专利标准色彩再现系统的一部分，用于确保色彩的一致性，无论用于显示或输出的介质为何。</li></ul><table><thead><tr><th>Pantone 色册和 ArcGIS Pro 样式名称</th><th>色册说明</th></tr></thead><tbody><tr><td>PANTONE® Formula Guide Solid Coated</td><td>铜版纸上的专色油墨</td></tr><tr><td>PANTONE® Formula Guide Solid Uncoated</td><td>未涂布纸上的专色油墨</td></tr><tr><td>PANTONE® Pastels &amp; Neons Coated</td><td>铜版纸上的纯色粉彩和霓虹油墨</td></tr><tr><td>PANTONE® Pastels &amp; Neons Uncoated</td><td>未涂布纸上的纯色粉彩和霓虹油墨</td></tr><tr><td>PANTONE® Metallics Coated Guide</td><td>铜版纸上的金属效果油墨</td></tr><tr><td>PANTONE® Extended Gamut Guide Coated</td><td>涂布纸上的 CMYK + OGV 四色油墨</td></tr><tr><td>PANTONE® Color Bridge Coated</td><td>铜版纸上的专色和四色油墨</td></tr><tr><td>PANTONE® Color Bridge Uncoated</td><td>未涂布纸上的专色和四色油墨</td></tr></tbody></table><ul><li>Intelligence 系统样式中共有 60 个新符号，每个符号具有 3 种大小。</li></ul><h3 id="符号系统-1"><a href="#符号系统-1" class="headerlink" title="符号系统"></a>符号系统</h3><ul><li>现在，可以在选择多个点符号时访问简单点符号周围轮廓的颜色和宽度。</li></ul><ul><li>选择多个符号后，符号预览将指示当前集中的符号数量。</li></ul><ul><li>新圆扇形 符号效果使用距该点的指定半径创建动态面。起始角和终止角用于定义扇形的宽度。</li></ul><ul><li>新面周围 标记放置用于将面周围的单个标记放置在 位置属性指定的位置处。</li></ul><ul><li><p>以下标记放置具有一个新按部件放置属性，用于控制如何在多部件要素上放置标记：</p></li><li><ul><li>沿线(大小可变)</li><li>面周围</li><li>居中</li><li>在端点处</li><li>采用测量单位</li><li>位于比例位置</li><li>在线上</li><li>在折点上</li></ul></li><li><p>现在可通过设置属性改变图片标记符号图层中使用的图像。</p></li></ul><h3 id="时间-1"><a href="#时间-1" class="headerlink" title="时间"></a>时间</h3><ul><li>Web 要素图层中日期字段的时区信息将显示在日历控件中以及属性表字段标题的工具提示中。从 ArcGIS Enterprise 10.9 版开始，可使用首选时区或未知时区配置地图和要素服务。将支持这些设置。</li></ul><h3 id="矢量切片-1"><a href="#矢量切片-1" class="headerlink" title="矢量切片"></a>矢量切片</h3><ul><li><p>矢量切片创建现在支持以下设置：有关详细信息，请参阅矢量切片中的符号系统和在矢量切片中进行标注。</p></li><li><ul><li>设置为随地图旋转进行旋转的点符号以及点和面标注。</li><li>文本符号中的可变字体。</li><li>其他源内容（例如 attribution、bounds、minzoom、maxzoom 和 scheme）将写入矢量切片样式，以供使用这些属性的非 Esri 客户端使用。</li><li>使用从路径添加数据命令时，通过包含不符合 Esri URL 模式的 URL 的样式渲染矢量切片。</li></ul></li></ul><h2 id="生产-1"><a href="#生产-1" class="headerlink" title="生产"></a>生产</h2><h3 id="Airports-1"><a href="#Airports-1" class="headerlink" title="Airports"></a>Airports</h3><p>Airports 扩展模块中新增了以下功能和增强功能：</p><ul><li>已向包含有关 GeoNet 的实用操作演示视频的文档添加链接。</li><li>为了清楚起见，已编辑用于创建机场指示牌的工作流。</li><li>已向“地形和障碍物剖面”元素工具添加一个按钮，用于在对其属性进行更改后刷新剖面图元素。</li></ul><h3 id="Aviation-Charting-1"><a href="#Aviation-Charting-1" class="headerlink" title="Aviation Charting"></a>Aviation Charting</h3><p>ArcGIS Aviation Charting 扩展模块中新增了以下功能和增强功能：</p><ul><li>AIXM 4.5 中未使用的要素已从 AIS 地理数据库方案中移除。从 My Esri 下载更新的 Charting 产品数据文件。</li><li>航空首选项工具用于设置首选项，以决定 Aviation Charting 地理处理工具如何创建航线、处理路径以及在 ArcGIS Pro 中执行变化检测。</li><li>图表变更工具用于识别、验证、分组和过滤两个企业级地理数据库版本之间不同的要素类和表。可使用 图表变更工具查看 报告航空图变更地理处理工具生成的报表。</li></ul><h3 id="Defense-Mapping-1"><a href="#Defense-Mapping-1" class="headerlink" title="Defense Mapping"></a>Defense Mapping</h3><ul><li>已增强 MGCP 地形图 (MTM) 和地形图 (TM) 样式。</li></ul><h4 id="产品文件-1"><a href="#产品文件-1" class="headerlink" title="产品文件"></a>产品文件</h4><ul><li>已添加运行模型以将数据概化到指定比例的自动概化工作流。</li><li>已添加用于替换数据和边匹配数据的自动化工作流。它将替换现有数据，并将替换后的数据与权威数据存储中的现有数据进行边匹配。</li><li>已增强用于创建复本和发布的工作流，现在可以自动运行。</li><li>现在已改进 ArcGIS Workflow Manager (Classic) 中的扩展属性的组织、排序和一致行为。</li><li>已将验证规则添加到概化规则文件中，以支持特定字段的下拉选项和验证。</li><li>添加了用于验证规则文件并报告需要注意的错误和不一致的地理处理工具。</li><li>已提高概化模型的性能，以消除先前发行版中某些数据集的特定瓶颈问题。</li><li>向模型添加了新工具，用于支持概化工作流。这些工具包括用于替换现有数据和对替换数据进行边匹配的工具。</li><li>已增强针对农村和城市密度的交通主题。</li><li>已对“结构”主题进行增强，以改进建成区面生成。</li><li>已对“地球皮肤”主题进行增强，以提高“填充间隙”逻辑的性能和灵活性。</li></ul><h3 id="Maritime-1"><a href="#Maritime-1" class="headerlink" title="Maritime"></a>Maritime</h3><ul><li>引入 S-57 关系管理器后，您现在可以检查和管理等级（结构-设备）和点对点（集合）关系。</li><li>S-57 编辑组可用于设置编译范围，以在编译新数据源时自动赋予要素比例属性。</li><li>S-57 固定比例范围可用于按比例范围和产品类型在数据上设置过滤器。这有助于可视化中央数据库中哪些数据将出现在不同规模的产品中。</li><li>可在属性窗格中查看和编辑按逻辑分组的要素属性。</li></ul><h3 id="Pipeline-Referencing-1"><a href="#Pipeline-Referencing-1" class="headerlink" title="Pipeline Referencing"></a>Pipeline Referencing</h3><p>ArcGIS Pipeline Referencing 包含对软件和文档的以下增强功能：</p><ul><li><p>新增了对垂直路径几何的支持。</p><p>了解有关 Pipeline Referencing 中的垂直路径的详细信息</p></li><li><ul><li>可以在 ArcGIS Pro 中使用局部场景在 3D 模式下可视化和编辑具有垂直段的中心线、路径和事件。</li><li>具有垂直段的中心线可用于创建和编辑 LRS 网络中的现有路径。事件也可以位于这些垂直路段上，以用于分析和报告 LRS 数据。</li><li>垂直路径或具有垂直段的路径可以使用追加路径工具加载到 LRS 中。</li></ul></li><li><p>当 LRS 数据采用地理坐标系并且 x,y 空间参考单位不同于 z 测量单位时，额外添加了对 3D LRS 计算的支持。这些计算如下：</p><p>了解有关 Pipeline Referencing 中 3D 支持的详细信息</p></li><li><ul><li>LRS 编辑工具中提供的建议措施，例如创建路径、重新对齐路径和添加校准点</li><li>测量插值，用于在 LRS 网络中的路径和 LRS 事件中的事件的每个折点上填充 m 值</li></ul></li><li><p>新增了对复杂路径形状的支持：</p><p>了解有关 Pipeline Referencing 中的复杂形状的详细信息</p></li><li><ul><li>循环</li><li>棒棒糖</li><li>Alpha</li><li>分支</li><li>杠铃</li><li>在整个 Pipeline Referencing 中都支持形成复杂形状的路径，例如自闭合和自相交几何。</li><li>支持的复杂几何如下：</li></ul></li><li><p>新增了对将多部分中心线分割为单部分要素的支持：</p></li><li><ul><li>将中心线分割为单部分要素工具可用于将多部分中心线分解成单部分要素，从而可以更轻松地编辑和校准具有复杂形状的路径。</li></ul></li></ul><h3 id="Production-Mapping-1"><a href="#Production-Mapping-1" class="headerlink" title="Production Mapping"></a>Production Mapping</h3><p>Production Mapping 扩展模块中新增了以下功能和增强功能：</p><ul><li>已添加运行模型以将数据概化到指定比例的自动概化工作流。</li><li>已添加用于替换数据和边匹配数据的自动化工作流。它将替换现有数据，并将替换后的数据与权威数据存储中的现有数据进行边匹配。</li><li>已增强用于创建复本和发布的工作流，现在可以自动运行。</li><li>现在已改进 ArcGIS Workflow Manager (Classic) 中的扩展属性的组织、排序和一致行为。</li><li>已将验证规则添加到概化规则文件中，以支持特定字段的下拉选项和验证。</li><li>添加了用于验证规则文件并报告需要注意的错误和不一致的地理处理工具。</li><li>概化模型中新增了性能增强功能，以消除先前发行版中某些数据集的特定瓶颈问题。</li><li>向模型添加了新工具，用于支持概化工作流。这些工具包括用于替换现有数据和对替换数据进行边匹配的工具。</li><li>已增强针对农村和城市密度的交通主题。</li><li>已对“结构”主题进行增强，以改进建成区面生成。</li><li>已对“地球皮肤”主题进行增强，以提高“填充间隙”逻辑的性能和灵活性。</li></ul><h3 id="Roads-and-Highways-1"><a href="#Roads-and-Highways-1" class="headerlink" title="Roads and Highways"></a>Roads and Highways</h3><p>ArcGIS Roads and Highways 包含对软件和文档的以下增强功能：</p><ul><li><p>新增了对复杂路径形状的支持：</p><p>了解有关 Roads and Highways 中的复杂形状的详细信息</p></li><li><ul><li>循环</li><li>棒棒糖（死巷）</li><li>Alpha（坡道）</li><li>分支</li><li>杠铃</li><li>在整个 Roads and Highways 中都支持形成复杂形状的路径，例如自闭合和自相交几何。</li><li>支持的复杂几何如下：</li></ul></li><li><p>当 LRS 数据采用地理坐标系并且 x,y 空间参考单位不同于 z 测量单位时，额外添加了对 3D LRS 计算的支持。这些计算如下：</p><p>了解有关 Roads and Highways 中 3D 支持的详细信息</p></li><li><ul><li>LRS 编辑工具中提供的建议措施，例如创建路径、重新对齐路径和添加校准点</li><li>测量插值，用于在 LRS 网络中的路径和 LRS 事件中的事件的每个折点上填充 m 值。</li></ul></li><li><p>新增了对将多部分中心线分割为单部分要素的支持：</p></li><li><ul><li>将中心线分割为单部分要素工具可用于将多部分中心线分解成单部分要素，从而可以更轻松地编辑和校准具有复杂形状的路径。</li></ul></li></ul><h2 id="工程-1"><a href="#工程-1" class="headerlink" title="工程"></a>工程</h2><h3 id="常规-10"><a href="#常规-10" class="headerlink" title="常规"></a>常规</h3><ul><li>ArcGIS Pro 开始页面具有指向学习资源的直接链接。请参阅“亮点”部分中开始页面资源。</li><li>您可以将 GNSS (GPS) 设备连接到 ArcGIS Pro。请参阅“亮点”部分中的 GNSS 设备位置支持。</li></ul><ul><li>更新工程中的数据源时，现在可选择按原样应用更改，也可以先验证目标源，然后再应用更改。将光标悬停在数据源上时，现在可以看到数据类型和完整路径名称，如果是企业数据，还可以看到服务器信息。数据源无法更新的项目现在在不支持的项目标题下列出。查找并替换框中的文本字符串不再区分大小写。</li></ul><h2 id="共享工作-1"><a href="#共享工作-1" class="headerlink" title="共享工作"></a>共享工作</h2><ul><li><p>您现在可以保存 Web 图层和地图服务的服务定义以稍后共享到 ArcGIS Online、ArcGIS Enterprise 门户或独立 ArcGIS Server。</p></li><li><p>现在，您可以将包含关联 Web 要素图层的建筑场景图层发布到 ArcGIS Online 以支持编辑工作流。</p></li><li><p>替换 Web 图层工具已扩展，现支持将 Web 场景图层从文件夹或云数据存储中引用的场景缓存发布到 ArcGIS Enterprise10.8.1 及更高版本。</p></li><li><p>您现在可以将子类型图层组共享为 web 要素图层、切片图层和矢量切片图层，以及在 web 地图共享到 ArcGIS Online 或 ArcGIS Enterprise 10.9 及更高版本。</p></li><li><p>自动建议已添加为共享Web 切片图层、地图图像图层、web 影像图层和地图服务时的切片方案选项。此选项会根据地图或场景的坐标系（如果是 Web 影像图层，则根据数据的坐标系）自动建议缓存的切片方案。</p></li><li><p>现在可通过使用与所有客户端兼容的符号类型选项更好地控制 web 地图的符号系统。可通过在较新的客户端使用的 Web 地图中保留 2D 点标记符号来选择使用高级符号系统。</p></li><li><p>现在，您可以在共享 web 地图或场景时更新现有 web 图层的共享设置。</p></li><li><p>已通过其他选项增强共享移动地图包体验：</p></li><li><ul><li>引用在线内容可用于在地图中包含服务图层，以在连接到 Internet 的设备上使用。</li><li>如果拥有 ArcGIS Publisher 扩展模块，可使用设置地图到期设置到期日期，指定地图在到期时是否可以访问，以及包含到期消息。</li></ul></li><li><p>将 web 样式共享到 ArcGIS Online 或 ArcGIS Enterprise 10.9 及更高版本时，还会将自定义样式的副本作为桌面样式项目共享到您的门户。</p></li></ul><h2 id="追踪网络-1"><a href="#追踪网络-1" class="headerlink" title="追踪网络"></a>追踪网络</h2><ul><li>可使用新的结果类型参数选项网络图层创建输出图层组，以包含具有追踪返回的要素选择集的要素图层。有关详细信息，请参阅控制返回的内容。</li><li>现在支持将表作为追踪操作的起点和障碍的输入。</li></ul><p>需要使用追踪网路版本 2 才能支持以下功能：</p><p>注：</p><p>使用企业级地理数据库时，ArcGIS Pro 和 ArcGIS Enterprise 版本用于确定将创建和升级的追踪网络数据集的追踪网络版本。有关详细信息，请参阅 ArcGIS 平台兼容性。</p><ul><li>现在，企业级地理数据库支持追踪网络。使用 ArcGIS Enterprise 10.9 时，可使用要素访问服务共享分支版本化的追踪网络数据集。了解有关发布和使用追踪网络的详细信息。</li><li>使用追踪配置时，您现在可以在追踪网络中创建并存储复杂追踪，这些追踪可以通过 web 地图共享并在 web 应用程序、外业应用程序和 ArcGIS Pro 中使用。</li><li>FLOWDIRECTION 网络属性现在显示为网络中所有线要素类的可编辑字段。有关详细信息，请参阅追踪网络中的流向。</li></ul><h2 id="公共设施网络-1"><a href="#公共设施网络-1" class="headerlink" title="公共设施网络"></a>公共设施网络</h2><ul><li>现在，由门户联合服务器的版本确定使用创建公共设施网络工具创建的公共设施网络版本。这也适用于使用升级数据集工具升级公共设施网络。这可确保公共设施网络的版本与 ArcGIS Server 的版本兼容。有关详细信息，请参阅 ArcGIS 平台兼容性。</li><li>现在支持将表作为追踪操作的起点和障碍的输入。</li></ul><p>需要使用公共设施为网络版本 5 才能支持以下功能：</p><p>注：</p><p>使用企业级地理数据库时，ArcGIS Pro 和 ArcGIS Enterprise 版本用于确定将创建和升级的公共设施网络数据集的公共设施网络版本。有关详细信息，请参阅公共设施网络兼容性。</p><ul><li><p>使用追踪配置时，您现在可以在公共设施网络中创建并存储复杂追踪，这些追踪可以通过 web 地图共享并在 web 应用程序、外业应用程序和 ArcGIS Pro 中使用。</p></li><li><p>对子网管理进行了以下更改：</p></li><li><ul><li>已向所有域网络类（装配除外）添加新字段 Supporting Subnetwork Name，用于提供有关内容要素的信息以及支持要素的容器的子网名称。有关详细信息，请参阅支持的子网名称。</li><li>已将新属性 管理 IsDirty 添加到 层的子网定义的 “更新子网策略”。这样可以选择绕过管理子网表中 Is dirty 属性。</li><li>子网追踪配置中提供了新选项，用于控制如何更新、导出或追踪特定层的要素 - 包含容器、包含内容和包括结构。</li><li>已将更新结构和更新容器选项分别重新标记为更新结构网络容器和更新域网络容器，现在用于确定用作容器的要素或对象是否将在域和结构网络中更新其受支持的子网名称属性。</li><li>可使用追踪和设置子网定义工具中的验证可定位性新选项识别不用作内容或在结构上未附加到其关联层次结构中的另一个要素的对象。要了解详细信息，请参阅可定位性。</li></ul></li></ul><h3 id="网络逻辑示意图-1"><a href="#网络逻辑示意图-1" class="headerlink" title="网络逻辑示意图"></a>网络逻辑示意图</h3><ul><li>“旋转树”布局支持一个新选项，用于将逻辑示意图交汇点符号设置为以在执行布局期间应用的相同旋转角度进行变化。</li><li>现在，优化模板上的逻辑示意图图层定义变得更加灵活。创建逻辑示意图图层定义工具中新增了覆盖所有图层选项。如果在未选中该选项的情况下运行此工具，您可以在保留其他子图层的同时添加新的逻辑示意图子图层或覆盖现有逻辑示意图子图层上的设置。</li><li>添加逻辑示意图要素功能规则包括新功能，允许您标记逻辑示意图交汇点，以禁止或允许它们按稍后在逻辑示意图构建过程中执行的任何“缩减交汇点”规则进行缩减。</li><li>已增强“智能树”和“主线树”布局，以更好地管理结构附件。</li><li>网络逻辑示意图支持企业级地理数据库中的追踪网络版本 2。</li><li>您可以从追踪网络图层服务生成网络逻辑示意图。</li></ul><h2 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h2><h3 id="常规-11"><a href="#常规-11" class="headerlink" title="常规"></a>常规</h3><ul><li>ArcGIS Pro 中的 Python 版本已升级为 Python 3.7.9。</li><li>已添加 Python 代码格式化模块 black 和 Python 样式指南检查器模块 pycodestyle。</li></ul><h3 id="ArcGIS-Notebooks-1"><a href="#ArcGIS-Notebooks-1" class="headerlink" title="ArcGIS Notebooks"></a>ArcGIS Notebooks</h3><ul><li>现在支持可折叠的标题。</li><li>现已启用自动保存。</li><li>Notebook 命令现在可通过键盘快捷键使用，这些快捷键可通过 Esc 键进行模式切换来访问并在 Notebook 菜单中找到。</li><li>Shell 命令已在 ArcGIS Pro 2.6 部分启用，但现在在 ArcGIS Pro 2.7 中完全受支持。</li></ul><h3 id="ArcPy-1"><a href="#ArcPy-1" class="headerlink" title="ArcPy"></a>ArcPy</h3><ul><li>ArcPy (arcpy) 现在作为 conda 包提供，并且可通过 conda 进行安装。这意味着可以将 arcpy 和支持模块直接添加到您自己的自定义环境中。</li><li>数据访问游标（包括 InsertCursor、SearchCursor 和 UpdateCursor）现在支持通过 datum_transformation 新参数进行动态基准面转换。</li><li>已添加 GenerateOptimalCoordinateSystem 函数，以支持根据给定范围和其他条件动态选择最佳投影。</li><li>Locator 类具有新属性 multilineInputFields 和 SingleLineField，用于返回在进行地理编码时可以映射的输入字段列表。</li></ul><h3 id="Mapping-模块-1"><a href="#Mapping-模块-1" class="headerlink" title="Mapping 模块"></a>Mapping 模块</h3><p>在此版本中，对映射模块 (arcpy.mp) 进行了以下更改：</p><ul><li>添加了两个新的符号系统类：RasterStretchColorizer 和 UnclassedColorsRenderer。</li><li>LegendElement 类已扩展为允许修改各个 LegendItems。</li></ul><h3 id="“影像分析”模块-1"><a href="#“影像分析”模块-1" class="headerlink" title="“影像分析”模块"></a>“影像分析”模块</h3><p>Image Analyst 模块已重命名为 Image Analysis 模块 (arcpy.ia)；对现有脚本没有影响。</p><h4 id="ArcPy-函数-4"><a href="#ArcPy-函数-4" class="headerlink" title="ArcPy 函数"></a>ArcPy 函数</h4><p>已将以下新 ArcPy 函数添加到此版本中的 arcpy.ia 模块：</p><ul><li>分析 - ComputeChange、DetectChangeUsingChangeAnalysis、GenerateTrend 和 PredictUsingTrend</li><li>波段指数 - BAI、NBR、NDBI、NDMI 和 NDSI</li><li>分类 - Classify、LinearSpectralUnmixing、RegionGrow 和 SegMeanShift</li><li>转换 - RasterizeFeatures、RasterToXarray、TrendToRGB 和 XarrayToRaster</li><li>校正 - ApparentReflectance 和 Geometric</li><li>数据管理 - Buffered 和 Reproject</li><li>重分类 - ZonalRemap</li></ul><h4 id="地理处理函数-4"><a href="#地理处理函数-4" class="headerlink" title="地理处理函数"></a>地理处理函数</h4><p>Image Analysis 地理处理函数概览提供了功能类别表以及每个地理处理函数的链接。ArcGIS Image Analyst 扩展模块中新的可用地理处理工具也作为 arcpy.ia 模块中的新地理处理函数提供。新地理处理函数如下：</p><ul><li>变化检测 - ComputeChangeRaster</li><li>深度学习 - ComputeAccuracyForObjectDetection</li><li>多维分析 - AnalyzeChangesUsingLandTrendr 和 SummarizeCategoricalRaster</li></ul><h3 id="Spatial-Analyst-模块-1"><a href="#Spatial-Analyst-模块-1" class="headerlink" title="Spatial Analyst 模块"></a>Spatial Analyst 模块</h3><p>新 ArcPy 函数和地理处理函数适用于 arcpy.sa 模块。</p><h4 id="ArcPy-函数-5"><a href="#ArcPy-函数-5" class="headerlink" title="ArcPy 函数"></a>ArcPy 函数</h4><p>已将以下新 ArcPy 函数添加到此版本中的 arcpy.sa 模块：</p><ul><li>波段指数 - BAI、NBR、NDBI、NDMI 和 NDSI</li><li>分类 - Classify、LinearSpectralUnmixing、RegionGrow 和 SegMeanShift</li><li>转换 - RasterizeFeatures</li><li>重分类 - ZonalRemap</li></ul><h4 id="地理处理函数-5"><a href="#地理处理函数-5" class="headerlink" title="地理处理函数"></a>地理处理函数</h4><p>Spatial Analyst 地理处理函数概览提供了功能类别表以及每个地理处理函数的链接。ArcGIS Spatial Analyst 扩展模块中新的可用地理处理工具也作为 arcpy.sa 模块中的新地理处理函数提供。新地理处理函数如下：</p><ul><li>水文 - StorageCapacity</li><li>表面 - AddSurfaceInformation、InterpolateShape 和 SurfaceParameters</li></ul><h2 id="ArcGIS-Pro-SDK-1"><a href="#ArcGIS-Pro-SDK-1" class="headerlink" title="ArcGIS Pro SDK"></a>ArcGIS Pro SDK</h2><ul><li>ArcGIS Pro SDK for .NET 允许您通过 SDK 加载项和配置，使用您自己特有的工具和工作流来扩展 ArcGIS Pro。请参阅 2.7 版本面向开发人员的新特性。</li></ul><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>有关近期、中期和长期开发目标的详细信息，请参考最新的 ArcGIS Pro 概述。</p><p><strong>软件下载</strong></p><p><strong>链接：<a href="https://pan.baidu.com/s/1H2Wgy5CvZ3fDDSghADKm6Q">https://pan.baidu.com/s/1H2Wgy5CvZ3fDDSghADKm6Q</a></strong></p><p>提取码：ji0p</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前使用的是ArcMap，最近因为一些需求转了ArcGIS Pro，ArcMap中提供的大多数功能在 ArcGIS Pro 中同样可用。随即面临的挑战是在重新设计的应用程序中找到熟悉的命令并遵循熟悉的工作流。ArcMap 中的下拉菜单、工具条和对话框替换为 ArcGIS Pro 中的功能区和窗格。ArcGIS Pro 基于工程的结构也是一项全新体验。ArcMap 中提供的大多数功能在 ArcGIS Pro 中同样可用。随即面临的挑战是在重新设计的应用程序中找到熟悉的命令并遵循熟悉的工作流。ArcMap 中的下拉菜单、工具条和对话框替换为 ArcGIS Pro 中的功能区和窗格。ArcGIS Pro 基于工程的结构也是一项全新体验。ArcMap 中提供的大多数功能在 ArcGIS Pro 中同样可用。随即面临的挑战是在重新设计的应用程序中找到熟悉的命令并遵循熟悉的工作流。ArcMap 中的下拉菜单、工具条和对话框替换为 ArcGIS Pro 中的功能区和窗格。ArcGIS Pro 基于工程的结构也是一项全新体验。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浙大PAT考试数据结构与算法模板整理</title>
    <link href="http://yuanquanquan.top/2022/2202202226/"/>
    <id>http://yuanquanquan.top/2022/2202202226/</id>
    <published>2022-02-26T09:11:27.000Z</published>
    <updated>2022-02-26T09:15:35.534Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前把浙大PAT甲级题库刷完了，整理一下PAT的考点</p><p>题目来源于ACwing网站</p></blockquote><span id="more"></span><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h2><h3 id="字符串类型转换"><a href="#字符串类型转换" class="headerlink" title="字符串类型转换"></a>字符串类型转换</h3><h4 id="01-to-string"><a href="#01-to-string" class="headerlink" title="01 to_string()"></a>01 to_string()</h4><p>这个太常用了不多说了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">3.14</span>;</span><br><span class="line">string str1, str2;</span><br><span class="line">str1 = <span class="built_in">to_string</span>(a);</span><br><span class="line">str2 = <span class="built_in">to_string</span>(b);</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="02-stoi-和atoi"><a href="#02-stoi-和atoi" class="headerlink" title="02 stoi()和atoi()"></a>02 stoi()和atoi()</h4><p>C++11包含在#include。作用是将字符串转化为int型。区别是stoi的形参直接传入string类型即可，而atoi的形参是const char*</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;1234567&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span>* s2 = <span class="string">&quot;1234567&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="built_in">stoi</span>(s1);</span><br><span class="line"><span class="keyword">int</span> b = <span class="built_in">atoi</span>(s2);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>进化版：stol(),stoll(),stoul(),stoull(),atol(),atoll(),atoul(),atoull()</p><p>l为long int，ll为long long，ul为unsigned long int，ull为unsigned long long</p><h4 id="03-string类的方法c-str"><a href="#03-string类的方法c-str" class="headerlink" title="03 string类的方法c_str()"></a>03 string类的方法c_str()</h4><p>c_str()就是将C++的string转化为C的字符串数组，c_str()生成一个const char *指针，指向字符串的首地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p=s[<span class="number">10</span>];</span><br><span class="line">string a=“welcome”;</span><br><span class="line"><span class="built_in">strcpy</span>(p,a.<span class="built_in">c_str</span>());</span><br><span class="line">cout&lt;&lt;p;</span><br></pre></td></tr></table></figure><p>如果需要使用C语言printf的格式化输出string时可以使用，很方便，比如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string name=<span class="string">&quot;PAT&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,name.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><h4 id="04-string类的方法find"><a href="#04-string类的方法find" class="headerlink" title="04 string类的方法find()"></a>04 string类的方法find()</h4><p>在string中找到目标字符的位置，返回数组下标</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&quot;e&quot;</span>) &lt;&lt; endl;<span class="comment">//结果为1</span></span><br></pre></td></tr></table></figure><p>未找到会返回一个特殊的标志npos(一个很大的数字)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;a&quot;</span>) == s.npos)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;not found&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>从指定位置开始查找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="comment">//从下标为5的数组位置开始查找(也就是忽略前面的)</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&quot;l&quot;</span>,<span class="number">5</span>) &lt;&lt; endl;<span class="comment">//结果为9</span></span><br></pre></td></tr></table></figure><h4 id="05-string类的方法substr"><a href="#05-string类的方法substr" class="headerlink" title="05 string类的方法substr()"></a>05 string类的方法substr()</h4><p>截取子串</p><p>单参数形式(给出截取开始的位置，末尾默认为原string末尾)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;12345abcd&quot;</span>)</span></span>;</span><br><span class="line">string a = s.<span class="built_in">substr</span>(<span class="number">5</span>);<span class="comment">//获得字符串s中从下标为5开始一直到末尾的字符串</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;<span class="comment">//结果为abcd</span></span><br></pre></td></tr></table></figure><p>双参数形式(给出截取开始的位置，并给出截取长度)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;12345abcd&quot;</span>)</span></span>;</span><br><span class="line">string a = s.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">5</span>);<span class="comment">//获得字符串s中从下标为0开始的长度为5的字符串</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;<span class="comment">//结果为12345</span></span><br></pre></td></tr></table></figure><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>给定一个模式串S，以及一个模板串P，所有字符串中只包含大小写英文字母以及阿拉伯数字。</p><p>模板串P在模式串S中多次作为子串出现。</p><p>求出模板串P在模式串S中所有出现的位置的起始下标。</p><p><strong>输入格式</strong></p><p>第一行输入整数N，表示字符串P的长度。</p><p>第二行输入字符串P。</p><p>第三行输入整数M，表示字符串S的长度。</p><p>第四行输入字符串S。</p><p><strong>输出格式</strong></p><p>共一行，输出所有出现位置的起始下标（下标从0开始计数），整数之间用空格隔开。</p><p><strong>数据范围</strong></p><p>1≤N≤10^5<br>1≤M≤10^6</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">aba</span><br><span class="line">5</span><br><span class="line">ababa</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>,M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> t[N],p[M];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">build</span><span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *ne=<span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">-1</span>;</span><br><span class="line">    ne[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;m<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;<span class="number">0</span>||p[i]==p[j])&#123;</span><br><span class="line">            i++,j++;</span><br><span class="line">            ne[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j=ne[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span> *t,<span class="keyword">char</span>* p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *ne=<span class="built_in">build</span>(p);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;m&amp;&amp;i&lt;n)</span><br><span class="line">            <span class="keyword">if</span>(j&lt;<span class="number">0</span>||t[i]==p[j])</span><br><span class="line">                i++,j++;</span><br><span class="line">            <span class="keyword">else</span> j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(j==m)&#123;    </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-j);</span><br><span class="line">            i--;</span><br><span class="line">            j=ne[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s%d%s&quot;</span>,&amp;m,p,&amp;n,t);</span><br><span class="line">    <span class="built_in">match</span>(t,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a><strong>排序</strong></h2><p>PAT常考的排名方式(同分布排名)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!i||a[i].grade!=a[i<span class="number">-1</span>].grade)</span><br><span class="line">      a[i].rank=i+<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">else</span> a[i].rank=a[i<span class="number">-1</span>].rank;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>输入一个长度为n的整数数列，从小到大输出前m小的数。</p><p><strong>输入格式</strong></p><p>第一行包含整数n和m。</p><p>第二行包含n个整数，表示整数数列。</p><p><strong>输出格式</strong></p><p>共一行，包含m个整数，表示整数数列中前m小的数。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">4 5 1 3 2</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[maxn],size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=x;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*x&lt;=size&amp;&amp;h[<span class="number">2</span>*x]&lt;h[t]) t=<span class="number">2</span>*x;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*x+<span class="number">1</span>&lt;=size&amp;&amp;h[<span class="number">2</span>*x+<span class="number">1</span>]&lt;h[t]) t=<span class="number">2</span>*x+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(t!=x)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[t],h[x]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x/<span class="number">2</span>&amp;&amp;h[x]&lt;h[x/<span class="number">2</span>])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[x],h[x/<span class="number">2</span>]);</span><br><span class="line">        x/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    size=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        <span class="built_in">down</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,h[<span class="number">1</span>]);</span><br><span class="line">        h[<span class="number">1</span>]=h[size--];</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>这里默认为升序排序，降序只要对比较的符号进行调整就可以了</p><p>快速排序分为三个过程：</p><ol><li>将数列划分为两部分（不是直接分，要求保证相对大小关系）</li><li>递归到两个子序列中分别进行快速排序</li><li>不用合并，因为此时数列已经完全有序</li></ol><p>首先对于第一步来说我们需要先找到一个基准值（基准值用于将整个数组切分成小和大两部分）</p><p>然后使用两个指针和来进行操作，大概原理就是先将指向的位置，指向的位置，然后使用do while循环使i指针疯狂向前直到遇到第一个比基准值大的数字停下，接下来对j指针也同样操作使其停在第一个比基准值小的数值上，然后互换，的数字。一直操作到ij指针相遇，那么由于对一路上不符合条件的数字都进行了互换，所以i和j相遇的就是整个数组的切分点。</p><p>OK我们找到了切分点，接下来就是递归操作(l,j),(j+1,r)了</p><p><strong>注意事项：当切分点取a[l]时，递归取(l,j),(j+1,r)。当切分点取a[r]时，递归取(l,i-1),(i,r)。当切分点其余数字时，递归二者皆可(避免出现死循环)</strong></p><p>每个递归直到l&gt;=r停止，因为一个点是不需要再“划分”的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn],n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> x=a[l],i=l<span class="number">-1</span>,j=r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(a[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(a[j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(a[i],a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(l,j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">quick_sort</span>(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线性第K大-快排思想应用"><a href="#线性第K大-快排思想应用" class="headerlink" title="线性第K大(快排思想应用)"></a>线性第K大(快排思想应用)</h3><p>找第 k 大的数（K-th order statistic），最简单的方法是先排序，然后直接找到第 k 大的位置的元素。这样做的时间复杂度是O(nlogn)，对于这个问题来说很不划算。事实上，我们有时间复杂度 的解法。</p><p>考虑快速排序的划分过程，在快速排序的“划分”结束后，我们会将数组分成两部分，我们可以通过检查k是否落在左边的范围内来减少复杂度，在排序的途中解决这个问题，当然这时候快排就不会全部排完了，而是找到了k就中途退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+10;</span><br><span class="line"></span><br><span class="line">int a[maxn];</span><br><span class="line"></span><br><span class="line">int quick_sort(int l,int r,int k)&#123;</span><br><span class="line">    if(l==r&amp;&amp;l==k) return a[k];</span><br><span class="line">    int x=a[l],i=l-1,j=r+1;</span><br><span class="line">    while(i&lt;j)&#123;</span><br><span class="line">        do i++; while(a[i]&lt;x);</span><br><span class="line">        do j--; while(a[j]&gt;x);</span><br><span class="line">        if(i&lt;j) swap(a[i],a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    if(l&lt;=k&amp;&amp;k&lt;=j) quick_sort(l,j,k);</span><br><span class="line">    else quick_sort(j+1,r,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">    for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    printf(&quot;%d\n&quot;,quick_sort(0,n-1,k-1));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是一种采用了 <strong>分治</strong> 思想的排序算法，其本质是一种 <strong>CDQ 分治</strong>。</p><p>归并排序分为三个过程：</p><ol><li>将数列随意划分为两部分（在均匀划分时时间复杂度为 O(nlogn)）</li><li>递归地分别对两个子序列进行归并排序</li><li>合并两个子序列</li></ol><p>不难发现，归并排序的核心是如何合并两个子序列，前两步都很好实现。</p><p>其实合并的时候也不难操作。注意到两个子序列在第二步中已经保证了都是有序的了，第三步中实际上是想要把两个 <strong>有序</strong> 的序列合并起来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn],t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(l,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">int</span> i=l,j=mid+<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j]) t[k++]=a[i++];</span><br><span class="line">        <span class="keyword">else</span> t[k++]=a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) t[k++]=a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) t[k++]=a[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l,j=<span class="number">0</span>;j&lt;k;i++,j++)</span><br><span class="line">        a[i]=t[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">merge_sort</span>(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断插入排序"><a href="#判断插入排序" class="headerlink" title="判断插入排序"></a>判断插入排序</h3><p>PAT出过两次的考点，判断一个排到一半的排序是否是插入排序还是别的排序（PAT会保证答案唯一）</p><p>一般可以使用这个方法，将数组分成两段，一段是排好序的（非降序），另一段是没有排好序的，我们找到没排序的那一段的起点，往下比对是否与原数组相同即可，不同就不是插入排序（因为插入排序是不会改变未排序的数组元素的顺序的）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;b[i];</span><br><span class="line"><span class="keyword">int</span> p=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(p&lt;=n&amp;&amp;b[p]&gt;=b[p<span class="number">-1</span>]) p++;</span><br><span class="line"><span class="keyword">int</span> k=p;</span><br><span class="line"><span class="keyword">while</span>(p&lt;=n&amp;&amp;a[p]==b[p]) p++;</span><br><span class="line"><span class="keyword">if</span>(p==n+<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Insertion Sort&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span>(k&gt;<span class="number">1</span>&amp;&amp;b[k]&lt;b[k<span class="number">-1</span>]) <span class="built_in">swap</span>(b[k],b[k<span class="number">-1</span>]),k--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a><strong>二分</strong></h2><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><p>二分搜索，也称折半搜索、二分查找，是用来在一个有序数组中查找某一元素的算法。</p><p>以在一个升序数组中查找一个数为例。</p><p>它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需要到右侧去找就好了；如果中间元素大于所查找的值，同理，右侧的只会更大而不会有所查找的元素，所以只需要到左侧去找。</p><p>在二分搜索过程中，每次都把查询的区间减半，因此对于一个长度为n的数组，至多会进行O(logn)次查找。</p><p>下面是第一种整数二分形式，<strong>用于找到&gt;=x的区间的第一个数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质</span><br><span class="line"></span><br><span class="line">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="line">int bsearch_1(int l, int r)</span><br><span class="line">&#123;</span><br><span class="line">    while (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = l + r &gt;&gt; 1;</span><br><span class="line">        if (check(mid)) r = mid;    // check()判断mid是否满足性质</span><br><span class="line">        else l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是第二种整数二分形式，<strong>用于找到&lt;=x的最后一个数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质</span><br><span class="line"></span><br><span class="line">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="line">int bsearch_2(int l, int r)</span><br><span class="line">&#123;</span><br><span class="line">    while (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = l + r + 1 &gt;&gt; 1;</span><br><span class="line">        if (check(mid)) l = mid;</span><br><span class="line">        else r = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a><strong>链表</strong></h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+10;</span><br><span class="line"></span><br><span class="line">int e[maxn],ne[maxn],head,idx;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    head=-1;</span><br><span class="line">    idx=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add_to_head(int x)&#123;</span><br><span class="line">    e[idx]=x;</span><br><span class="line">    ne[idx]=head;</span><br><span class="line">    head=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(int k,int x)&#123;</span><br><span class="line">    e[idx]=x;</span><br><span class="line">    ne[idx]=ne[k];</span><br><span class="line">    ne[k]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void remove(int k)&#123;</span><br><span class="line">    ne[k]=ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k,x;</span><br><span class="line">    char c;</span><br><span class="line">    init();</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        cin&gt;&gt;c;</span><br><span class="line">        if(c==&#x27;H&#x27;)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            add_to_head(x);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(c==&#x27;I&#x27;)&#123;</span><br><span class="line">            cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            add(k-1,x);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            if(!k) head=ne[head];</span><br><span class="line">            else remove(k-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=head;i!=-1;i=ne[i])&#123;</span><br><span class="line">        if(i!=head) cout &lt;&lt; &#x27; &#x27;;</span><br><span class="line">        cout &lt;&lt; e[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+10;</span><br><span class="line"></span><br><span class="line">int l[maxn],r[maxn],e[maxn],idx;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    r[0]=1;</span><br><span class="line">    l[1]=0;</span><br><span class="line">    idx=2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insertR(int k,int x)&#123;</span><br><span class="line">    e[idx]=x;</span><br><span class="line">    l[idx]=k;</span><br><span class="line">    r[idx]=r[k];</span><br><span class="line">    l[r[k]]=idx;</span><br><span class="line">    r[k]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insertL(int k,int x)&#123;</span><br><span class="line">    insertR(l[k],x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void addL(int x)&#123;</span><br><span class="line">    insertR(0,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void addR(int x)&#123;</span><br><span class="line">    insertL(1,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void remove(int k)&#123;</span><br><span class="line">    r[l[k]]=r[k];</span><br><span class="line">    l[r[k]]=l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k,x;</span><br><span class="line">    string s;</span><br><span class="line">    init();</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        if(s==&quot;L&quot;)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            addL(x);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(s==&quot;R&quot;)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            addR(x);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(s==&quot;D&quot;)&#123;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            remove(k+1);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(s==&quot;IL&quot;)&#123;</span><br><span class="line">            cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            insertL(k+1,x);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            insertR(k+1,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=r[0];i!=1;i=r[i])&#123;</span><br><span class="line">        if(i!=r[0]) cout &lt;&lt; &#x27; &#x27;;</span><br><span class="line">        cout &lt;&lt; e[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br></pre></td></tr></table></figure><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a><strong>栈和队列</strong></h2><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>给定一个长度为N的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出-1。</p><p>输入格式</p><p>第一行包含整数N，表示数列长度。</p><p>第二行包含N个整数，表示整数数列。</p><p>输出格式</p><p>共一行，包含N个整数，其中第i个数表示第i个数的左边第一个比它小的数，如果不存在则输出-1。</p><p>输入样例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 2 7 5</span><br></pre></td></tr></table></figure><p>输出样例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 3 -1 2 2</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+10;</span><br><span class="line"></span><br><span class="line">int s[maxn],t;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,x;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        while(t&amp;&amp;s[t-1]&gt;=x) t--;</span><br><span class="line">        if(t) printf(&quot;%d &quot;,s[t-1]);</span><br><span class="line">        else printf(&quot;-1 &quot;);</span><br><span class="line">        s[t++]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>给定一个大小为n≤10^6的数组。</p><p>有一个大小为k的滑动窗口，它从数组的最左边移动到最右边。</p><p>您只能在窗口中看到k个数字。</p><p>每次滑动窗口向右移动一个位置。</p><p>以下是一个例子：</p><p>该数组为[1 3 -1 -3 5 3 6 7]，k为3。</p><table><thead><tr><th style="text-align:left">窗口位置</th><th style="text-align:left">最小值</th><th style="text-align:left">最大值</th></tr></thead><tbody><tr><td style="text-align:left">[1 3 -1] -3 5 3 6 7</td><td style="text-align:left">-1</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">1 [3 -1 -3] 5 3 6 7</td><td style="text-align:left">-3</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">1 3 [-1 -3 5] 3 6 7</td><td style="text-align:left">-3</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left">1 3 -1 [-3 5 3] 6 7</td><td style="text-align:left">-3</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left">1 3 -1 -3 [5 3 6] 7</td><td style="text-align:left">3</td><td style="text-align:left">6</td></tr><tr><td style="text-align:left">1 3 -1 -3 5 [3 6 7]</td><td style="text-align:left">3</td><td style="text-align:left">7</td></tr></tbody></table><p>您的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p><p>输入格式</p><p>输入包含两行。</p><p>第一行包含两个整数n和k，分别代表数组长度和滑动窗口的长度。</p><p>第二行有n个整数，代表数组的具体数值。</p><p>同行数据之间用空格隔开。</p><p>输出格式</p><p>输出包含两个。</p><p>第一行输出，从左至右，每个位置滑动窗口中的最小值。</p><p>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p><p>输入样例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></figure><p>输出样例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e6+10;</span><br><span class="line"></span><br><span class="line">int a[maxn],q[maxn],head,rear;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">    for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        if(rear&gt;head&amp;&amp;i-k+1&gt;q[head]) head++;</span><br><span class="line">        while(rear&gt;head&amp;&amp;a[q[rear-1]]&gt;=a[i]) rear--;</span><br><span class="line">        q[rear++]=i;</span><br><span class="line">        if(i-k+1&gt;=0) printf(&quot;%d &quot;,a[q[head]]);</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;&quot;);</span><br><span class="line">    head=rear=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        if(rear&gt;head&amp;&amp;i-k+1&gt;q[head]) head++;</span><br><span class="line">        while(rear&gt;head&amp;&amp;a[q[rear-1]]&lt;=a[i]) rear--;</span><br><span class="line">        q[rear++]=i;</span><br><span class="line">        if(i-k+1&gt;=0) printf(&quot;%d &quot;,a[q[head]]);</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a><strong>树</strong></h2><h3 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树"></a>反转二叉树</h3><p>很简单了不多解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void dfs_reverse(int u)&#123;</span><br><span class="line">    if(u==-1) return;</span><br><span class="line">    dfs_reverse(l[u]);</span><br><span class="line">    dfs_reverse(r[u]);</span><br><span class="line">    swap(l[u],r[u]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建二叉搜索树"><a href="#构建二叉搜索树" class="headerlink" title="构建二叉搜索树"></a>构建二叉搜索树</h3><p>这里指的是从空树一个个插入结点构建二叉搜索树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1010;</span><br><span class="line"></span><br><span class="line">int l[maxn],r[maxn],e[maxn],idx;</span><br><span class="line"></span><br><span class="line">void insert(int&amp; u,int x)&#123;</span><br><span class="line">    if(!u)&#123;</span><br><span class="line">        u=++idx;</span><br><span class="line">        e[u]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(x&lt;=e[u]) insert(l[u],x);//注意题干中是小于还是小于等于</span><br><span class="line">    else insert(r[u],x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断完全二叉树"><a href="#判断完全二叉树" class="headerlink" title="判断完全二叉树"></a>判断完全二叉树</h3><p>用数组存储，看n个结点是否分布在1到n的位置，如果没有就不是完全二叉树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1010;</span><br><span class="line"></span><br><span class="line">int l[maxn],r[maxn],cnt[maxn];</span><br><span class="line">int maxk,maxid;</span><br><span class="line"></span><br><span class="line">void dfs(int u,int k)&#123;</span><br><span class="line">    if(u==-1) return;</span><br><span class="line">    if(k&gt;maxk)&#123;</span><br><span class="line">        maxk=k;</span><br><span class="line">        maxid=u;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(l[u],k*2);</span><br><span class="line">    dfs(r[u],k*2+1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    string x,y;</span><br><span class="line">    memset(l,-1,sizeof l);</span><br><span class="line">    memset(r,-1,sizeof r);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        if(x!=&quot;-&quot;) l[i]=stoi(x),cnt[l[i]]++;</span><br><span class="line">        if(y!=&quot;-&quot;) r[i]=stoi(y),cnt[r[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    int root=0;</span><br><span class="line">    while(cnt[root]) root++;</span><br><span class="line">    dfs(root,1);</span><br><span class="line">    if(maxk==n) printf(&quot;YES %d\n&quot;,maxid);</span><br><span class="line">    else printf(&quot;NO %d\n&quot;,root);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p>首先是固定的套路</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Node&#123;</span><br><span class="line">    int val;</span><br><span class="line">    Node* lchild,*rchild;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="01-先序遍历"><a href="#01-先序遍历" class="headerlink" title="01 先序遍历"></a>01 先序遍历</h4><p>(三种方法，难度从低到高，性能从劣到优)</p><p>第一种：使用递归的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void preorder1(Node *node)&#123;</span><br><span class="line">    if(node==NULL)</span><br><span class="line">        return;</span><br><span class="line">    printf(&quot;%d\n&quot;,node-&gt;val);</span><br><span class="line">    if(node-&gt;lchild!=NULL)</span><br><span class="line">        preorder1(node-&gt;lchild);</span><br><span class="line">    if(node-&gt;rchild!=NULL)</span><br><span class="line">        preorder1(node-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种：使用栈辅助递归降低复杂度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void preorder2(Node *node)&#123;</span><br><span class="line">    stack&lt;Node*&gt; sta;</span><br><span class="line">    if(node!=NULL)</span><br><span class="line">        sta.push(node);</span><br><span class="line">    while(!sta.empty())&#123;</span><br><span class="line">        Node* p=sta.top();sta.pop();</span><br><span class="line">        printf(&quot;%d\n&quot;,p-&gt;val);</span><br><span class="line">        if(node-&gt;rchild!=NULL)</span><br><span class="line">            sta.push(p-&gt;rchild);</span><br><span class="line">        if(node-&gt;lchild!=NULL)</span><br><span class="line">            preorder2(node-&gt;lchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种：纯用栈遍历，沿左子树链下行，途中将右子树压栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void visitAlongLeftBranch(Node* node,stack&lt;Node*&gt;&amp; sta)&#123;</span><br><span class="line">    while(node!=NULL)&#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,node-&gt;val);</span><br><span class="line">        sta.push(node-&gt;rchild);</span><br><span class="line">        node=node-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void preorder3(Node* node)&#123;</span><br><span class="line">    stack&lt;Node*&gt; sta;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        visitAlongLeftBranch(node,sta);</span><br><span class="line">        if(sta.empty())</span><br><span class="line">            break;</span><br><span class="line">        node=sta.top();</span><br><span class="line">        sta.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="02-中序遍历"><a href="#02-中序遍历" class="headerlink" title="02 中序遍历"></a>02 中序遍历</h4><p>(两种方法，难度从低到高，性能从劣到优)</p><p>第一种：使用递归的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void inorder1(Node* node)&#123;</span><br><span class="line">    if(node==NULL)</span><br><span class="line">        return;</span><br><span class="line">    if(node-&gt;lchild!=NULL)</span><br><span class="line">        inorder1(node-&gt;lchild);</span><br><span class="line">    printf(&quot;%d\n&quot;,node-&gt;val);</span><br><span class="line">    if(node-&gt;rchild!=NULL)</span><br><span class="line">        inorder1(node-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种：纯用栈遍历，将左子树压栈，一直到最左边的叶子节点，从栈中弹出节点访问并进入右子树，反复该过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void goAlongLeftBranch(Node* node,stack&lt;Node*&gt;&amp; sta)&#123;</span><br><span class="line">    while(node!=NULL) &#123;</span><br><span class="line">        sta.push(node);</span><br><span class="line">        node=node-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void inorder2(Node* node)&#123;</span><br><span class="line">    stack&lt;Node*&gt; sta;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        goAlongLeftBranch(node,sta);</span><br><span class="line">        if(sta.empty())</span><br><span class="line">            break;</span><br><span class="line">        node=sta.top();</span><br><span class="line">        sta.pop();</span><br><span class="line">        printf(&quot;%d\n&quot;,node-&gt;val);</span><br><span class="line">        node=node-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="03-后序遍历"><a href="#03-后序遍历" class="headerlink" title="03 后序遍历"></a>03 后序遍历</h4><p>(后序的栈辅助比较复杂，不写了)</p><p>使用递归的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void postorder(Node *node)&#123;</span><br><span class="line">    if(node==NULL)</span><br><span class="line">        return;</span><br><span class="line">    printf(&quot;%d\n&quot;,node-&gt;val);</span><br><span class="line">    if(node-&gt;rchild!=NULL)</span><br><span class="line">        postorder1(node-&gt;rchild);</span><br><span class="line">    if(node-&gt;lchild!=NULL)</span><br><span class="line">        postorder1(node-&gt;lchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><h4 id="01-先序-后序-不唯一"><a href="#01-先序-后序-不唯一" class="headerlink" title="01 先序+后序(不唯一)"></a>01 先序+后序(不唯一)</h4><p>假设一个二叉树上所有结点的权值都互不相同。</p><p>我们可以通过后序遍历和中序遍历来确定唯一二叉树。</p><p>也可以通过前序遍历和中序遍历来确定唯一二叉树。</p><p>但是，如果只通过前序遍历和后序遍历，则有可能无法确定唯一二叉树。</p><p>现在，给定一组前序遍历和后序遍历，请你输出对应二叉树的中序遍历。</p><p>如果树不是唯一的，则输出任意一种可能树的中序遍历即可。</p><p>输入格式</p><p>第一行包含整数 N，表示结点数量。</p><p>第二行给出前序遍历序列。</p><p>第三行给出后序遍历序列。</p><p>一行中的数字都用空格隔开。</p><p>输出格式</p><p>首先第一行，如果树唯一，则输出 <code>Yes</code>，如果不唯一，则输出 <code>No</code>。</p><p>然后在第二行，输出树的中序遍历。</p><p>注意，如果树不唯一，则输出任意一种可能的情况均可。</p><p>数据范围</p><p>1≤N≤30</p><p>输入样例1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">1 2 3 4 6 7 5</span><br><span class="line">2 6 7 4 5 3 1</span><br></pre></td></tr></table></figure><p>输出样例1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">2 1 6 4 7 3 5</span><br></pre></td></tr></table></figure><p>输入样例2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 2 3 4</span><br><span class="line">2 4 3 1</span><br></pre></td></tr></table></figure><p>输出样例2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No</span><br><span class="line">2 1 3 4</span><br></pre></td></tr></table></figure><p>代码</p><p>直接暴力枚举左子树和右子树的长度即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=40;</span><br><span class="line"></span><br><span class="line">int pre[maxn],post[maxn];</span><br><span class="line"></span><br><span class="line">int dfs(int l1,int r1,int l2,int r2,string&amp; s)&#123;</span><br><span class="line">    if(l1&gt;r1) return 1;</span><br><span class="line">    if(pre[l1]!=post[r2]) return 0;</span><br><span class="line">    int cnt=0;</span><br><span class="line">    for(int i=l1;i&lt;=r1;i++)&#123;</span><br><span class="line">        string ls,rs;</span><br><span class="line">        int lcnt=dfs(l1+1,i,l2,l2+i-l1-1,ls);</span><br><span class="line">        int rcnt=dfs(i+1,r1,l2+i-l1-1+1,r2-1,rs);</span><br><span class="line">        if(lcnt&amp;&amp;rcnt)&#123;</span><br><span class="line">            s=ls+to_string(pre[l1])+&#x27; &#x27;+rs;</span><br><span class="line">            cnt+=lcnt*rcnt;</span><br><span class="line">            if(cnt&gt;1) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++) cin&gt;&gt;pre[i];</span><br><span class="line">    for(int i=0;i&lt;n;i++) cin&gt;&gt;post[i];</span><br><span class="line">    string s;</span><br><span class="line">    int cnt=dfs(0,n-1,0,n-1,s);</span><br><span class="line">    if(cnt&gt;1) puts(&quot;No&quot;);</span><br><span class="line">    else puts(&quot;Yes&quot;);</span><br><span class="line">    s.pop_back();</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="02-先序-中序-唯一"><a href="#02-先序-中序-唯一" class="headerlink" title="02 先序+中序(唯一)"></a>02 先序+中序(唯一)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int pre[maxn],in[maxn];</span><br><span class="line">unordered_map&lt;int,int&gt; pos,l,r;</span><br><span class="line"></span><br><span class="line">int build(int pl,int pr,int il,int ir)&#123;</span><br><span class="line">    int root=pre[pl],k=pos[root];</span><br><span class="line">    if(k&gt;il) l[root]=build(pl+1,pl+k-il,il,k-1);</span><br><span class="line">    if(k&lt;ir) r[root]=build(pl+k-il+1,pr,k+1,ir);</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++) cin&gt;&gt;pre[i];</span><br><span class="line">    for(int i=0;i&lt;n;i++) cin&gt;&gt;in[i],pos[in[i]]=i;</span><br><span class="line">    int root=build(0,n-1,0,n-1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="03-后序-中序-唯一"><a href="#03-后序-中序-唯一" class="headerlink" title="03 后序+中序(唯一)"></a>03 后序+中序(唯一)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;int,int&gt; l,r,pos;</span><br><span class="line">int post[maxn],in[maxn];</span><br><span class="line"></span><br><span class="line">int build(int il,int ir,int pl,int pr)&#123;</span><br><span class="line">    int root=post[pr];</span><br><span class="line">    int k=pos[root];</span><br><span class="line">    if(k&gt;il) l[root]=build(il,k-1,pl,pl+k-1-il);</span><br><span class="line">    if(k&lt;ir) r[root]=build(k+1,ir,pl+k-1-il+1,pr-1);</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++) cin&gt;&gt;in[i],pos[in[i]]=i;</span><br><span class="line">    for(int i=0;i&lt;n;i++) cin&gt;&gt;post[i];</span><br><span class="line">    int root=build(0,n-1,0,n-1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手动实现AVL树插入"><a href="#手动实现AVL树插入" class="headerlink" title="手动实现AVL树插入"></a>手动实现AVL树插入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=50;</span><br><span class="line"></span><br><span class="line">int l[maxn],r[maxn],e[maxn],h[maxn],idx;</span><br><span class="line"></span><br><span class="line">void update(int u)&#123;</span><br><span class="line">    h[u]=max(h[l[u]],h[r[u]])+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void L(int&amp; u)&#123;</span><br><span class="line">    int p=r[u];</span><br><span class="line">    r[u]=l[p],l[p]=u;</span><br><span class="line">    update(u),update(p);</span><br><span class="line">    u=p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void R(int&amp; u)&#123;</span><br><span class="line">    int p=l[u];</span><br><span class="line">    l[u]=r[p],r[p]=u;</span><br><span class="line">    update(u),update(p);</span><br><span class="line">    u=p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int get_balance(int u)&#123;</span><br><span class="line">    return h[l[u]]-h[r[u]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insert(int&amp; u,int x)&#123;</span><br><span class="line">    if(!u) u=++idx,e[u]=x;</span><br><span class="line">    else if(x&lt;e[u])&#123;</span><br><span class="line">        insert(l[u],x);</span><br><span class="line">        if(get_balance(u)==2)&#123;</span><br><span class="line">            if(get_balance(l[u])==1)</span><br><span class="line">                R(u);</span><br><span class="line">            else L(l[u]),R(u); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        insert(r[u],x);</span><br><span class="line">        if(get_balance(u)==-2)&#123;</span><br><span class="line">            if(get_balance(r[u])==-1)</span><br><span class="line">                L(u);</span><br><span class="line">            else R(r[u]),L(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    update(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,x,root=0;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        insert(root,x);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断红黑树"><a href="#判断红黑树" class="headerlink" title="判断红黑树"></a>判断红黑树</h3><p>数据结构中有一类平衡的二叉搜索树，称为红黑树。</p><p>它具有以下 5 个属性：</p><ul><li>节点是红色或黑色。</li><li>根节点是黑色。</li><li>所有叶子都是黑色。（叶子是 NULL节点）</li><li>每个红色节点的两个子节点都是黑色。</li><li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li></ul><p>现在，对于每个给定的二叉搜索树，请你判断它是否是合法的红黑树。</p><p>注意</p><p>给定的前序遍历序列可能不合法，即无法构建出合法二叉搜索树。</p><p>输入格式</p><p>第一行包含整数 K，表示共有 K 组测试数据。</p><p>每组测试数据，第一行包含整数 N，表示二叉搜索树的节点数量。</p><p>第二行给出了这个二叉搜索树的前序遍历。</p><p>注意，虽然所有节点的权值都为正，但是我们使用负号表示红色节点。</p><p>各节点权值互不相同。</p><p>输入样例与题目中三个图例相对应。</p><p>输出格式</p><p>对于每组数据，如果是合法红黑树则输出一行 <code>Yes</code>，否则输出一行 <code>No</code>。</p><p>数据范围</p><p>1≤K≤30<br>1≤N≤30</p><p>输入样例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">9</span><br><span class="line">7 -2 1 5 -4 -11 8 14 -15</span><br><span class="line">9</span><br><span class="line">11 -2 1 -7 5 -4 8 14 -15</span><br><span class="line">8</span><br><span class="line">10 -7 5 -6 8 15 -11 17</span><br></pre></td></tr></table></figure><p>输出样例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=50;</span><br><span class="line"></span><br><span class="line">int pre[maxn],in[maxn];</span><br><span class="line">bool ans;</span><br><span class="line">unordered_map&lt;int,int&gt; pos;</span><br><span class="line"></span><br><span class="line">int build(int il,int ir,int pl,int pr,int&amp; sum)&#123;</span><br><span class="line">    int root=pre[pl];</span><br><span class="line">    int k=pos[abs(root)];</span><br><span class="line">    if(k&lt;il||k&gt;ir)&#123;</span><br><span class="line">        ans=false;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int l=0,r=0,ls=0,rs=0;</span><br><span class="line">    if(k&gt;il) l=build(il,k-1,pl+1,pl+1+k-1-il,ls);</span><br><span class="line">    if(k&lt;ir) r=build(k+1,ir,pl+1+k-1-il+1,pr,rs);</span><br><span class="line">    if(ls!=rs) ans=false;</span><br><span class="line">    sum=ls;</span><br><span class="line">    if(root&lt;0)&#123;</span><br><span class="line">        if(l&lt;0||r&lt;0) ans=false;</span><br><span class="line">    &#125;</span><br><span class="line">    else sum++;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        int n,sum=0;</span><br><span class="line">        pos.clear();</span><br><span class="line">        ans=true;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        for(int i=0;i&lt;n;i++) cin&gt;&gt;pre[i],in[i]=abs(pre[i]);</span><br><span class="line">        sort(in,in+n);</span><br><span class="line">        for(int i=0;i&lt;n;i++) pos[in[i]]=i;</span><br><span class="line">        int root=build(0,n-1,0,n-1,sum);</span><br><span class="line">        if(root&lt;0) ans=false;</span><br><span class="line">        if(ans) puts(&quot;Yes&quot;);</span><br><span class="line">        else puts(&quot;No&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DFS判断一个先序遍历是否为堆"><a href="#DFS判断一个先序遍历是否为堆" class="headerlink" title="DFS判断一个先序遍历是否为堆"></a>DFS判断一个先序遍历是否为堆</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1010;</span><br><span class="line"></span><br><span class="line">int h[maxn],n,gt,lt;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line"></span><br><span class="line">void dfs(int u)&#123;</span><br><span class="line">    v.push_back(h[u]);</span><br><span class="line">    if(u*2&gt;n)&#123;</span><br><span class="line">        cout &lt;&lt; v[0];</span><br><span class="line">        for(int i=1;i&lt;v.size();i++)&#123;</span><br><span class="line">            cout &lt;&lt; &#x27; &#x27; &lt;&lt; v[i];</span><br><span class="line">            if(v[i]&lt;=v[i-1]) gt=1;</span><br><span class="line">            else lt=1;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    if(u*2+1&lt;=n) dfs(u*2+1);</span><br><span class="line">    if(u*2&lt;=n) dfs(u*2);</span><br><span class="line">    v.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;h[i];</span><br><span class="line">    dfs(1);</span><br><span class="line">    if(lt&amp;&amp;gt) cout &lt;&lt; &quot;Not Heap&quot; &lt;&lt; endl;</span><br><span class="line">    else if(lt) cout &lt;&lt; &quot;Min Heap&quot; &lt;&lt; endl;</span><br><span class="line">    else if(gt) cout &lt;&lt; &quot;Max Heap&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最低公共祖先"><a href="#最低公共祖先" class="headerlink" title="最低公共祖先"></a>最低公共祖先</h3><p>树中两个结点 U 和 V 的最低公共祖先（LCA）是指同时具有 U 和 V 作为后代的最深结点。</p><p>给定二叉树中的任何两个结点，请你找到它们的 LCA。</p><p>输入格式</p><p>第一行包含两个整数 M 和 N，分别表示询问结点对数以及二叉树中的结点数量。</p><p>接下来两行，每行包含 N 个不同的整数，分别表示二叉树的中序和前序遍历。</p><p>保证二叉树可由给定遍历序列唯一确定。</p><p>接下来 M 行，每行包含两个整数 U 和 V，表示一组询问。</p><p>所有结点权值均在 <strong>int</strong> 范围内。</p><p>输出格式</p><p>对于每对给定的 U 和 V，输出一行结果。</p><p>如果 U 和 V 的 LCA 是 A，且 A 不是 U 或 V，则输出 <code>LCA of U and V is A.</code>。</p><p>如果 U 和 V 的 LCA 是 A，且 A 是 U 或 V 中的一个，则输出 <code>X is an ancestor of Y.</code>，其中 X 表示 A，Y 表示另一个结点。</p><p>如果 U 或 V 没有在二叉树中找到，则输出 <code>ERROR: U is not found.</code> 或 <code>ERROR: V is not found.</code> 或 <code>ERROR: U and V are not found.</code>。</p><p>数据范围</p><p>1≤M≤1000<br>1≤N≤10000</p><p>输入样例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">6 8</span><br><span class="line">7 2 3 4 6 5 1 8</span><br><span class="line">5 3 7 2 6 4 8 1</span><br><span class="line">2 6</span><br><span class="line">8 1</span><br><span class="line">7 9</span><br><span class="line">12 -3</span><br><span class="line">0 8</span><br><span class="line">99 99</span><br></pre></td></tr></table></figure><p>输出样例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LCA of 2 and 6 is 3.</span><br><span class="line">8 is an ancestor of 1.</span><br><span class="line">ERROR: 9 is not found.</span><br><span class="line">ERROR: 12 and -3 are not found.</span><br><span class="line">ERROR: 0 is not found.</span><br><span class="line">ERROR: 99 and 99 are not found.</span><br></pre></td></tr></table></figure><p>代码</p><p>PAT不会要求用倍增的LCA算法，基本上只要朴素的往上爬的算法就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e4+10;</span><br><span class="line"></span><br><span class="line">int f[maxn],pre[maxn],in[maxn],s[maxn],d[maxn];</span><br><span class="line">unordered_map&lt;int,int&gt; pos;</span><br><span class="line"></span><br><span class="line">int build(int il,int ir,int pl,int pr,int x)&#123;</span><br><span class="line">    int root=pre[pl],k=root;</span><br><span class="line">    d[root]=x;</span><br><span class="line">    if(k&gt;il) f[build(il,k-1,pl+1,pl+1+k-1-il,x+1)]=root;</span><br><span class="line">    if(k&lt;ir) f[build(k+1,ir,pl+1+k-1-il+1,pr,x+1)]=root;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,a,b;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        pos[s[i]]=i;</span><br><span class="line">        in[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;pre[i];</span><br><span class="line">        pre[i]=pos[pre[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    build(0,n-1,0,n-1,0);</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        if(!pos.count(a)&amp;&amp;!pos.count(b)) printf(&quot;ERROR: %d and %d are not found.\n&quot;,a,b);</span><br><span class="line">        else if(pos.count(a)&amp;&amp;pos.count(b))&#123;</span><br><span class="line">            int x=pos[a],y=pos[b];</span><br><span class="line">            while(x!=y)&#123;</span><br><span class="line">                if(d[x]&gt;d[y]) x=f[x];</span><br><span class="line">                else y=f[y];</span><br><span class="line">            &#125;</span><br><span class="line">            if(x==pos[a]) printf(&quot;%d is an ancestor of %d.\n&quot;,a,b);</span><br><span class="line">            else if(x==pos[b]) printf(&quot;%d is an ancestor of %d.\n&quot;,b,a);</span><br><span class="line">            else printf(&quot;LCA of %d and %d is %d.\n&quot;,a,b,s[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(!pos.count(a)) printf(&quot;ERROR: %d is not found.\n&quot;,a);</span><br><span class="line">        else printf(&quot;ERROR: %d is not found.\n&quot;,b);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h4 id="01-朴素版本"><a href="#01-朴素版本" class="headerlink" title="01 朴素版本"></a>01 朴素版本</h4><p>一共有n个数，编号是1~n，最开始每个数各自在一个集合中。</p><p>现在要进行m个操作，操作共有两种：</p><ol><li>“M a b”，将编号为a和b的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</li><li>“Q a b”，询问编号为a和b的两个数是否在同一个集合中</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+10;</span><br><span class="line"></span><br><span class="line">int p[maxn];</span><br><span class="line"></span><br><span class="line">int find(int x)&#123;</span><br><span class="line">    return p[x]=x==p[x]?x:find(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,a,b;</span><br><span class="line">    char op[2];</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        scanf(&quot;%s%d%d&quot;,op,&amp;a,&amp;b);</span><br><span class="line">        if(op[0]==&#x27;M&#x27;) p[find(a)]=find(b);</span><br><span class="line">        else</span><br><span class="line">            find(a)==find(b)?puts(&quot;Yes&quot;):puts(&quot;No&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="02-合并时更新额外信息"><a href="#02-合并时更新额外信息" class="headerlink" title="02 合并时更新额外信息"></a>02 合并时更新额外信息</h4><p>其实就是写一个merge函数，更新一些题目中要求的信息，比如说下面就是更新并查集中结点个数的merge函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void init()&#123;</span><br><span class="line">    for(int i=0;i&lt;maxn;i++)</span><br><span class="line">        f[i]=i,cnt[i]=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void merge(int x,int y)&#123;</span><br><span class="line">    int fx=find(x),fy=find(y);</span><br><span class="line">    if(fx!=fy)&#123;</span><br><span class="line">        f[fx]=fy;</span><br><span class="line">        cnt[fy]+=cnt[fx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图"><a href="#图" class="headerlink" title="图"></a><strong>图</strong></h2><h3 id="最短路径与扩展问题"><a href="#最短路径与扩展问题" class="headerlink" title="最短路径与扩展问题"></a>最短路径与扩展问题</h3><h4 id="01-朴素dijkstra"><a href="#01-朴素dijkstra" class="headerlink" title="01 朴素dijkstra"></a>01 朴素dijkstra</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=510,inf=0x3f3f3f3f;</span><br><span class="line"></span><br><span class="line">int g[maxn][maxn],vis[maxn],d[maxn],m,n;</span><br><span class="line"></span><br><span class="line">void dijkstra()&#123;</span><br><span class="line">    d[1]=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        int t=-1;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)</span><br><span class="line">            if(!vis[j]&amp;&amp;(t==-1||d[t]&gt;d[j]))</span><br><span class="line">                t=j;</span><br><span class="line">        vis[t]=1;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)</span><br><span class="line">            d[j]=min(d[j],d[t]+g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    memset(g,0x3f,sizeof g);</span><br><span class="line">    memset(d,0x3f,sizeof d);</span><br><span class="line">    int a,b,c;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        g[a][b]=min(g[a][b],c);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    if(d[n]==inf) puts(&quot;-1&quot;);</span><br><span class="line">    else printf(&quot;%d\n&quot;,d[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="02-堆优化版dijkstra"><a href="#02-堆优化版dijkstra" class="headerlink" title="02 堆优化版dijkstra"></a>02 堆优化版dijkstra</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=3e5+10,inf=0x3f3f3f3f;</span><br><span class="line">typedef pair&lt;int,int&gt; P;</span><br><span class="line"></span><br><span class="line">int h[maxn],e[maxn],ne[maxn],w[maxn],d[maxn],vis[maxn],idx,n,m;</span><br><span class="line">priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt;&gt; que;</span><br><span class="line"></span><br><span class="line">void add(int a,int b,int c)&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dijkstra()&#123;</span><br><span class="line">    d[1]=0;</span><br><span class="line">    que.push(&#123;0,1&#125;);</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        P p=que.top();que.pop();</span><br><span class="line">        int u=p.second;</span><br><span class="line">        if(vis[u]) continue;</span><br><span class="line">        vis[u]=1;</span><br><span class="line">        for(int i=h[u];i!=-1;i=ne[i])&#123;</span><br><span class="line">            int v=e[i];</span><br><span class="line">            if(d[v]&gt;d[u]+w[i])&#123;</span><br><span class="line">                d[v]=d[u]+w[i];</span><br><span class="line">                que.push(&#123;d[v],v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a,b,c;</span><br><span class="line">    memset(h,-1,sizeof h);</span><br><span class="line">    memset(d,0x3f,sizeof d);</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        add(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    if(d[n]==inf) puts(&quot;-1&quot;);</span><br><span class="line">    else printf(&quot;%d\n&quot;,d[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="03-对最短路选择的扩展"><a href="#03-对最短路选择的扩展" class="headerlink" title="03 对最短路选择的扩展"></a>03 对最短路选择的扩展</h4><p>在满足最短路的条件下继续追加条件，比如说下面的dijkstra代码就追加了两个数组cnt和sum，cnt用于统计最短路的数量，sum用于统计路径上累计的一个量(比如说路上遇到的人数啊、路上所需要的花费啊等等，就是题目会给的除了路径长度之外用于最短路选择的变量，这时候只需要在dijkstra松弛操作d[j]==d[t]+g[t][j]时对另一个量进行更新即可)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1010;</span><br><span class="line"></span><br><span class="line">int g[maxn][maxn],d[maxn],vis[maxn],w[maxn],cnt[maxn],sum[maxn],st,ed,n,m;</span><br><span class="line"></span><br><span class="line">void dijkstra()&#123;</span><br><span class="line">    d[st]=0,sum[st]=w[st],cnt[st]=1;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        int t=-1;</span><br><span class="line">        for(int j=0;j&lt;n;j++)</span><br><span class="line">            if(!vis[j]&amp;&amp;(t==-1||d[t]&gt;d[j]))</span><br><span class="line">                t=j;</span><br><span class="line">        vis[t]=1;</span><br><span class="line">        for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">            if(d[j]&gt;d[t]+g[t][j])&#123;</span><br><span class="line">                d[j]=d[t]+g[t][j];</span><br><span class="line">                cnt[j]=cnt[t];</span><br><span class="line">                sum[j]=sum[t]+w[j];</span><br><span class="line">            &#125;</span><br><span class="line">            else if(d[j]==d[t]+g[t][j])&#123;</span><br><span class="line">                cnt[j]+=cnt[t];</span><br><span class="line">                sum[j]=max(sum[j],sum[t]+w[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a,b,c;</span><br><span class="line">    memset(g,0x3f,sizeof g);</span><br><span class="line">    memset(d,0x3f,sizeof d);</span><br><span class="line">    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;st,&amp;ed);</span><br><span class="line">    for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;w[i]);</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        g[a][b]=g[b][a]=min(g[a][b],c);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    printf(&quot;%d %d\n&quot;,cnt[ed],sum[ed]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="04-对最短路信息的扩展"><a href="#04-对最短路信息的扩展" class="headerlink" title="04 对最短路信息的扩展"></a>04 对最短路信息的扩展</h4><p>比如下面这题是要求在选择最短路的前提下选择花费最小的一条，同时要求输出最短路的路径，这个也不是太难，只需要每次最短路松弛操作的时候把路径记录到pre数组即可，最后将pre倒着输出就是路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=510;</span><br><span class="line"></span><br><span class="line">int g[maxn][maxn],val[maxn][maxn],d[maxn],cost[maxn],vis[maxn],pre[maxn],n,m,st,ed;</span><br><span class="line"></span><br><span class="line">void dijkstra()&#123;</span><br><span class="line">    d[st]=0,cost[st]=0,pre[st]=-1;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        int t=-1;</span><br><span class="line">        for(int j=0;j&lt;n;j++)</span><br><span class="line">            if(!vis[j]&amp;&amp;(t==-1||d[t]&gt;d[j]))</span><br><span class="line">                t=j;</span><br><span class="line">        vis[t]=1;</span><br><span class="line">        for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">            if(d[j]&gt;d[t]+g[t][j])&#123;</span><br><span class="line">                d[j]=d[t]+g[t][j];</span><br><span class="line">                cost[j]=cost[t]+val[t][j];</span><br><span class="line">                pre[j]=t;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(d[j]==d[t]+g[t][j]&amp;&amp;cost[j]&gt;cost[t]+val[t][j])&#123;</span><br><span class="line">                cost[j]=cost[t]+val[t][j];</span><br><span class="line">                pre[j]=t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    memset(g,0x3f,sizeof g);</span><br><span class="line">    memset(val,0x3f,sizeof val);</span><br><span class="line">    memset(cost,0x3f,sizeof cost);</span><br><span class="line">    memset(d,0x3f,sizeof d);</span><br><span class="line">    int a,b,x,y;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;st&gt;&gt;ed;</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        g[a][b]=g[b][a]=min(g[a][b],x);</span><br><span class="line">        val[a][b]=val[b][a]=min(val[a][b],y);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">    for(int i=ed;i!=-1;i=pre[i]) ans.push_back(i);</span><br><span class="line">    for(int i=ans.size()-1;i&gt;=0;i--)&#123;</span><br><span class="line">        if(i!=ans.size()-1) cout &lt;&lt; &#x27; &#x27;;</span><br><span class="line">        cout &lt;&lt; ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt; &#x27; &#x27; &lt;&lt; d[ed] &lt;&lt; &#x27; &#x27; &lt;&lt; cost[ed] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断哈密顿回路"><a href="#判断哈密顿回路" class="headerlink" title="判断哈密顿回路"></a>判断哈密顿回路</h3><p>哈密顿回路的四个条件</p><ul><li>起点与终点相同</li><li>每一步都有边</li><li>所有点都被访问</li><li>总共访问n+1次点(起点访问两次)</li></ul><p>DFS时判断这四个条件即可</p><p>下面这题a数组就是题目给出的访问序列，判断是否是哈密顿回路</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=310;</span><br><span class="line"></span><br><span class="line">int g[maxn][maxn],a[maxn],vis[maxn],n,m,k;</span><br><span class="line"></span><br><span class="line">bool check(int cnt)&#123;</span><br><span class="line">    memset(vis,0,sizeof vis);</span><br><span class="line">    if(a[cnt-1]!=a[0]||cnt!=n+1) return false;</span><br><span class="line">    for(int i=0;i&lt;cnt-1;i++)&#123;</span><br><span class="line">        vis[a[i]]=1;</span><br><span class="line">        if(!g[a[i]][a[i+1]]) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[a[cnt-1]]=1;</span><br><span class="line">    for(int i=0;i&lt;cnt;i++)</span><br><span class="line">        if(!vis[a[i]]) return false;</span><br><span class="line">    return true;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int x,y,cnt;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        g[x][y]=g[y][x]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    while(k--)&#123;</span><br><span class="line">        cin&gt;&gt;cnt;</span><br><span class="line">        for(int i=0;i&lt;cnt;i++) cin&gt;&gt;a[i];</span><br><span class="line">        if(check(cnt)) puts(&quot;YES&quot;);</span><br><span class="line">        else puts(&quot;NO&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="欧拉路径"><a href="#欧拉路径" class="headerlink" title="欧拉路径"></a>欧拉路径</h3><p>在图论中，欧拉路径是图中的一条路径，该路径满足恰好访问每个边一次。</p><p>而欧拉回路是一条在同一顶点处开始和结束的欧拉路径。</p><p>它们最早由欧拉于 17361736 年解决著名的哥尼斯堡七桥问题时提出。</p><p>事实证明，如果一个连通图的所有顶点的度数都为偶数，那么这个连通图具有欧拉回路，且这个图被称为欧拉图。</p><p>如果一个连通图中有两个顶点的度数为奇数，其他顶点的度数为偶数，那么所有欧拉路径都从其中一个度数为奇数的顶点开始，并在另一个度数为奇数的顶点结束。</p><p>具有欧拉路径但不具有欧拉回路的图被称为半欧拉图。</p><p>现在，给定一个<strong>无向</strong>图，请你判断它是欧拉图、半欧拉图还是非欧拉图。</p><p>思路就是迭代判断度数，DFS或BFS判断图的联通性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=510;</span><br><span class="line"></span><br><span class="line">int g[maxn][maxn],d[maxn],vis[maxn],n,m;</span><br><span class="line"></span><br><span class="line">int dfs(int u)&#123;</span><br><span class="line">    vis[u]=1;</span><br><span class="line">    int res=1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        if(!vis[i]&amp;&amp;g[u][i])</span><br><span class="line">            res+=dfs(i);</span><br><span class="line">    return res;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        g[a][b]=g[b][a]=1;</span><br><span class="line">        d[a]++,d[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    int cnt=dfs(1);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(i!=1) cout &lt;&lt; &#x27; &#x27;;</span><br><span class="line">        cout &lt;&lt; d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    if(cnt==n)&#123;</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            if(d[i]&amp;1) sum++;</span><br><span class="line">        if(sum==0) puts(&quot;Eulerian&quot;);</span><br><span class="line">        else if(sum==2) puts(&quot;Semi-Eulerian&quot;);</span><br><span class="line">        else puts(&quot;Non-Eulerian&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else puts(&quot;Non-Eulerian&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顶点覆盖"><a href="#顶点覆盖" class="headerlink" title="顶点覆盖"></a>顶点覆盖</h3><p>如果图中的一个顶点集合能够满足图中的每一条边都至少有一个端点在该集合内，那么这个顶点集合就是图的顶点覆盖。</p><p>现在给定一张图，以及若干个顶点集合，请你判断这些顶点集合是否是图的顶点覆盖。</p><p>存一个边集每次遍历边集判断即可，特别简单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e4+10;</span><br><span class="line"></span><br><span class="line">struct edge&#123;</span><br><span class="line">    int from,to;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line">int vis[maxn],n,m,k;</span><br><span class="line">unordered_set&lt;int&gt; s;</span><br><span class="line"></span><br><span class="line">bool check()&#123;</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">        if(!s.count(e[i].from)&amp;&amp;!s.count(e[i].to))</span><br><span class="line">            return false;</span><br><span class="line">    return true;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        e[i]=&#123;a,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    while(k--)&#123;</span><br><span class="line">        int cnt,x;</span><br><span class="line">        cin&gt;&gt;cnt;</span><br><span class="line">        s.clear();</span><br><span class="line">        while(cnt--)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            s.insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">        if(check()) puts(&quot;Yes&quot;);</span><br><span class="line">        else puts(&quot;No&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大团"><a href="#最大团" class="headerlink" title="最大团"></a>最大团</h3><p>在一个无向图中，如果一个顶点子集满足子集内的任意两个不同顶点之间都是相连的，那么这个顶点子集就被称为一个团。</p><p>如果一个团不能通过加入某个新的顶点来扩展成一个更大的团，那么该团就被称为最大团。</p><p>现在，你需要判断给定顶点子集能否构成一个最大团。</p><p>也是比较简单的图论题目了，因为PAT的数据很小所以直接在给出的集合内部两两之间判断是否有边即可，如果有两点之间没有边那么就不是团。在接下来判断外面的点是否与集合中每个点都有边，如果有的话说明当前的集合不是最大团</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=210;</span><br><span class="line"></span><br><span class="line">int g[maxn][maxn],n,m,k;</span><br><span class="line">unordered_set&lt;int&gt; s;</span><br><span class="line"></span><br><span class="line">int check(vector&lt;int&gt;&amp; v)&#123;</span><br><span class="line">    s.clear();</span><br><span class="line">    for(int i=0;i&lt;v.size();i++)</span><br><span class="line">        for(int j=i+1;j&lt;v.size();j++)</span><br><span class="line">            if(!g[v[i]][v[j]])&#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">    for(int i=0;i&lt;v.size();i++) s.insert(v[i]);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        if(!s.count(i))&#123;</span><br><span class="line">            int flag=1;</span><br><span class="line">            for(auto j:v)</span><br><span class="line">                if(i!=j&amp;&amp;!g[i][j])</span><br><span class="line">                    flag=0;</span><br><span class="line">            if(flag) return 1;        </span><br><span class="line">        &#125;</span><br><span class="line">    return 2;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        g[a][b]=g[b][a]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    while(k--)&#123;</span><br><span class="line">        int cnt,x;</span><br><span class="line">        cin&gt;&gt;cnt;</span><br><span class="line">        vector&lt;int&gt; v;</span><br><span class="line">        while(cnt--) cin&gt;&gt;x,v.push_back(x);</span><br><span class="line">        if(check(v)==2) puts(&quot;Yes&quot;);</span><br><span class="line">        else if(check(v)==1) puts(&quot;Not Maximal&quot;);</span><br><span class="line">        else puts(&quot;Not a Clique&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>给出一个图和一堆序列，问序列是不是拓扑排序，输出不是拓扑排序的序列的编号</p><p>因为已经给出了序列，只需要每次判断点是不是入度为0，如果是的话就将其所有的连接的点的入度-1，然后继续往下判断，如果能一直走到序列结束那就是拓扑排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=100010;</span><br><span class="line"></span><br><span class="line">int h[maxn],e[maxn],ne[maxn],d[maxn],back[maxn],n,m,k,idx;</span><br><span class="line"></span><br><span class="line">void add(int a,int b)&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++,d[b]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool check(vector&lt;int&gt;&amp; v)&#123;</span><br><span class="line">    for(auto x:v)&#123;</span><br><span class="line">        if(d[x]!=0) return false;</span><br><span class="line">        for(int i=h[x];i!=-1;i=ne[i])&#123;</span><br><span class="line">            int y=e[i];</span><br><span class="line">            d[y]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    memset(h,-1,sizeof h);</span><br><span class="line">    int a,b;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        add(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    memcpy(back,d,sizeof d);</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">    for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">        memcpy(d,back,sizeof back);</span><br><span class="line">        int x;</span><br><span class="line">        vector&lt;int&gt; v;</span><br><span class="line">        for(int i=0;i&lt;n;i++) cin&gt;&gt;x,v.push_back(x);</span><br><span class="line">        if(!check(v)) ans.push_back(i);  </span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;ans.size();i++)&#123;</span><br><span class="line">        if(i) cout &lt;&lt; &#x27; &#x27;;</span><br><span class="line">        cout &lt;&lt; ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="染色问题"><a href="#染色问题" class="headerlink" title="染色问题"></a>染色问题</h3><h4 id="01-二分图染色"><a href="#01-二分图染色" class="headerlink" title="01 二分图染色"></a>01 二分图染色</h4><p>给定一个n个点m条边的无向图，图中可能存在重边和自环。</p><p>请你判断这个图是否是二分图。</p><p>使用DFS，一边遍历一边染色(标记1或者2，使用3-c进行颜色转换)，如果没有冲突就说明染色成功了，那么就是二分图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool dfs(int u,int c)&#123;</span><br><span class="line">    color[u]=c;</span><br><span class="line">    for(int i=h[u];i!=-1;i=ne[i])&#123;</span><br><span class="line">        int v=e[i];</span><br><span class="line">        if(!color[v])&#123;</span><br><span class="line">            if(!dfs(v,3-c))</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(color[v]==c) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="02-判断染色方案"><a href="#02-判断染色方案" class="headerlink" title="02 判断染色方案"></a>02 判断染色方案</h4><p>一个合适的顶点着色是指用各种颜色标记图中各个顶点，使得每条边的两个端点的颜色都不相同。</p><p>如果一种合适的顶点着色方案使用了一共 kk 种不同的颜色，则称其为合适的 kk 着色（<code>k-coloring</code>)。</p><p>现在，你需要判断给定的着色方案是否是合适的 kk 着色方案。</p><p>只需要将二分图染色的代码修改一番，将染色的代码删掉即可，判断的原理是一样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool dfs(int u)&#123;</span><br><span class="line">    vis[u]=1;</span><br><span class="line">    for(int i=h[u];~i;i=ne[i])&#123;</span><br><span class="line">        int v=e[i];</span><br><span class="line">        if(color[u]==color[v]) return false;</span><br><span class="line">        if(!vis[v]&amp;&amp;!dfs(v)) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><h4 id="01-高精度加法"><a href="#01-高精度加法" class="headerlink" title="01 高精度加法"></a>01 高精度加法</h4><p>注意在vector中数字是倒着存的(方便遍历)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; add(vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)&#123;</span><br><span class="line">    int t=0;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">    for(int i=0;i&lt;a.size()||i&lt;b.size();i++)&#123;</span><br><span class="line">        if(i&lt;a.size()) t+=a[i];</span><br><span class="line">        if(i&lt;b.size()) t+=b[i];</span><br><span class="line">        ans.push_back(t%10);</span><br><span class="line">        t/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    if(t) ans.push_back(1);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string sa,sb;</span><br><span class="line">    vector&lt;int&gt; a,b;</span><br><span class="line">    cin&gt;&gt;sa&gt;&gt;sb;</span><br><span class="line">    for(int i=sa.length()-1;i&gt;=0;i--) a.push_back(sa[i]-&#x27;0&#x27;);</span><br><span class="line">    for(int i=sb.length()-1;i&gt;=0;i--) b.push_back(sb[i]-&#x27;0&#x27;);</span><br><span class="line">    vector&lt;int&gt; ans=add(a,b);</span><br><span class="line">    for(int i=ans.size()-1;i&gt;=0;i--)</span><br><span class="line">        cout &lt;&lt; ans[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="02-高精度减法"><a href="#02-高精度减法" class="headerlink" title="02 高精度减法"></a>02 高精度减法</h4><p>注意在vector中数字是倒着存的(方便遍历)，<strong>cmp函数用于比较大小(重要！！！)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool cmp(vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)&#123;</span><br><span class="line">    if(a.size()!=b.size()) return a.size()&gt;b.size();</span><br><span class="line">    for(int i=a.size()-1;i&gt;=0;i--)</span><br><span class="line">        if(a[i]!=b[i])</span><br><span class="line">            return a[i]&gt;b[i];</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; sub(vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)&#123;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">    int t=0;</span><br><span class="line">    for(int i=0;i&lt;a.size();i++)&#123;</span><br><span class="line">        t=a[i]-t;</span><br><span class="line">        if(i&lt;b.size()) t-=b[i];</span><br><span class="line">        ans.push_back((t+10)%10);</span><br><span class="line">        if(t&lt;0) t=1;</span><br><span class="line">        else t=0;</span><br><span class="line">    &#125;</span><br><span class="line">    while(ans.size()&gt;1&amp;&amp;ans.back()==0) ans.pop_back();</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string sa,sb;</span><br><span class="line">    vector&lt;int&gt; a,b,ans;</span><br><span class="line">    cin&gt;&gt;sa&gt;&gt;sb;</span><br><span class="line">    for(int i=sa.length()-1;i&gt;=0;i--) a.push_back(sa[i]-&#x27;0&#x27;);</span><br><span class="line">    for(int i=sb.length()-1;i&gt;=0;i--) b.push_back(sb[i]-&#x27;0&#x27;);</span><br><span class="line">    if(cmp(a,b))</span><br><span class="line">        ans=sub(a,b);</span><br><span class="line">    else</span><br><span class="line">        ans=sub(b,a),cout &lt;&lt; &#x27;-&#x27;;</span><br><span class="line">    for(int i=ans.size()-1;i&gt;=0;i--)</span><br><span class="line">        cout &lt;&lt; ans[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="03-高精度乘法"><a href="#03-高精度乘法" class="headerlink" title="03 高精度乘法"></a>03 高精度乘法</h4><p>注意在vector中数字是倒着存的(方便遍历)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; mul(vector&lt;int&gt;&amp; a,int b)&#123;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">    int t=0;</span><br><span class="line">    for(int i=0;i&lt;a.size();i++)&#123;</span><br><span class="line">        t+=a[i]*b;</span><br><span class="line">        ans.push_back(t%10);</span><br><span class="line">        t/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    while(t) ans.push_back(t%10),t/=10;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string s;</span><br><span class="line">    vector&lt;int&gt; a;</span><br><span class="line">    int b;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;b;</span><br><span class="line">    for(int i=s.length()-1;i&gt;=0;i--)</span><br><span class="line">        a.push_back(s[i]-&#x27;0&#x27;);</span><br><span class="line">    vector&lt;int&gt; ans=mul(a,b);</span><br><span class="line">    for(int i=ans.size()-1;i&gt;=0;i--)</span><br><span class="line">        cout &lt;&lt; ans[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="04-高精度除法"><a href="#04-高精度除法" class="headerlink" title="04 高精度除法*"></a>04 高精度除法*</h4><p>注意在vector中数字是倒着存的(方便遍历)，r是余数，使用引用传递</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; div(vector&lt;int&gt;&amp; a,int b,int &amp;r)&#123;</span><br><span class="line">    r=0;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">    for(int i=a.size()-1;i&gt;=0;i--)&#123;</span><br><span class="line">        r=r*10+a[i];</span><br><span class="line">        ans.push_back(r/b);</span><br><span class="line">        r%=b;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(ans.begin(),ans.end());</span><br><span class="line">    while(ans.size()&gt;1&amp;&amp;ans.back()==0)</span><br><span class="line">        ans.pop_back();</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string s;</span><br><span class="line">    vector&lt;int&gt; a;</span><br><span class="line">    int b,r;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;b;</span><br><span class="line">    for(int i=s.length()-1;i&gt;=0;i--)</span><br><span class="line">        a.push_back(s[i]-&#x27;0&#x27;);</span><br><span class="line">    vector&lt;int&gt; ans=div(a,b,r);</span><br><span class="line">    for(int i=ans.size()-1;i&gt;=0;i--)</span><br><span class="line">        cout &lt;&lt; ans[i];</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分解质因子"><a href="#分解质因子" class="headerlink" title="分解质因子"></a>分解质因子</h3><p>给定一个整数 N，找出它的所有质因子，并输出。</p><p>思路：能除就一直除，但是不要忘记输出最后剩下来的n</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void divide(int n)&#123;</span><br><span class="line">    for(int i=2;i&lt;=n/i;i++)&#123;</span><br><span class="line">        if(n%i==0)&#123;</span><br><span class="line">            int s=0;</span><br><span class="line">            while(n%i==0)&#123;</span><br><span class="line">                s++;</span><br><span class="line">                n/=i;</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%d %d\n&quot;,i,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //注意不要忘记这里</span><br><span class="line">    if(n&gt;1) printf(&quot;%d %d\n&quot;,n,1);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,x;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">        divide(x);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分数运算-和差积商"><a href="#分数运算-和差积商" class="headerlink" title="分数运算(和差积商)"></a>分数运算(和差积商)</h3><p>给定两个有理数，你的任务是实现基本算术，即计算它们的和，差，积和商。</p><p>输入格式</p><p>共一行，以 <code>a1/b1 a2/b2</code> 的形式给出两个有理数。</p><p>分子和分母都在 <strong>long int</strong> 范围内，如果存在负号，则只能出现在分子前面，分母保证为非零数字。</p><p>输出格式</p><p>分别在四行输出两个有理数的和，差，积和商。</p><p>每行的格式为 <code>number1 operator number2 = result</code>。</p><p>请注意，所有有理数都必须采用最简形式，<code>k a/b</code>，其中 kk 是整数部分，而 a/ba/b 是最简分数部分。</p><p>如果数字为负，则必须将其包含在一对括号中。</p><p>如果除法中除数为 00，则输出 <code>Inf</code> 作为结果。</p><p>确保所有输出整数都在 <strong>long int</strong> 范围内。</p><p>输入样例1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2/3 -4/2</span><br></pre></td></tr></table></figure><p>输出样例1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2/3 + (-2) = (-1 1/3)</span><br><span class="line">2/3 - (-2) = 2 2/3</span><br><span class="line">2/3 * (-2) = (-1 1/3)</span><br><span class="line">2/3 / (-2) = (-1/3)</span><br></pre></td></tr></table></figure><p>输入样例2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5/3 0/6</span><br></pre></td></tr></table></figure><p>输出样例2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 2/3 + 0 = 1 2/3</span><br><span class="line">1 2/3 - 0 = 1 2/3</span><br><span class="line">1 2/3 * 0 = 0</span><br><span class="line">1 2/3 / 0 = Inf</span><br></pre></td></tr></table></figure><p>代码</p><p>由于数据不是很变态，所以打印的时候约分就可以了，如果数据很大那么需要在计算过程中进行约分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">ll gcd(ll a,ll b)&#123;</span><br><span class="line">    return b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(ll a,ll b)&#123;</span><br><span class="line">    ll t=gcd(a,b);</span><br><span class="line">    a/=t,b/=t;</span><br><span class="line">    if(b&lt;0) a*=-1,b*=-1;</span><br><span class="line">    bool flag=false;</span><br><span class="line">    if(a&lt;0) flag=true;</span><br><span class="line">    if(flag) printf(&quot;(&quot;);</span><br><span class="line">    if(b==1) printf(&quot;%lld&quot;,a);</span><br><span class="line">    else if(abs(a)&gt;b) printf(&quot;%lld %lld/%lld&quot;,a/b,abs(a-b*(a/b)),b);</span><br><span class="line">    else printf(&quot;%lld/%lld&quot;,a,b);</span><br><span class="line">    if(flag) printf(&quot;)&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll add(ll a,ll b,ll c,ll d)&#123;</span><br><span class="line">    print(a,b),cout &lt;&lt; &quot; + &quot;,print(c,d),cout &lt;&lt; &quot; = &quot;;</span><br><span class="line">    a=a*d+b*c,b=b*d;</span><br><span class="line">    print(a,b);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll sub(ll a,ll b,ll c,ll d)&#123;</span><br><span class="line">    print(a,b),cout &lt;&lt; &quot; - &quot;,print(c,d),cout &lt;&lt; &quot; = &quot;;</span><br><span class="line">    a=a*d-b*c,b=b*d;</span><br><span class="line">    print(a,b);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll mul(ll a,ll b,ll c,ll d)&#123;</span><br><span class="line">    print(a,b),cout &lt;&lt; &quot; * &quot;,print(c,d),cout &lt;&lt; &quot; = &quot;;</span><br><span class="line">    a=a*c,b=b*d;</span><br><span class="line">    print(a,b);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll div(ll a,ll b,ll c,ll d)&#123;</span><br><span class="line">    print(a,b),cout &lt;&lt; &quot; / &quot;,print(c,d),cout &lt;&lt; &quot; = &quot;;</span><br><span class="line">    a*=d,b*=c;</span><br><span class="line">    if(b==0) puts(&quot;Inf&quot;);</span><br><span class="line">    else&#123;</span><br><span class="line">        print(a,b);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    ll a,b,c,d;</span><br><span class="line">    scanf(&quot;%lld/%lld %lld/%lld&quot;,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">    add(a,b,c,d);</span><br><span class="line">    sub(a,b,c,d);</span><br><span class="line">    mul(a,b,c,d);</span><br><span class="line">    div(a,b,c,d);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="素数筛"><a href="#素数筛" class="headerlink" title="素数筛"></a>素数筛</h3><h4 id="01-朴素筛法"><a href="#01-朴素筛法" class="headerlink" title="01 朴素筛法"></a>01 朴素筛法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e6+10;</span><br><span class="line"></span><br><span class="line">int flag[maxn];</span><br><span class="line">vector&lt;int&gt; prime;</span><br><span class="line"></span><br><span class="line">void get_primes(int n)&#123;</span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!flag[i])&#123;</span><br><span class="line">            prime.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=i+i;j&lt;=n;j+=i)</span><br><span class="line">            flag[j]=true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    get_primes(n);</span><br><span class="line">    printf(&quot;%d\n&quot;,prime.size());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="02-埃氏筛法"><a href="#02-埃氏筛法" class="headerlink" title="02 埃氏筛法"></a>02 埃氏筛法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e6+10;</span><br><span class="line"></span><br><span class="line">int flag[maxn];</span><br><span class="line">vector&lt;int&gt; prime;</span><br><span class="line"></span><br><span class="line">void get_primes(int n)&#123;</span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!flag[i])&#123;</span><br><span class="line">            prime.push_back(i);</span><br><span class="line">            for(int j=i+i;j&lt;=n;j+=i)</span><br><span class="line">                flag[j]=true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    get_primes(n);</span><br><span class="line">    printf(&quot;%d\n&quot;,prime.size());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="03-线性筛"><a href="#03-线性筛" class="headerlink" title="03 线性筛"></a>03 线性筛</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e6+10;</span><br><span class="line"></span><br><span class="line">int flag[maxn];</span><br><span class="line">vector&lt;int&gt; prime;</span><br><span class="line"></span><br><span class="line">void get_primes(int n)&#123;</span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!flag[i]) prime.push_back(i);</span><br><span class="line">        for(int j=0;prime[j]&lt;=n/i;j++)&#123;</span><br><span class="line">            flag[prime[j]*i]=true;</span><br><span class="line">            if(i%prime[j]==0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    get_primes(n);</span><br><span class="line">    printf(&quot;%d\n&quot;,prime.size());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int qmi(int a,int b,int p)&#123;</span><br><span class="line">    int ans=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1) ans=1ll*ans*a%p;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">        a=1ll*a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,a,b,p;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;p);</span><br><span class="line">        printf(&quot;%d\n&quot;,qmi(a,b,p));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a><strong>动态规划</strong></h2><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><p>二维</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1010;</span><br><span class="line"></span><br><span class="line">int v[maxn],w[maxn],dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;=m;j++)&#123;</span><br><span class="line">            dp[i][j]=dp[i-1][j];</span><br><span class="line">            if(j&gt;=v[i])</span><br><span class="line">                dp[i][j]=max(dp[i][j],dp[i-1][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>滚动数组优化一维</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1010;</span><br><span class="line"></span><br><span class="line">int v[maxn],w[maxn],dp[maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=m;j&gt;=v[i];j--)&#123;</span><br><span class="line">                dp[j]=max(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="02-硬币找零"><a href="#02-硬币找零" class="headerlink" title="02 硬币找零"></a>02 硬币找零</h4><p>(01背包应用)</p><p>伊娃喜欢从整个宇宙中收集硬币。</p><p>有一天，她去了一家宇宙购物中心购物，结账时可以使用各种硬币付款。</p><p>但是，有一个特殊的付款要求：每张帐单，她都必须<strong>准确</strong>的支付所消费金额。</p><p>给定她拥有的所有硬币的面额，请你帮她确定对于给定的金额，她能否找到一些硬币来支付。</p><p>输入格式</p><p>第一行包含两个整数 N 和 M，分别表示硬币数量以及需要支付的金额。</p><p>第二行包含 N 个整数，表示每个硬币的面额。</p><p>输出格式</p><p>共一行，按照面额升序的顺序，输出用来支付的所有硬币的面额。</p><p>如果支付方式不唯一，则输出最小的支付面额序列。</p><p>如果无解，则输出 <code>No Solution</code>。</p><p>对于两个序列 <code>&#123;A[1], A[2], ...&#125;</code> 和 <code>&#123;B[1], B[2], ...&#125;</code>，如果存在 k≥1k≥1 使得所有 i&lt;ki&lt;k，满足 A[i]=B[i]A[i]=B[i] 成立，并且 A[k]&lt;B[k]，则我们称序列 AA 小于序列 BB。</p><p>数据范围</p><p>1≤N≤10^4,<br>1≤M≤100,<br>硬币面值不超过 100100</p><p>输入样例1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 9</span><br><span class="line">5 9 8 7 2 3 4 1</span><br></pre></td></tr></table></figure><p>输出样例1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3 5</span><br></pre></td></tr></table></figure><p>输入样例2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 8</span><br><span class="line">7 2 4 3</span><br></pre></td></tr></table></figure><p>输出样例2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No Solution</span><br></pre></td></tr></table></figure><p>代码</p><p>为了保证最小的面额支付序列，需要将硬币面额从大到小进行dp，保证后面面额小的可以覆盖面额大的方案</p><p>输出路径的时候只需要从后往前沿着true的路径倒着回去即可，因为是bool数组所以只会存储一个支付方案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1e4+10,M=110;</span><br><span class="line"></span><br><span class="line">bool f[N][M];</span><br><span class="line">int a[N];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    f[0][0]=true;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    sort(a+1,a+1+n,greater&lt;int&gt;());</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        for(int j=0;j&lt;=m;j++)&#123;</span><br><span class="line">            f[i][j]=f[i-1][j];</span><br><span class="line">            if(j&gt;=a[i]) f[i][j]|=f[i-1][j-a[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    if(!f[n][m]) puts(&quot;No Solution&quot;);</span><br><span class="line">    else&#123;</span><br><span class="line">        bool flag=true;</span><br><span class="line">        while(n)&#123;</span><br><span class="line">            if(m&gt;=a[n]&amp;&amp;f[n-1][m-a[n]])&#123;</span><br><span class="line">                if(flag) flag=false;</span><br><span class="line">                else cout &lt;&lt; &#x27; &#x27;;</span><br><span class="line">                cout &lt;&lt; a[n];</span><br><span class="line">                m-=a[n];</span><br><span class="line">            &#125;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="03-完全背包"><a href="#03-完全背包" class="headerlink" title="03 完全背包"></a>03 完全背包</h4><p>朴素版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1010;</span><br><span class="line"></span><br><span class="line">int dp[maxn][maxn],v[maxn],w[maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        for(int j=0;j&lt;=m;j++)</span><br><span class="line">            for(int k=0;k*v[i]&lt;=j;k++)</span><br><span class="line">                dp[i][j]=max(dp[i][j],dp[i-1][j-k*v[i]]+k*w[i]);</span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1010;</span><br><span class="line"></span><br><span class="line">int dp[maxn][maxn],v[maxn],w[maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;=m;j++)&#123;</span><br><span class="line">            dp[i][j]=dp[i-1][j];</span><br><span class="line">            if(j&gt;=v[i])</span><br><span class="line">                dp[i][j]=max(dp[i][j],dp[i][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>滚动数组终极优化版</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1010;</span><br><span class="line"></span><br><span class="line">int dp[maxn],v[maxn],w[maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        for(int j=v[i];j&lt;=m;j++)</span><br><span class="line">            dp[j]=max(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">    cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="04-整数分解"><a href="#04-整数分解" class="headerlink" title="04 整数分解"></a>04 整数分解</h4><p>(完全背包应用)</p><p>正整数 NN 的 K−P 分解，是将 N 写为 K 个正整数的 P 次幂的和。</p><p>请你编写一个程序，给定 N,K,P 的情况下，找到 N 的 K−P 分解。</p><p>输入格式</p><p>共一行，包含三个整数 N,K,P。</p><p>输出格式</p><p>如果存在 N 的 K−P 分解，则以如下格式输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">N = n[1]^P + ... n[K]^P</span><br></pre></td></tr></table></figure><p>其中，n[i]是第 i 个因子，所有因子必须按照不升序顺序输出。</p><p>注意，答案也许不唯一。</p><p>例如，169的 5−2 分解共有 99 种，如 122+42+22+22+12，112+62+22+22+22 等等。</p><p>你需要输出各因子之和最大的一种解法。</p><p>如果仍不能确定唯一解法，则选择因子序列更大的解法。</p><p>我们称序列 {a1,a2,…,aK} 大于序列 {b1,b2,…,bK}，当且仅当存在 1≤L≤K，满足当 ibL。</p><p>如果无解，则直接输出 <code>Impossible</code>。</p><p>数据范围</p><p>1≤K≤N≤400,<br>2≤P≤7</p><p>输入样例1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">169 5 2</span><br></pre></td></tr></table></figure><p>输出样例1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">169 = 6^2 + 6^2 + 6^2 + 6^2 + 5^2</span><br></pre></td></tr></table></figure><p>输入样例2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">169 167 3</span><br></pre></td></tr></table></figure><p>输出样例2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Impossible</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=410;</span><br><span class="line"></span><br><span class="line">int f[30][maxn][maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k,p,m;</span><br><span class="line">    memset(f,-0x3f,sizeof f);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;p;</span><br><span class="line">    f[0][0][0]=0;</span><br><span class="line">    for(m=1;;m++)&#123;</span><br><span class="line">        int val=pow(m,p);</span><br><span class="line">        if(val&gt;n) break;</span><br><span class="line">        for(int i=0;i&lt;=n;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;=k;j++)&#123;</span><br><span class="line">                f[m][i][j]=f[m-1][i][j];</span><br><span class="line">                if(j&amp;&amp;i&gt;=val) f[m][i][j]=max(f[m][i][j],f[m][i-val][j-1]+m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m--;</span><br><span class="line">    if(f[m][n][k]&lt;0) puts(&quot;Impossible&quot;);</span><br><span class="line">    else&#123;</span><br><span class="line">        bool flag=true;</span><br><span class="line">        printf(&quot;%d = &quot;,n);</span><br><span class="line">        while(m)&#123;</span><br><span class="line">            int val=pow(m,p);</span><br><span class="line">            while(f[m][n-val][k-1]+m&gt;=f[m-1][n][k])&#123;</span><br><span class="line">                if(!flag) cout &lt;&lt; &quot; + &quot;;</span><br><span class="line">                else flag=false;</span><br><span class="line">                printf(&quot;%d^%d&quot;,m,p);</span><br><span class="line">                n-=val,k--;</span><br><span class="line">            &#125;</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="05-多重背包"><a href="#05-多重背包" class="headerlink" title="05 多重背包*"></a>05 多重背包*</h4><p>PAT题目最多最多也只会涉及到01背包和完全背包了，多重背包不太可能，但是还是放一下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=110;</span><br><span class="line"></span><br><span class="line">int dp[maxn][maxn],v[maxn],w[maxn],s[maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i];</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        for(int j=0;j&lt;=m;j++)</span><br><span class="line">            for(int k=0;k&lt;=s[i]&amp;&amp;k*v[i]&lt;=j;k++)</span><br><span class="line">                dp[i][j]=max(dp[i][j],dp[i-1][j-k*v[i]]+k*w[i]);</span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大子序列和"><a href="#最大子序列和" class="headerlink" title="最大子序列和"></a>最大子序列和</h3><p>给定一个包含 KK 个整数的序列 {N1,N2,…,NK}。</p><p>连续子序列定义为 {Ni,Ni+1,…,Nj}，其中 1≤i≤j≤K。</p><p>最大子序列是指序列内各元素之和最大的连续子序列。</p><p>例如，给定序列 {−2,11,−4,13,−5,−2}，它的最大子序列为 {11,−4,13}，其各元素之和为 20。</p><p>现在你需要求出最大子序列的各元素之和，并且输出最大子序列的第一个元素和最后一个元素的值。</p><p>输入格式</p><p>第一行包含一个整数 K。</p><p>第二行包含 K 个整数。</p><p>输出格式</p><p>输出一行三个整数，分别表示最大子序列的各元素之和以及最大子序列的第一个元素和最后一个元素的值。</p><p>设最大子序列为 {Ni,Ni+1,…,Nj}，如果答案不唯一，则选择 i 更小的解，如果仍不唯一，则选择 j 更小的解。</p><p>注意，我们规定，如果所有 KK 个数字均为负数，则其最大和定义为 0，并且应该输出整个序列的第一个数字和最后一个数字。</p><p>数据范围</p><p>1≤K≤10000,序列内元素的绝对值不超过 10^5。</p><p>输入样例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">-10 1 2 3 4 -5 -23 3 7 -21</span><br></pre></td></tr></table></figure><p>输出样例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 1 4</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=10010;</span><br><span class="line"></span><br><span class="line">int a[maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,ans=-1,l,r;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    for(int i=0,f=-1,st;i&lt;n;i++)&#123;</span><br><span class="line">        if(f&lt;0) f=0,st=i;</span><br><span class="line">        f+=a[i];</span><br><span class="line">        if(f&gt;ans)&#123;</span><br><span class="line">            ans=f;</span><br><span class="line">            l=a[st],r=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans&lt;0) ans=0,l=a[0],r=a[n-1];</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; &#x27; &#x27; &lt;&lt; l &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><h4 id="01-最长公共子序列"><a href="#01-最长公共子序列" class="headerlink" title="01 最长公共子序列"></a>01 最长公共子序列</h4><p>dp[i][j]=max(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]+1)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1010;</span><br><span class="line"></span><br><span class="line">char a[maxn],b[maxn];</span><br><span class="line">int dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    scanf(&quot;%s%s&quot;,a+1,b+1);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">            dp[i][j]=max(dp[i-1][j],dp[i][j-1]);</span><br><span class="line">            if(a[i]==b[j]) dp[i][j]=dp[i-1][j-1]+1;</span><br><span class="line">        &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,dp[n][m]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="02-变种-一个字符匹配多个字符"><a href="#02-变种-一个字符匹配多个字符" class="headerlink" title="02 变种(一个字符匹配多个字符)"></a>02 变种(一个字符匹配多个字符)</h4><p>a数组中的字符可以匹配多次b数组中的字符，所以dp[i][j]=max(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]+1)要改成f[i][j]=max(f[i-1][j],f[i][j-1],f[i][j-1]+1)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=210,M=1e4+10;</span><br><span class="line"></span><br><span class="line">int a[N],b[M];</span><br><span class="line">int f[N][M];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=m;i++) cin&gt;&gt;a[i];</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    for(int i=1;i&lt;=k;i++) cin&gt;&gt;b[i];</span><br><span class="line">    for(int i=1;i&lt;=m;i++)</span><br><span class="line">        for(int j=1;j&lt;=k;j++)&#123;</span><br><span class="line">            if(a[i]==b[j]) f[i][j]=max(f[i][j],f[i][j-1]+1);</span><br><span class="line">            else f[i][j]=max(f[i-1][j],f[i][j-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[m][k] &lt;&lt; endl;    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态机模型"><a href="#状态机模型" class="headerlink" title="状态机模型"></a>状态机模型</h3><p>字符串 <code>APPAPT</code> 中共包含两个 <code>PAT</code> 作为子串。</p><p>第一个子串由第二，第四和第六个字符组成，第二个子串由第三，第四和第六个字符组成。</p><p>现在给定一个字符串，请你求出字符串中包含的 <code>PAT</code> 的数量。</p><p>输入格式</p><p>共一行，包含一个由大写字母 P,A,T 构成的字符串。</p><p>输出格式</p><p>输出字符串中包含的 <code>PAT</code> 的数量。</p><p>由于结果可能很大，请你输出对 1000000007 取模后的结果。</p><p>数据范围</p><p>给定字符串的长度不超过 10^5。</p><p>输入样例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPAPT</span><br></pre></td></tr></table></figure><p>输出样例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>代码</p><p>将初始状态设置为0，匹配P的状态设置为1，匹配P后又匹配了A的状态设置为2，匹配了P和A之后又匹配了T的状态设置为3</p><p>f[i][j]表示为只考虑给定字符串前i个字符且走到了状态j的所有路线的数量</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前把浙大PAT甲级题库刷完了，整理一下PAT的考点&lt;/p&gt;
&lt;p&gt;题目来源于ACwing网站&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>USD简介和各在DCC软件中的应用</title>
    <link href="http://yuanquanquan.top/2022/20220220/"/>
    <id>http://yuanquanquan.top/2022/20220220/</id>
    <published>2022-02-19T17:41:57.000Z</published>
    <updated>2022-02-20T15:00:22.134Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近做了些AR/VR的1内容，学了不少三维数据的结构，本节介绍一下USD，由于相关内容相对比较多，一次性的把近期的学习都总结在这里，所以文章相对比较长，本来想分开弄，但他们的关联性比较强，就合并了。并且不会涉及太多的开发相关内容，仅仅是简单的介绍。</p></blockquote><span id="more"></span>  <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>现在关于USD的介绍还是比较多了，热度一直未减，但目前据我所知，由于内容太多，文章和文档比较分散，并且官方的专业术语表里面有上百个，每一个的解释相对也是较难以理解的，所以，简单总结相对能比较快速和集中的了解USD的框架以及他的运用。</p><h3 id="USD是什么"><a href="#USD是什么" class="headerlink" title="USD是什么"></a>USD是什么</h3><ol><li>关于usd的介绍，<br>首先需要了解他是什么，Pixar对他的描述是，在电影和游戏的生产流程中通常会生成、存储和传输大量的三维数据，我们称之为“<strong>场景描述</strong>”Universal Scene Description (USD)。</li><li>因为在CG的生产流程中的每一个模块（模型、材质、动画、灯光、特效、渲染）都有自己特定的场景描述形式，来满足模块的特定需求和工作流程，并且任何其他模块都无法读取或编辑。因此它并不会让你做出更好的视觉效果，但能让你在各个DCC之间或者在整个制作团队各个工作流传递数据变得更有效率。</li><li>总的来说，USD是用来合成场景和解析场景中的数值而运行的引擎，因此，它在不同DCC之间交换和传输数据，也可以直接用做3D场景文件。</li></ol><h3 id="USD的性质"><a href="#USD的性质" class="headerlink" title="USD的性质"></a>USD的性质</h3><ul><li>上述提到的USD的简单介绍：<br>那么就很容易的知道他的主要特点是能够构建复杂的场景，让艺术家或者各个工作流之间的合作在效率上会有质的提升。那么我们可以了解一下他的基本特性。</li><li>我们已经知道了USD是一个场景描述文件，从另一个方面来看，CG流程生产里一种协作方案，数据的传递和处理系统。并且用途非常广泛，用于影视，游戏等领域，比如Nvidia，Apple，各个游戏引擎，影视DCC软件都在使用。</li></ul><h3 id="USD的概念"><a href="#USD的概念" class="headerlink" title="USD的概念"></a>USD的概念</h3><p>这里主要是用一些实例来展示USD的概念。<br>USD场景描述格式具有.usda人类可读的等效纯文本（）。这是一个非常简单的.usda示例</p><ul><li>表示一个单位的立方体：建立一个.usda的文件，</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*#usda 1.0*</span><br><span class="line">def Cube &quot;box&quot; &#123;</span><br><span class="line">double size = 1.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的“<code>def</code>”是用来告诉USD，我们这里定义了一个基础容器(<code>Prim</code>)，这里<code>prim</code>是USD中的最重要的容器，后续后详细说明。<br><code>Cube</code>指代的是prim的类型，这个类型是通过模式(<code>schema</code>)来进行描述的<br>后面部分的“<code>box</code>”就是这个“<code>Cube</code>”的名字。<br>在{ }中的定义了立方体的大小，<br><strong>总结来说</strong>：这个usd文件中定义了一个prim并且声明了一个“属性(attribute)”的值的“观点（<code>opinion</code>)”<br>它也是一种缓存格式，至于这个格式相对于abc优势，也是比较多的，目前我对USD的了解还不太多，只能以后在看了。</p><h4 id="USD的文件后缀"><a href="#USD的文件后缀" class="headerlink" title="USD的文件后缀"></a>USD的文件后缀</h4><p>要注意的一点是通常我们说的USD其实不是一个文件的格式，他的主要文件格式如下。<br>主要是.usd/.usda/.usdc的后缀：</p><ul><li><code>.usd</code>，这个格式是最通用而最常见的后缀，他又两种储存方式，一种是可读性较强的<code>ASCII</code>文件，一种是压缩优化过的二进制文件。</li><li><code>.usda</code>，这个格式表示usd文件是可读性较强的<code>ASCII</code>编码文件</li><li><code>.usdc</code>，这个后缀表示该usd文件被压缩优化过的二进制文件，不具可读性</li><li><code>.usdz</code>，这个是苹果公司基于usd自己研发的格式，优化了流传输等方面的功能，</li></ul><p>注意：如果需要打开二进制的usdc文件，想要读取这些二进制的内容，可以借助官方给我们提供的命令行小工具即可：<br>usdcat命令行用于转换格式</p><h4 id="构成USD文件的元素"><a href="#构成USD文件的元素" class="headerlink" title="构成USD文件的元素"></a>构成USD文件的元素</h4><p>上述说明了USD的基本概念，下面或详细说明USD的核心元素。</p><ul><li><strong>Primitives (prims)节点</strong></li></ul><p>prims是USD的基本“容器”，”Primitive”通常缩写为”prim”。<br>比如说一个<code>box</code>。它通常是有类型的。上面的文件中<code>Cube</code>就是<code>box</code>的类型。</p><p>注意：这个不是Houdini里面说的Primitive不是一个概念，可以把当当成最基本的一个容器，并且，prim是有名称的，可以支持多层级，每个层级包含承载很多类型，比如：灯光，相机，材质等这些都是个prim。访问对应的名称空间就能访问对应的节点。</p><ul><li><strong>Property资产</strong><br>Property包含了attributes属性, relationships关系。并且是有属性名，属性类型和对应的属性数据。<br><strong>1.Attributes属性</strong><br>是用来描述prim的类型值，例如：box的大小<br><strong>2.Relationships关系</strong><br>用来在基础容器(Prim)和资产(property)之间建立连接,例如，指定对一个网格对象的shader要使用的材质.</li><li><strong>Metadata元素据</strong><br>它是一种依附在prim，property，甚至是layer上面的额外信息，例如，如果为mesh指定颜色primvar ，则可添加interpolation元数据，该元数据指定渲染器应如何在这些点的颜色之间混合。</li><li><strong>Layers层</strong><br>一个.usd文件一般会被称为层。就像Photoshop里面的层一样，并且一个层可以表示场景的一个片段，例如，道具，角色，装备等。然后这些Layer最终会被合成一个完整的场景，一个Layer可以有Sublayer，然后构成LayerStack，处于LayerStack上方的节点会覆盖下方的节点。</li><li><strong>Composition arcs合成操作符</strong><br>是USD提供的一种合成场景的方式，它十分的强大，并且能够帮你解锁一些很酷的工作流程。例如，场景图层可能会reference进包含道具，灯光等图层。这些图层可能reference自己的子层，依此类推。在将各层复合在一起，合并每层中的prims。较高层中的属性将覆盖下面的属性。</li><li><strong>Stage场次</strong><br>这个可以理解成场景，每个usd文件里都包含一个stage。Stage就是把所有层，从根层向下合成的结果。主要作用是查询场景中的信息和遍历场景。它给到你的是合成好的基础容器(prim)，和相应的位置，命名空间以及属性(attribute)的最终值等等。<br>注意，stage只是结果的名称。“stage文件”和“layer文件”之间没有区别，如果将.usd文件加载为”top-level”文件，它将创建一个新的stage。在另一种情况下，你可以将同一文件作为不同stage的图层引用。</li><li><strong>合成Composition</strong><br>是通过写在usd文件中的一系列的操作符号(operators (or “arcs”))来完成的。在运行时，usd的合成引擎运算这些操作符，并最终将合成的场景呈现，每个USD文件都包含完整的“场景”。<br>USD文件可以将其它USD文件的内容导入为图层,用于将多层合成、叠加到顶层文件创建的整个场景(stage)中的软件。合成允许你从非常小的资产开始构建资产，然后小的资产组合成中等大小的资产，之后中的大小的资产组合成完整的场景。它允许你进行非破坏性的复写(non-destructive override)，这样，你就可以在不破坏当前资产的情况下，修改资产的外观，属性等等,<br>合成器里面有几个合成机制，完整的机制是 Local（最强） - Inherite - Variant - Reference - Payload - Specialists（最弱）</li><li><strong>Sublayers, references</strong><br>USD具有两种“导入”另一个USD的内容的方法：sublayering 是将导入文件的树覆盖在当前树上，而reference是将导入树的内容作为分支附加到现有树上。</li></ul><p>你可以将sublayering视为组成整个场景的不同版本，例如：灯光部门的场景版本与最终照明重叠在Layout部门的场景版本中并使用照明，并将其视为场景添加一部分。</p><ul><li><strong>Sub-layering子层</strong></li></ul><p>是最简单的合成操作符(composition arc)。子层的作用是：允许你将场景描述合并到其它层上。<br>具有相同路径的prims和具有相同名称的属性、元数据的opinions将基于opinion strength合并。<br>当合并每个文件都应构成整个场景一部分时，此功能很有用。例如，组成代表场景布局，道具，角色，特效，灯光的单独图层。</p><ul><li><strong>Referencing引用</strong><br>Referencing将被Referencing文件并“参考”到当前树中的分支上。可以理解为Maya的参考。<br>通过引用(reference)合成操作符来将其它层堆栈(layer stack)中的基础图元(prim)引入到我们的场景图中。这就是我们如何用小的资产来构建大的资产的方式。特别地，引用是在不同位置多次加载同一图层文件的唯一方法。因为子分层适用于整个树，所以多次对同一文件进行子分层将无效。</li><li><strong>Payloads有效载荷</strong><br>引用(Reference)让我们可以通过小的组件组成大的资产集合体。但是，有的时候需要让用户在运行时决定哪些内容要进行合成。负载(payloads)合成操作符提供了我们这种能力，它可以在运行时通过各种API调用选择加载或卸载的引用，但是有可能让USD不加载有效负载，除非特别要求它们。这使您可以控制场景的哪些部分被加载到内存中，从而通过集中精力关注场景的各个部分来减少内存使用和处理时间。</li><li><strong>Activation and visibility激活和可见性</strong><br>由于USD是专为非破坏性编辑而设计的，因此不允许deleting( 删除) primitives。但是，可以使用新值override(覆盖 ) primitives，或者deactivate(停用 ) primitives，以使它们不起作用。</li><li><strong>Schema</strong><br>它可以理解为：模式是一组属性attribute的集合，这些属性赋予了基础容器Prim含义。<br>提供了一个流程的编程环境。这个是开发者才会接触到的东西，通俗理解就是API包，</li><li><strong>Opinion观点</strong><br>每个usd文件（Layer）都会包含着很多的opinion，比如，覆盖被引用文件box中的颜色属性，修改一下大小，那他就是一个新的opinion。</li><li><strong>Variant变体</strong><br>变体允许用户在单个资产中打包一组备选方案。用户创建在资产中包含“变体(variant)”的“变量集(variant sets)”，然后编写“变量选择(variant selections)”以选择在合成过程中应该具体使用哪个变体。可以将他理解为同个节点(Prim)的不同版本，比如说一个模型可能实际工作时候有很多的迭代版本，那这n个版本可以用变体这个东西来承载，可以很方便的切换。利用少量的物体能创建出更丰富的资产。</li></ul><h3 id="USD的发展历程"><a href="#USD的发展历程" class="headerlink" title="USD的发展历程"></a>USD的发展历程</h3><p>USD大约是皮克斯开发的第四代“<strong>合成场景描述</strong>”。在完成《玩具总动员》之后（《玩具总动员》中每个镜头由单个线性程序文件描述），皮克斯研发团队开始在其专有动画系统Marionette（内部叫Menv）的背景下添加和发展参考、分层、编辑和变体的概念。<br>从《虫虫特工队》开始，在接下来的十部故事片中继续。到2004年，很明显，尽管Marionette已经发展得非常强大，但其有机发展的起源正在成为持续稳定发展和我们利用多核系统等重要工具的能力的障碍。该工作室现在致力于设计和开发叫做Presto的全新第二代动画系统，该系统最初用于《勇敢传说》，在那之后应用了所有功能。<br>Presto开始着手解决的Marionette的一个问题是，它的各种组合和覆盖3D场景描述的功能并不总是有效地同时工作，因为它们分布在三种不同的格式和“合成引擎”上。Presto提供了统一的第二代场景描述，支持从单个网格到整个模型，环境或镜头的所有粒度的引用、覆盖、变化和其他操作，以单个ascii格式编码并使用一个组合引擎进行评估。</p><p>USD项目的一个关键组成部分是开发一种超现代、可扩展的OpenGL渲染架构，称为Hydra。Hydra作为USD项目的一部分，因为它为流程中USD的使用增加了巨大价值，并在我们所有的插件中使用，它还提供了一个基准和参考，用于如何利用USD的多线程进行快速场景加载和成像，以及有效地更新以响应对活动中的UsdStage的动态编辑。然而，Hydra本身就是一款产品，并且已经拥有除USD以外的其他直接前端耦合器（包括Presto、Maya和Katana插件），并且正在超越其原有的OpenGL架构，为其他后端客户端提供服务，例如路径跟踪器。</p><h3 id="USD能做什么"><a href="#USD能做什么" class="headerlink" title="USD能做什么"></a>USD能做什么</h3><p>主要有以下几点：</p><ul><li>USD是Pixar公司多年技术迭代的结果，它可以帮助你学习到我们的经验和错误。</li><li>USD的直接继承者就是Pixar公司大名鼎鼎的Presto软件：pixar内部的绑定，动画，模拟软件。所以USD构建在很多有天赋的从业人员，几十年的经验上。</li><li>这也是为什么USD中有很多很复杂的概念：这么多的概念，是为了生产中更好的解决实际问题，希望在后面的学习中，大家也能理解这些概念为什么是这样的。</li><li>USD设计的主要目的是为了生产：电影级质量的数字内容，并且有着很好的拓展性。</li></ul><p>它解决了以稳定性性和可扩展的方式，交换资产组成的任意3D场景的需要。</p><p>USD构成语义上最强大，最统一的方面是，所有上述运算符都可以以任何组合应用于任何素数，并且构成引擎将以可预测的方式解析结果图。这种对构图弧进行统一处理的另一个理想属性是，构图中的较强层可以均匀地覆盖较弱层中的场景描述  ，而不管是否对较弱层进行了子层，引用，继承等。针对较弱的层覆盖以下内容：</p><p><strong>最后</strong>，USD提供了一些场景图级别的功能，可以极大地扩展可编码为USD的数据集的类型和规模。最突出的两个是本机素数实例化，用于非常紧凑地编码（和处理）大量参考资产或素数的实例/副本，适用于不需要深度编辑副本的情况。和Value Clips，它们允许一组素数的timeSamples散布在许多文件中，并且进行无损（重新）排序和重新定时。</p><h3 id="USD不能做什么"><a href="#USD不能做什么" class="headerlink" title="USD不能做什么"></a>USD不能做什么</h3><ul><li><strong>没有GUIDSUSD</strong><br>使用文本的分层名称空间来标识其数据，这意味着它是“名称空间路径”，通过这些名称绑定将覆盖绑定到其定义的素数/属性。因此，当引用资产的内部名称空间发生更改时，先前记录在引用资产中的更高级别的覆盖将下降。解决此问题的一种方法是通过“全局唯一标识符”（GUID）识别数据，然后将替代与与定义的原语相同的GUID关联。在解决名称空间编辑问题时，GUID将其他问题引入到管道中，并可能限制合成的灵活性。在过去的USD迭代中，Pixar在模型/资产粒度上使用了一种GUID形式，在仔细权衡了利弊之后，偶尔进行“名称空间修复”操作的成本超过了一个集合资产的价值值得为资产构造和聚合的简便性以及我们从名称空间路径中获得的可读的ascii资产表示形式作为标识符而付出。</li><li><strong>不是执行或操纵系统</strong><br>USD提供了一个轻量级的，优化的场景图，以方便创作和高效提取组成的场景描述。但是，除了提供名称空间层次结构和属性值解析的组成之外，它没有提供其他行为，并且在低内存占用空间，较高延迟数据访问和高内存占用空间，低延迟数据访问，USD的场景图倾斜之间进行权衡前者则更多，而高性能执行引擎则需要后者。<br>此外，USD添加更多的操纵行为和执行语义，因此，DCC之间成功交换数据将变得更加困难，因为目前供应商之间对于这些行为的含义尚未达成广泛共识。USD及其模式生成工具应适合于在特定应用程序或自定义管道中用于往返绑定数据的编码绑定，并且USD确实提供了客户端可以用来在UsdStage之上构建更广泛的内存中缓存的功能。提供对以USD编码的数据的低延迟访问。但就目前而言，这些主要指令中并未发挥重要作用：在3D内容创建管道中，DCC之间的几何数据和着色数据的可伸缩交换。</li></ul><h2 id="USD的使用"><a href="#USD的使用" class="headerlink" title="USD的使用"></a>USD的使用</h2><h3 id="在Windows中编译USD"><a href="#在Windows中编译USD" class="headerlink" title="在Windows中编译USD"></a>在Windows中编译USD</h3><p>如果直接去下载到的USD其实是未编译的文件，需要自己动手编译，编译 USD是非常难折腾的，各种各样的报错永不断。那么需要做以下准备</p><h4 id="编译所需环境"><a href="#编译所需环境" class="headerlink" title="编译所需环境"></a>编译所需环境</h4><ul><li><strong>Git的安装</strong><br>如果您不熟悉Git，最简单的方法之一就是使用GitHub Desktop GUI。</li><li>确保网络正常，编译USD的时候需要下载各种依赖。</li><li>Python2.7<br>注意：<br>提示：您可能需要手动将Python Scripts目录添加到系统路径。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C：\ Python27 \ Scripts</span><br><span class="line">并且检查</span><br><span class="line">C：\ Python27；C：\ Python27 \ Scripts，并修复由于某些原因而不存在的路径。</span><br></pre></td></tr></table></figure><p>需要的安装库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 可能不需要</span><br><span class="line">pip install PySide</span><br><span class="line">// USDView必需</span><br><span class="line">pip install pyd</span><br><span class="line">// 否则将不会设置USD_GENSCHEMA。如果您打算构建Autodesk（以前是Animal Logic）的Maya_USD插件，则需要此工具</span><br><span class="line">pip install pyopengl</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>-<span class="built_in">zip</span></span><br><span class="line">下载安装：https://www<span class="number">.7</span>-<span class="built_in">zip</span>.org/download.html</span><br><span class="line">添加系统环境变量，默认是：C:\Programs Files\<span class="number">7</span>-Zip</span><br><span class="line">Cmake</span><br><span class="line">下载安装：https://cmake.org/download/</span><br><span class="line">安装的时候选择对所有用户添加system path</span><br><span class="line">NASM</span><br><span class="line">下载安装：https://www.nasm.us/</span><br><span class="line">管理员权限启动安装程序</span><br><span class="line">添加系统环境变量，默认是：C:\Program Files\NASM</span><br><span class="line">Microsoft Visual Studio <span class="number">2017</span></span><br><span class="line">下载安装：https://visualstudio.microsoft.com/vs/community/</span><br><span class="line"></span><br><span class="line">下载Visual Studio社区。 </span><br><span class="line">用构建USD的build_usd.py脚本不支持VS2019。为此，您将需要VS <span class="number">2017</span>。</span><br><span class="line">可以在这里找到较旧的版本：https : //visualstudio.microsoft.com/vs/older-downloads/</span><br><span class="line"></span><br><span class="line">安装组件要选择“develop <span class="keyword">for</span> desktop C++”</span><br><span class="line">Microsoft Visual Studio Code和AL扩展</span><br><span class="line">下载安装：https://code.visualstudio.com/download</span><br><span class="line">安装内置的Extension，直接搜索USD和Python，选择靠前的扩展安装即可</span><br></pre></td></tr></table></figure><p><strong>用git命令获取USD源码</strong>：<a href="https://github.com/PixarAnimationStudios/USD">https://github.com/PixarAnimationStudios/USD</a><br>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/PixarAnimationStudios/USD</span><br></pre></td></tr></table></figure><p>或者点击：选择“ 克隆”或“下载”。保证路径不要有英文意外的其他字符。</p><h4 id="准备编译"><a href="#准备编译" class="headerlink" title="准备编译"></a>准备编译</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">运行开始菜单&gt; Visual Studio 2017&gt; VS 2017的x64本机工具命令提示符</span><br><span class="line">您必须使用本机工具命令提示符-标准命令提示符将不允许您从命令行使用MSVC进行构建。</span><br><span class="line">验证您的工具：</span><br><span class="line">输入“ cl ”-您应该会看到优化编译器的使用说明</span><br><span class="line">输入“ 7z ”-您应该会看到7-Zip使用说明</span><br><span class="line">输入“ python ”-应该启动python 2.7。键入exit（）退出。</span><br><span class="line">如果您的计算机上同时装有Python 2和Python 3，请键入“ py -2 ”。</span><br><span class="line">键入“ cmake ”-应显示CMake使用说明</span><br><span class="line">输入“ nasm ”-NASM应该抱怨未指定输入文件</span><br></pre></td></tr></table></figure><p>测试程序包，如果全部命令都成功，可以进行下一步<br>进入刚刚克隆下来的USD包。<br><code>python build_scripts \ build_usd.py“ C：\ USD”</code></p><ul><li>如果计划使用Autodesk的maya_usd插件，则需要确保您的USD版本包括Boost库，并且不生成Pixar的Maya USD插件。在您的build命令中添加boost参数，并使用-no-maya开关，如下所示：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python build_usd.py --build-args boost，“-with-date_time --with-thread --with-system --with-filesystem” --no-maya“ C：\ USD”</span><br></pre></td></tr></table></figure><ul><li>如果需要明确指定要使用python 2运行构建脚本，请使用py -2而不是python。该脚本不会在python 3下运行。</li><li>最后的参数是您想要安装USD二进制文件的位置。如果需要，您可以在此处指定其他位置。</li></ul><h5 id="编译失败的可能性"><a href="#编译失败的可能性" class="headerlink" title="编译失败的可能性"></a>编译失败的可能性</h5><ul><li>确认您是通过“管理员权限启动命令提示符 ”而不是普通命令行运行的。</li><li>确认您已安装VS 2017，并且您正在运行与其关联的本机工具命令提示符</li><li>类似于以下的错误表明您缺少必需的VS安装：</li><li><code>cmake -DCMAKE_INSTALL_PREFIX=&quot;C:\USD&quot; -DCMAKE_PREFIX_PATH=&quot;C:\USD&quot; -DCMAKE_BUILD_TYPE=Release -G &quot;Visual Studio 15 2017 Win64&quot; &quot;C:\USD\src\zlib-1.2.11&quot;</code></li><li>*</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CMake Error at CMakeLists.txt:4 (project):  </span><br><span class="line">Generator    </span><br><span class="line">Visual Studio 15 2017 Win64  </span><br><span class="line">could not find any instance of Visual Studio.</span><br></pre></td></tr></table></figure><ul><li>如果安装成功按照提示添加环境变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">按照安装输出末尾的提示，将PYTHONPATH变量添加到系统变量中。</span><br><span class="line">如果您将USD安装到C：\ USD，则此路径将为C：\ USD \ lib \ python</span><br><span class="line">按照说明将C：\ USD \ bin和C：\ USD \ lib添加到系统路径。</span><br><span class="line">当然，如果您在其他地方安装，则这些路径将有所不同。</span><br></pre></td></tr></table></figure><h4 id="编译完成测试"><a href="#编译完成测试" class="headerlink" title="编译完成测试"></a>编译完成测试</h4><p>编译完成包的结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lib\python，是整个USD开发包调包的地方</span><br><span class="line">bin，包含了一些pixar官方提供的命令行程序</span><br><span class="line">lib，是运行时需要的一些静态库和动态库</span><br></pre></td></tr></table></figure><p>在命令行输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usdview .\extras\usd\tutorials\convertingLayerFormats\Sphere.usd</span><br></pre></td></tr></table></figure><p>如果显示如下：表示整个过程成功。</p><p><img src="/Users/xinhuoliaoyuan/Library/Application Support/typora-user-images/image-20220220224244091.png" alt=""></p><h3 id="如何使用已经编译好的USD"><a href="#如何使用已经编译好的USD" class="headerlink" title="如何使用已经编译好的USD"></a>如何使用已经编译好的USD</h3><p>使用编译好的模型是比较省事的，可以使用NVIDIA编译好的，地址为：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image-20220220224517271.png" alt=""></p><h3 id="usdView的使用"><a href="#usdView的使用" class="headerlink" title="usdView的使用"></a>usdView的使用</h3><p>打开这个工具后，列表视图叫PrimView，usd视口也叫StageView，通过继承自QOpenGL.QGLWidget集成到Qt界面里的。<br>并且整个界面UI是用Qt编写的，官方也提供了完整的源代码，可以根据自己的工作流去扩展或者魔改它，它也支持插件的扩展功能，官方也给了示例。</p><p><strong>PrimView视图</strong></p><p>PrimView视图里面是多个usd文件合成，这个列表中的每个prim都有着各自对应的prim type类型，比如：Xform，Camera等等。<br>点击下方的？，会出现一个新的面板。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image-20220220224600167.png" alt=""></p><ul><li>并且对每一个类别进行了说明：<br>Normal 通常节点，最普通的一种节点。<br>HasArcs 当前的节点含有某种合成器，只要父节点有合成机制，那么对应的子节点也会同时起作用<br>Instance 实例节点，表示是一个实例对象。<br>Master 被实例节点引用的节点，表示实例的原始模型<br>加粗的字体是某个usd文件里显式定义了该节点，<br>斜体字表示usd文件里用over关键字修饰的节点，没有实际内容，是个空节点，也叫Orphaned Over，空覆盖不加字体粗细样式的是抽象节点，被定义了class关键字，比较少见。</li><li><strong>PropertyView</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image-20220220224631003.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image-20220220224649876.png" alt=""></p><p>上面的每个prim节点选择，都会显示不同的信息。我们可以把下面这些信息看作是上述选择节点的属性列表。这个列表包含了各种各样的信息，数值，名称，类型。</p><ul><li><strong>其他视图</strong></li></ul><p><img src="/Users/xinhuoliaoyuan/Library/Application Support/typora-user-images/image-20220220224736533.png" alt=""></p><ul><li><p>Value 选中一个对象，点击，右下角的数字value面板就会有对应的点位置数值</p></li><li><p>Meta Data 显示的是每个prim节点或者属性的元数据。</p></li><li><p>layer stack和composition是用来表示当前节点的usd文件，可以通过查看layer stack来直观的看到所有的合成，元数据等。</p></li><li><p><strong>Interpreter</strong><br>点击window 下面选Interpreter 会弹出新的窗口。</p></li></ul><p>  这个是它提供的的一个usdviewApi的模块接口，状态显示，选择功能等等<br>  usdviewApi的方式遍历场景和prim节点，通用的函数如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image-20220220224808213.png" alt=""></p><h2 id="USD在各DCC软件中的用法概述"><a href="#USD在各DCC软件中的用法概述" class="headerlink" title="USD在各DCC软件中的用法概述"></a>USD在各DCC软件中的用法概述</h2><h3 id="在maya中的运用"><a href="#在maya中的运用" class="headerlink" title="在maya中的运用"></a>在maya中的运用</h3><p>如果要在maya中使用USD，需要获得Autodesk（以前称为Animal Logic）Maya-USD插件,<br>可以从Autodesk的Maya-USD GitHub软件仓库获取源代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/Autodesk/maya-usd</span><br></pre></td></tr></table></figure><p>然后在命令行运行，一定要在vs2017的窗口中去运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python build.py --generator Ninja --build-args=-DCMAKE_MAKE_PROGRAM=ninja.exe --maya-location &quot;C:\Program Files\Autodesk\maya2020&quot; --pxrusd-location c:\USD --devkit-location c:\devkitBase_maya2020 C:\USD_WorkSpace --build-args=&quot;-DPXR_STRICT_BUILD_MODE=OFF“</span><br></pre></td></tr></table></figure><p>如果编译失败，可能的原因：<br>可以去这里看，或者提问：<br><code>https://github.com/Autodesk/maya-usd/blob/fix_import_module_macosx/doc/build.md</code></p><h3 id="USD在Unreal中使用"><a href="#USD在Unreal中使用" class="headerlink" title="USD在Unreal中使用"></a>USD在Unreal中使用</h3><p>设置虚幻引擎4以导入和导出USD。从4.22开始，此功能是实验性的，需要一些手动处理。需要在<br>并启用USD Importer插件和Python编辑器脚本插件。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image-20220220225201501.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image-20220220224934473.png" alt=""></p><p>重启UE4<br>然后点击导入，我们会发现已经支持usd的导入了。 </p><p> <img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image-20220220225008659.png" alt=""></p><h3 id="在houdini中的运用"><a href="#在houdini中的运用" class="headerlink" title="在houdini中的运用"></a>在houdini中的运用</h3><p>Houdini18的Solaris算是目前功能最全的了。实现了USD的绝大部分的功能，这个的版本变化比较大，引入了这个新的流程。<br>在houdini中使用的是Solaris，是18新加入的一个新的模块，也就是houdini为USD所提供的工具支持的统称。</p><h4 id="Solaris介绍"><a href="#Solaris介绍" class="headerlink" title="Solaris介绍"></a>Solaris介绍</h4><ul><li>Solaris模块在houdini中的主要工作层级是Lop(Light operator)</li><li>场景图树中的模型层次结构可能</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image-20220220225319216.png" alt=""></p><ul><li>在 Lop层级中，Stage指代的是当前正在操作的整个场景，很多术语是对Usd的简化包装。</li></ul><p>houdini中的Solaris。是按照USD的逻辑来布局的。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image-20220220225408868.png" alt=""></p><h3 id="在Nuke中的运用"><a href="#在Nuke中的运用" class="headerlink" title="在Nuke中的运用"></a>在Nuke中的运用</h3><p>只能在Nuke12最新版本中使用，并且功能也是非常少，也是在一个实验阶段的。<br>使用方式和其他导入方式是一样的，直接用ReadGeo导入即可。<br>参数也是非常少。</p><h3 id="在katana中的运用"><a href="#在katana中的运用" class="headerlink" title="在katana中的运用"></a>在katana中的运用</h3><p>要在katana中使用USD，需要设置环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1PATH=KATANA_ROOT/plugins/Resources/Usd/lib KATANA_RESOURCES=KATANA_ROOT/plugins/Resources/Usd/plugin</span><br></pre></td></tr></table></figure><p>可以保存一个bat文件来启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rem -------- USD Specific ------------</span><br><span class="line">set &quot;KATANA_ROOT=C:\Program Files\Katana3.5v2&quot; </span><br><span class="line">set &quot;PATH=C:\Program Files\Katana3.5v2\bin&quot;</span><br><span class="line">set &quot;PATH=%PATH%;%KATANA_ROOT%/plugins/Resources/Usd/lib&quot;</span><br><span class="line">set &quot;KATANA_RESOURCES=%KATANA_RESOURCES%;%KATANA_ROOT%/plugins/Resources/Usd/plugin&quot;</span><br><span class="line">rem -------- Start KATANA ------------</span><br><span class="line">&quot;%KATANA_ROOT%\bin\katanaBin.exe&quot;</span><br></pre></td></tr></table></figure><p>目前还是在实验阶段，目前官方提供的USD插件还过于简单，只能完成加载文件。在没有TD的情况下，很难体验到它有先进和爽快感。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>总结一下优点吧：</li></ul><p>1.它的结构是树状的分层描述整个场景的数据，管理灵活并且比较自由。让整个场景的结构能做到很清晰。<br>2.它的分层功能，主要是组织数据，每一个曾所做的事情，都会对你的结果造成影响，如果不要这层，可以去掉。类似于ps的图层管理。通过这种层和层之间的合成机制，实现了非破坏性的编辑。不会影响到其他环节的数据。<br>3.USD组织文件的形式，是使用了多层嵌套的引用机制，实现了轻量化的存储。带入数据的时候，效率应该是非常高的。<br>4.基于Hydra渲染的架构，可以对大规模的网格场景进行比较高效的去预览。然后可以通过不同渲染的代理，进行渲染切换。能快速的看到最终渲染近似的效果。</p><ul><li>来就目前来看一些比较致命的缺陷了：</li></ul><p>目前比较全的功能就是houdinil了，可以完全实现基于USD的从资产到装配到灯光渲染的整个过程。<br>在其他软件的进度来看，要在不借助TD开发的环境下，想最接近的体验USD的生产流程，简单的选择就是使用Houdini18的Solaris来完模型资产发布，动画及特效完成后再由Solaris输出各层的USD文件并与场景其它内容合并发布最终场景USD，Lookdev部分则交由Katana完成，最后Katana加载由Solaris发布最终场景文件来进行材质装配和布光渲染的工作。<br>USD对Hydra这个GPU渲染构架支持（需要等商业软件跟进），只能完成预览工作，第三方渲染器跟进的速度也比较缓慢。<br>还有就是对数据来源有明确的责任分工和技术手段保证落实。对资产的制作和管理会有更高的要求。如果有些概念在现有的流程中没有，引入USD时的改造，目前的情况还是非常曲折。。。</p><h2 id="参考文献和其他连接"><a href="#参考文献和其他连接" class="headerlink" title="参考文献和其他连接"></a>参考文献和其他连接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">编译完成的USD库：https://developer.nvidia.com/usd</span><br><span class="line">USD预览文档：https://graphics.pixar.com/usd/overview.html</span><br><span class="line">mayaUSD插件：https://github.com/Autodesk/maya-usd</span><br><span class="line">USD的开发API：http://graphics.pixar.com/usd/docs/api/index.html</span><br><span class="line">USD源码库：https://github.com/PixarAnimationStudios/USD</span><br><span class="line">Solaris介绍：ttps://www.sidefx.com/products/houdini/solaris/</span><br><span class="line">本文翻译自《Siggraph 2019 USD Introduction and Overview》：ttps://zhuanlan.zhihu.com/p/97710961</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近做了些AR/VR的1内容，学了不少三维数据的结构，本节介绍一下USD，由于相关内容相对比较多，一次性的把近期的学习都总结在这里，所以文章相对比较长，本来想分开弄，但他们的关联性比较强，就合并了。并且不会涉及太多的开发相关内容，仅仅是简单的介绍。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Siggraph" scheme="http://yuanquanquan.top/tags/Siggraph/"/>
    
  </entry>
  
  <entry>
    <title>Low-latency Speculative Inference On Distributed Multi-modal Data Streams</title>
    <link href="http://yuanquanquan.top/2022/20220113/"/>
    <id>http://yuanquanquan.top/2022/20220113/</id>
    <published>2022-01-13T08:06:23.000Z</published>
    <updated>2022-01-13T08:22:51.858Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文介绍MobiSys 2021年的文章《Low-latency Speculative Inference On Distributed Multi-modal Data Streams》。多模态数据流（multi-modal data streams）在在分布式传感任务中很常见，常用的场景有人物跟踪、行为识别以及音频和视频分析等。考虑到不同模态数据之间高度的异构性，不同模态的数据传输速度是不一致的，因而较慢的数据流会显著地降低整个系统的推理性能和准确率。为此，该篇文章提出推测式推理来自动调节和适应多模态数据流中传输速度不一致的问题。与已有工作阻塞式推理的有所不同，该文章会根据残缺不完整的数据，推测生成一个完整的数据，并根据此生成的数据进行推断。同时，该文章提供一个回滚机制，用以确定是否可以接受利用不完整数据得到的推理结果。当在不接受结果时，回滚机制会等到足够多的数据到达时在做推理，以保证结果的正确性。实验显示该篇文章提出的方法，与最新的六个基准工作相比，能够在保证准确率不变的情况下，7-128倍的降低推断延迟</p></blockquote><span id="more"></span>  <div class="row">    <embed src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding/Hyperspectral/3458864.3467884.pdf" width="100%" height="550" type="application/pdf"></div><p>​        目前物联网设备上配有大量低功耗但数据丰富的传感器（如相机、麦克风、激光雷达、高光谱成像仪和射频成像仪）。这些传感器可以提供多种大量连续的数据用以进行复杂环境下的推理。这类多模态数据流的推理可以显著地提升语音识别、健康检测、增强现实和自动驾驶等任务的准确率。尽管有这么多的好处，多模态推理面临着多个数据流之间不同步，甚至是数据缺失的问题，具体带来三个挑战：(1) 多模态数据往往是不同维度的，差别较大（比如：音频和视频），因而很难通过某个模态的数据流去恢复或创建其他缺失的数据流。(2) 需要设计一个简单高效的回滚机制，既要保证尽可能地少进行回滚，又要保证回滚本身的开销较小。(3) 多个模态数据流之间存在时间漂移问题，即很多传感器设备由于缺少时钟同步，进而造成时间戳不准的现象。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220113160818753" alt="系统workflow"></p><p>​        为了解决上述问题，该文作者提出了推测式推理的方法予以解决。如图1所示，具体包含三个部分：数据对齐模块、数据填补模块和回滚模块。多模态数据首先经过数据对齐模块，将不同模态间的数据时间戳对齐，然后数据填补模块会根据某个模态的数据流生成缺失模态的数据，并将生成的数据和原始的数据一并输入到多模态学习模型中。如果得到的结果是可以相信的，那么直接输出，否则回滚模块进行处理，得到最终的正确数据。接下来本文将详细展开这三部分的详细实现。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220113160841622" alt="多模态推理过程"></p><p><strong>数据填补模块</strong></p><p>该文发现，直接用某个模态的数据流去生成另外一个模态的数据是十分困难的，同时也需要大量的训练开销。为此该文调研了多模态数据进行推断的方法，如图2所示。不同模态的数据首先经过各自的特征向量提取层，得到各自的feature map，然后将这些feature map拼接在一起经过后续的处理层，得到最终的输出。基于调研结果，该文提出基于某个模态的数据流去生成另一个模态的feature map的方法，既能保证生成的feature map准确，又能保证训练和生成过程的开销比较小，具体如图3所示。该文使用生成对抗网络（GAN）进行训练，训练时设置生成器和辨别器两个部分，生成器用于生成缺失数据流的feature map，辨别器用于区分生成的feature map和真实数据生成的feature map。生成器和辨别器相互对抗最后得到一个能够生成缺失数据流feature map的模型。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220113160907237" alt="数据填补模型训练图"></p><p><strong>回滚模块</strong></p><p>该文发现不同类别的数据对某个模态数据的缺失的反应是不同的，比如“under”这个词仅通过唇语就能识别，而“allegations”却很难。针对这一现象，该文对所有待识别的数据做了分类，获得了每一个类别的数据要想准确预测出正确结果所需要的最少模态数据信息。基于这个信息设置回滚模块，当推测时已有的数据大于最少模态数据信息时，就不回滚；否则反之。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220113160935523" alt="数据对齐示例"></p><p><strong>数据对齐模块</strong></p><p>该文发现，当两个模态的不同时刻的数据得到的推理结果具有最小的“距离”，那么这两个来自不同模态的时刻，实际上是一致的。图4给出了4个例子，画红圈的地方表示最小距离的时刻，也就是两个模态数据流时间偏移的距离。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220113162245436" alt="在模拟Trace上的准确率和延迟上的分析"></p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220113161043432" alt="在真实Trace上的准确率和延迟上的分析"></p><p>本文所提出的工作在一个带有Xeon E5-2620 v3 2.40 GHz CPU和两个GTX-1080Ti GPU的32 GB RAM边缘服务器上实现的。并与阻塞算法（Blocking mechanism）、自适应码率算法（ABS）、周期分析法（Periodic profiling）、一次分析方法（One-time profiling）和帧采样算法（frame sampling）在语音识别数据集（LRW）、事件检测数据集（AVE）和活动识别数据集（STISEN）进行了比较，对比结果如图5和6所示。在模拟Trace上显示，该文提出的方法能够降低2-128倍的延迟，并提高1%-25%的准确率。在真实Trace上显示，该文提出的方法能够在延迟上与自动码率和帧采样算法类似，但却能得到和分析与阻塞算法一样的准确率，达到了同时降低延迟，并提升准确率的目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文介绍MobiSys 2021年的文章《Low-latency Speculative Inference On Distributed Multi-modal Data Streams》。多模态数据流（multi-modal data streams）在在分布式传感任务中很常见，常用的场景有人物跟踪、行为识别以及音频和视频分析等。考虑到不同模态数据之间高度的异构性，不同模态的数据传输速度是不一致的，因而较慢的数据流会显著地降低整个系统的推理性能和准确率。为此，该篇文章提出推测式推理来自动调节和适应多模态数据流中传输速度不一致的问题。与已有工作阻塞式推理的有所不同，该文章会根据残缺不完整的数据，推测生成一个完整的数据，并根据此生成的数据进行推断。同时，该文章提供一个回滚机制，用以确定是否可以接受利用不完整数据得到的推理结果。当在不接受结果时，回滚机制会等到足够多的数据到达时在做推理，以保证结果的正确性。实验显示该篇文章提出的方法，与最新的六个基准工作相比，能够在保证准确率不变的情况下，7-128倍的降低推断延迟&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://yuanquanquan.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="论文笔记" scheme="http://yuanquanquan.top/categories/%E7%AC%94%E8%AE%B0/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Altium Designer 21版本初体验</title>
    <link href="http://yuanquanquan.top/2022/2022112/"/>
    <id>http://yuanquanquan.top/2022/2022112/</id>
    <published>2022-01-12T15:18:31.000Z</published>
    <updated>2022-01-13T07:38:45.656Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>AD21截止到今天，一共做了9个较大的版本更新，几乎每个月都会有一次。当然可能是由于更新的太快了，Bug也比较多，很多更新不到两周就会出一个Hot Fix的版本，本文盘点下AD21到底增加了哪些新的功能。</p></blockquote><span id="more"></span>  <p><strong>新的线长调制模式</strong></p><p>引入了新的Trombone（长号）和Sawtooth（锯齿）调整模式，并对Accordion（手风琴）模式进行了改进。现在一共支持三种调制模式：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220112232058666" alt=""></p><p>Sawtooth（锯齿）模式：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220112232121054" alt=""></p><p>Trombone（长号）模式：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220113153838290" alt=""></p><p>相比早期的版本，AD18之后的线长调制功能有了相当大的改进，使调等长更灵活、更方便。客观的讲，AD的调线长功能已经完全不输于Allegro或者Pads。但对于高速设计而言，AD仍有不少需要改进的地方，比如更完善的规则设定（目前AD不支持虚拟T点，在某些拓扑结构中，调整起来还是比较麻烦）；比如任意角度的差分对及圆弧走线，AD还不够灵活。</p><p><strong>原理图功能的改进</strong></p><p><em>原理图页自动标号</em></p><p>支持对同一工程下所有的原理图添加序号，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220112232240353" alt=""></p><p>具体如何操作呢？只要打开Project Options对话框，在Options页面的General栏中勾选“Automatic Sheet Numbering”。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220112232300263" alt=""></p><p>这个功能可以让图纸的逻辑结构更清晰，便于快速定位。结合之后的Cross Reference交叉探查功能，可以让Port跳转定位更清晰。</p><p><em>网络(Net)名称识别</em></p><p>当鼠标悬浮在某根导线上方时，会显示当前网络(Net)的逻辑名称和物理名称：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220112232325969" alt=""></p><p>所谓逻辑名称通常用于层级结构中，表示一个有逻辑意义的网络名称，通常会通过Net Label、Port或Sheet Entry的名称来表示；所谓物理名称，就是实际的网表中分配的名字，典型的物料名称定义为器件位号+管脚号，如NetC2_2。在非层次结构的项目中，两者大部分情况下是一致的。</p><p>这个功能也可以用来判断导线是否与器件管脚正常连接。</p><p><em>全局高亮指定网络</em></p><p>对某个网络点击Alt+鼠标左键，可以在整个项目的原理图中高亮该网络。</p><p>所谓逻辑名称通常用于层级结构中，表示一个有逻辑意义的网络名称，通常会通过Net Label、Port或Sheet Entry的名称来表示；所谓物理名称，就是实际的网表中分配的名字，典型的物料名称定义为器件位号+管脚号，如NetC2_2。在非层次结构的项目中，两者大部分情况下是一致的。</p><p>这个功能也可以用来判断导线是否与器件管脚正常连接。</p><p><em>全局高亮指定网络</em></p><p>对某个网络点击Alt+鼠标左键，可以在整个项目的原理图中高亮该网络。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image-20220112232438397.png" alt=""></p><p>这个和在Navigator面板里选择网络感觉差不多，多了一个快捷键，聊胜于无吧。</p><p><em>为导线(Wire)对象增加了属性</em></p><p>Wire不再是简单的图形对象，现在可以为Wire增加变量属性了：包括用户自定义变量、规则、网络类等都可以包含在Wire变量中。</p><p>下图是将信号完整性规则置于Wire中的一个实例：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220112232543706" alt=""></p><p>说实话不知道这功能有啥用，因为很少会用AD做仿真或者SI。倒是线束管理可能会用到一些自定义的属性。官方文档说之后还会在该功能基础上继续进行开发，让我们拭目以待吧</p><p><strong>新的PCB设计规则编辑器</strong></p><p>这应该说是AD21最大的一个变化之一。现在的规则编辑器，不仅可以用原来的对话框模式，还支持新的文档编辑模式，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220112232652189" alt=""></p><p>以上这个界面，是不是有点熟悉…? 和下面这个是不是有点像？</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220112232705715" alt=""></p><p>模式和Allegro的Constrain Manager几乎一样，当然使用方法和内容还是有很大区别的。两种工具都使用过的小伙伴都知道，AD的规则一直是由规则对象驱动的，即先确定规则，然后把需要满足规则的设计对象填充进去；而Allegro则不同，是设计对象驱动的，即先找到需要定义规则的设计对象，然后再设置约束。举个简单的例子，定义5V网络的Width宽度规则，AD的做法是先找到Width规则，然后用Query查询语句InNet(‘5V’)定位到5V网络，然后才能定义最小、最大线宽；而Allegro是需要先在CM的Net类目先找5V的网络，然后直接设定最小、最大线宽即可。</p><p>就设计而言，Allegro的CM的设定显然更加严谨。但这次AD的更新，明显模糊了两者的区别，让AD的用户也多了一种可能更为合理的选择。</p><p>使用这种基于设计对象的方式，可以非常方便的看到应用于某个设计对象的规则，而这在以前的AD规则编辑器中是完全做不到的。</p><p>下图为电源类Power应用的规则：包含热焊盘连接方式及过孔类型两类规则。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220112232816499" alt=""></p><p>下图为在同一界面中编辑差分对的线宽规则及过孔规则：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220112232840359" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220112232934182" alt=""></p><p>打开Properties属性面板，可以随时对某个设计对象添加额外的规则：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/npicj28A7dDMaMkpOpbBjl9IBwXG6BwyqNUwJccX7HibtRicraWC4zPw0adVpgiaewLMOhgCqPmpJtHribiaceVSnxSQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></p><p>AD的图形化示意模式无疑让用户对设计规则的使用方法有更直观的了解，这点比Allegro更人性化。</p><p>更有意思的是，AD21支持传统模式和文档模式之间的切换，也就是说用户可以随意在两种模式下定义规则，切换时AD会自动进行规则格式的转换… 总觉得这种转换可能会存在逻辑上的问题… </p><p><strong>在电源层上使用多边形铺铜</strong></p><p>大家都知道，AD的内电层（Plane层）默认定义为负片，即创建的Plane层默认都是铜箔。如果在Plane层上放一个矩形对象，就相当于把这块铜皮镂空；如果用线条围成一个闭合的多边形，就相当于完成了平面的分割：可以为围住的区域定义一个不同的电源网络，而线宽就是这个两个不同电源之间的间隙。这么做的目的是为了使数据存储的效率更高（因为内电层大部分都是铜箔）。然而这么做也会带来一些问题：内电层上相同网络的部分被视为一个整体，只能修改平面对其他电气对象（如过孔）的间距和连接方式，却无法对其形状进行编辑，有可能在平面层上出现铜岛、窄颈或死铜的情况。</p><p>新版本的AD21允许将内电层平面做为多边形铺铜(Polygon)处理。切割平面的操作与之前完全一样，唯一的区别是内电层平面现在可以进行独立的Polygon Repour操作，这样就可以人为的进行设置，避免死铜的出现：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220113151924979" alt=""></p><p>如何使用这一新功能呢？首先要在右上角打开小齿轮Preference，然后在System的General也点击Advance按钮，并在高级设置中勾选PCB.SplitPlanes.Routing。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220113151947242" alt=""></p><p>该选项默认是不勾选的，即按原来的方式处理内电层。</p><p>使用该功能请注意以下事项：</p><ul><li>启用该选项后，查看每个平面层，用配置好的Polygon选项重新铺铜平面多边形，以适应您的设计需要。</li><li>平面层的连接和间隙由PlaneConnect和PlaneClearance设计规则定义。</li><li>当修改了一个平面（连接或间隙）设计规则后，在每个平面层上至少重新铺铜一个多边形，以更新该层的连接/间隙。</li><li>在一个平面层上进行的编辑，如修改分割线的位置，会导致该平面层上的多边形自动重新铺铜。</li></ul><p>​    又一个细节的改进，虽然用到的概率不大，但如果真的碰到要求较高的设计，也多了一种解决问题的方法。但是该方法仍无法解决内电层中走线的特殊需求。如果需要在内电层中走信号线，还请使用信号层（Signal Layer）。</p><p><strong>区域（Region）和铺铜（Polygon）的端点</strong></p><p>Region和Polygon对象的属性中列出了外形端点的坐标：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220113152049867" alt=""></p><p>这些端点坐标可以复制到Excel中进行编辑，然后再粘贴回来。这一功能对于需要精确控制铺铜或区域外形的场合适用。</p><p>聊胜于无的功能。</p><p><strong>任意角度的拼版阵列</strong></p><p>支持任意角度的拼版阵列（Embedded Board Arrays）:</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220113152122250" alt=""></p><p>聊胜于无的功能。怎么拼版一般丢给板厂</p><p><strong>在PCB上放置一个矩形</strong></p><p>这是一个非常简单但千呼万唤始出来的功能… 以前要画一个矩形的板框只能依次画4根Track；如何需要做圆角或者倒角那更是痛苦万分。现在，这一切都成了过去。</p><p>在PCB的Place菜单中，可以直接进行矩形图形的摆放：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220113152212807" alt=""></p><p>双击矩形，可以对其转角模式进行编辑。</p><p>下图分别是一个圆角的矩形和带倒角的矩形，倒角和圆角的尺寸都可以设置：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220113152252704" alt=""></p><p><strong>在PCB上摆放一个图片</strong></p><p>以前如果需要在丝印层上放置一个比较复杂的Logo或者图形，只能使用脚本。</p><p>AD21支持了一种更简单粗暴的方法，点击菜单<strong>Place » Graphics</strong> ,就可以直接将JPG、BMP、PNG或SVG格式的图形放置在你的PCB上。</p><p>下图是我刚在丝印层上放置的图片</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220113152319677" alt=""></p><p><strong>在3D视图中包含非电气层及机械层</strong></p><p>AD21支持在3D模式中显示机械层以及丝印、阻焊等非电气层的信息。</p><p>操作方式：首先点击L，打开View Configuration。</p><p>将View Options栏中，将3D Setting设置为By Layer:</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220113152341316" alt=""></p><p>然后就可以在Layer &amp; Colors栏中，用小眼睛控制每一层在3D中的可见性了：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220113152354043" alt=""></p><p>从另一个维度欣赏您的PCB吧：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20220113152407260" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;AD21截止到今天，一共做了9个较大的版本更新，几乎每个月都会有一次。当然可能是由于更新的太快了，Bug也比较多，很多更新不到两周就会出一个Hot Fix的版本，本文盘点下AD21到底增加了哪些新的功能。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常技术" scheme="http://yuanquanquan.top/categories/%E6%97%A5%E5%B8%B8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="硬件学习" scheme="http://yuanquanquan.top/categories/%E6%97%A5%E5%B8%B8%E6%8A%80%E6%9C%AF/%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="单片机" scheme="http://yuanquanquan.top/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>vn.py-下载回测数据</title>
    <link href="http://yuanquanquan.top/2021/2021130/"/>
    <id>http://yuanquanquan.top/2021/2021130/</id>
    <published>2021-11-30T12:38:30.000Z</published>
    <updated>2021-12-16T18:09:38.007Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据库的配置</p><p>下载数据</p><ul><li><p>方式1：程序下载</p></li><li><p>方式2：直接导入</p></li></ul><p>对于写好的策略，使用历史数据回测何其重要。记录下怎么导入回测用的数据</p></blockquote><span id="more"></span><h2 id="数据库的配置"><a href="#数据库的配置" class="headerlink" title="数据库的配置"></a>数据库的配置</h2><p>至于<code>MongoDB</code>的安装，这里不多介绍，网上资料比较多。</p><ul><li>创建表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createUser(&#123; user: &quot;vnpy&quot;, pwd: &quot;123456&quot;, roles: [&#123; role: &quot;readWrite&quot;, db: &quot;vnpy&quot; &#125;] &#125;)</span><br></pre></td></tr></table></figure><ul><li>修改配置文件</li></ul><blockquote><p>Mac系统的配置文件路径 <code>~/.vntrader/vt_setting.json</code>,  和window系统不一样，注意一下。（账号，密码自己指定）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;database.driver&quot;: &quot;mongodb&quot;,</span><br><span class="line">  &quot;database.database&quot;: &quot;vnpy&quot;,</span><br><span class="line">  &quot;database.host&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">  &quot;database.port&quot;: 27017,</span><br><span class="line">  &quot;database.user&quot;: &quot;root&quot;,</span><br><span class="line">  &quot;database.password&quot;: &quot;123456&quot;,</span><br><span class="line">  &quot;database.authentication_source&quot;:&quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下载数据"><a href="#下载数据" class="headerlink" title="下载数据"></a>下载数据</h2><h3 id="方式1：程序下载"><a href="#方式1：程序下载" class="headerlink" title="方式1：程序下载"></a>方式1：程序下载</h3><blockquote><p>当然也可以通过图像界面的方式下载</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 初始化事件引擎</span><br><span class="line">event_engine = EventEngine()</span><br><span class="line"># 初始化主引擎</span><br><span class="line">main_engine = MainEngine(event_engine)</span><br><span class="line"></span><br><span class="line"># 加载币安现货的网关, 现货代码(小写)：btcusdt</span><br><span class="line">main_engine.add_gateway(BinanceGateway)</span><br><span class="line">main_engine.connect(binance_settings, &quot;BINANCE&quot;)</span><br><span class="line"></span><br><span class="line"># 加载币安合约的网关</span><br><span class="line">main_engine.add_gateway(BinancesGateway)</span><br><span class="line">main_engine.connect(binances_settings, &quot;BINANCES&quot;)</span><br><span class="line"></span><br><span class="line">main_engine.init_engines()</span><br><span class="line">sleep(15)</span><br><span class="line">engine = ManagerEngine(main_engine, event_engine)</span><br><span class="line"></span><br><span class="line"># 合约代码(大写)：BTCUSDT， 周期(Interval.MINUTE,Interval.HOUR,Interval.DAILY)</span><br><span class="line"># engine.download_bar_data(&quot;BTCUSDT&quot;, Exchange.BINANCE, Interval.MINUTE, datetime(2016, 1, 1))</span><br><span class="line"></span><br><span class="line"># 现货代码(小写)：btcusdt, 周期(Interval.MINUTE,Interval.HOUR,Interval.DAILY)</span><br><span class="line">engine.download_bar_data(&quot;bnbusdt&quot;, Exchange.BINANCE, Interval.HOUR, datetime(2016, 1, 1))</span><br><span class="line">main_engine.close()</span><br></pre></td></tr></table></figure><h3 id="方式2：直接导入"><a href="#方式2：直接导入" class="headerlink" title="方式2：直接导入"></a>方式2：直接导入</h3><p>我把自己下载的数据，总数<strong>8022246</strong>条数据已经导出，通过<code>mongorestore</code>直接导入到<code>MongoDB</code>,省时省力。</p><blockquote><p>数据如下，还是比较全的，小写的是现货，大写的是合约</p></blockquote><table><thead><tr><th style="text-align:left">Symbol</th><th style="text-align:left">Interval</th><th style="text-align:left">time区间</th><th style="text-align:left">数据量</th></tr></thead><tbody><tr><td style="text-align:left">btcusdt</td><td style="text-align:left">1m</td><td style="text-align:left">2017-08-17 ~2021-07-13</td><td style="text-align:left">2044721</td></tr><tr><td style="text-align:left">btcusdt</td><td style="text-align:left">1h</td><td style="text-align:left">2017-08-17 ~ 2021-07-15</td><td style="text-align:left">34154</td></tr><tr><td style="text-align:left">btcusdt</td><td style="text-align:left">d</td><td style="text-align:left">2017-08-17 ~ 2021-07-15</td><td style="text-align:left">1429</td></tr><tr><td style="text-align:left">ethusdt</td><td style="text-align:left">1m</td><td style="text-align:left">2017-08-17 ~ 2021-07-15</td><td style="text-align:left">2047718</td></tr><tr><td style="text-align:left">ethusdt</td><td style="text-align:left">1h</td><td style="text-align:left">2017-08-17 ~ 2021-07-15</td><td style="text-align:left">34154</td></tr><tr><td style="text-align:left">bnbusdt</td><td style="text-align:left">1m</td><td style="text-align:left">2017-11-06~2021-07-15</td><td style="text-align:left">1931504</td></tr><tr><td style="text-align:left">bnbusdt</td><td style="text-align:left">1h</td><td style="text-align:left">2017-11-06~2021-07-15</td><td style="text-align:left">32218</td></tr><tr><td style="text-align:left">bnbusdt</td><td style="text-align:left">d</td><td style="text-align:left">2017-11-06~2021-07-15</td><td style="text-align:left">1348</td></tr><tr><td style="text-align:left">ltcusdt</td><td style="text-align:left">1h</td><td style="text-align:left">2017-12-13~2021-07-15</td><td style="text-align:left">31330</td></tr><tr><td style="text-align:left">ltcusdt</td><td style="text-align:left">d</td><td style="text-align:left">2017-12-13~2021-07-15</td><td style="text-align:left">1311</td></tr><tr><td style="text-align:left">ETHUSDT</td><td style="text-align:left">1m</td><td style="text-align:left">2019-11-27 ~  2021-07-15</td><td style="text-align:left">857942</td></tr><tr><td style="text-align:left">ETHUSDT</td><td style="text-align:left">1h</td><td style="text-align:left">2019-11-27 ~ 2021-07-15</td><td style="text-align:left">14300</td></tr><tr><td style="text-align:left">ETHUSDT</td><td style="text-align:left">d</td><td style="text-align:left">2019-11-27 ~ 2021-07-15</td><td style="text-align:left">597</td></tr><tr><td style="text-align:left">BTCUSDT</td><td style="text-align:left">d</td><td style="text-align:left">2019-09-08 ~ 2021-07-15</td><td style="text-align:left">677</td></tr><tr><td style="text-align:left">BTCUSDT</td><td style="text-align:left">1h</td><td style="text-align:left">2019-09-09 ~ 2021-07-15</td><td style="text-align:left">16212</td></tr><tr><td style="text-align:left">BTCUSDT</td><td style="text-align:left">1m</td><td style="text-align:left">2019-09-09 ~ 2021-07-15</td><td style="text-align:left">972631</td></tr></tbody></table><blockquote><p>这里特别注意：如果自己原有的库<code>db_bar_data</code>,<code>db_bar_overview</code>中有重要数据,下面导入的方式就要注意，用的是<code>--drop</code>模式，有删库的风险</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongorestore -h 127.0.0.1 --port 27017 -uvnpy -p 123456 -d vnpy --drop ./vnpy</span><br></pre></td></tr></table></figure><ul><li><code>-h</code> 地址</li><li><code>-u</code> 数据库账号名（没有可省略）</li><li><code>-p</code> 数据库账号密码（没有可省略）</li><li><code>-d</code> 数据库名</li><li><code>--drop</code>:  <strong>在导入之前删除每个集合</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2021-07-15T16:39:06.524+0800 [*#######################.] vnpy.db_bar_data 1.59GB/1.63GB (97.7%)*</span><br><span class="line">2021-07-15T16:39:09.525+0800 [*#######################.] vnpy.db_bar_data 1.60GB/1.63GB (98.4%)*</span><br><span class="line">2021-07-15T16:39:12.524+0800 [*#######################.] vnpy.db_bar_data 1.61GB/1.63GB (99.1%)*</span><br><span class="line">2021-07-15T16:39:15.525+0800 [*#######################.] vnpy.db_bar_data 1.63GB/1.63GB (99.9%)*</span><br><span class="line">2021-07-15T16:39:16.020+0800 [*########################] vnpy.db_bar_data 1.63GB/1.63GB (100.0%)*</span><br><span class="line">2021-07-15T16:39:16.020+0800 restoring indexes for collection vnpy.db_bar_data from metadata</span><br><span class="line">2021-07-15T16:39:43.859+0800 finished restoring vnpy.db_bar_data (8022246 documents, 0 failures)</span><br><span class="line">2021-07-15T16:39:43.860+0800 8022262 document(s) restored successfully. 0 document(s) failed to restore.</span><br></pre></td></tr></table></figure><p>系统已经有了，数据也有了，后面的文章主要介绍一些经典的量化策略。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/20211217020238.png" alt=""></p><h2 id="图像界面方式回测"><a href="#图像界面方式回测" class="headerlink" title="图像界面方式回测"></a>图像界面方式回测</h2><p>启动<code>run_window.py</code>文件，即可启动图像界面回测。启动成功后，整个界面如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python run_window.py</span><br></pre></td></tr></table></figure><p><a href="https://camo.githubusercontent.com/959c3e43cf8cb155574d394ee960f3a97b73e2def82339b0615cea3cb3bb9e85/68747470733a2f2f692e6c6f6c692e6e65742f323032312f30352f32352f4e4a5966653858545663684d6e61642e706e67"><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/68747470733a2f2f692e6c6f6c692e6e65742f323032312f30352f32352f4e4a5966653858545663684d6e61642e706e67.png" alt=""></a></p><p>图像界面回测结果如下 <img src="https://camo.githubusercontent.com/f0fc6d4dfbd7d596f78d8d520a03b70d8e25357b0701bb925b854f12aa49c758/68747470733a2f2f692e6c6f6c692e6e65742f323032312f30352f32352f796d6733385a75466369595268786e2e706e67" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;数据库的配置&lt;/p&gt;
&lt;p&gt;下载数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;方式1：程序下载&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;方式2：直接导入&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于写好的策略，使用历史数据回测何其重要。记录下怎么导入回测用的数据&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="量化" scheme="http://yuanquanquan.top/tags/%E9%87%8F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>白鹭量化面试题</title>
    <link href="http://yuanquanquan.top/2021/202111301/"/>
    <id>http://yuanquanquan.top/2021/202111301/</id>
    <published>2021-11-30T09:23:16.000Z</published>
    <updated>2021-11-30T09:57:27.197Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="您好, 这里需要密码." /><label>您好, 这里需要密码.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="d76237745e4126bcf2e2bf3da7ecc98f1ce2f3e96503320cc0c27043adaee90b">f4db63e78dc90c84cb3acfbd41d260e6ec82a80acc2c0a2225596206c4876a8ff5de9cdd769670facb95c85588ab14017cf458dd18e7b8b5e5896311a164b4d809b1f9bb4a6ac16b04173b54cca88df93aeb7e5dec46bbb4dac7fdbddad5ee14ea11f7f002d93ea20264070ba7866f5faec0f296893606649602e1c79345252298872c7664e025e51ced225169df9eecb0454468698c730e68cd2cdecb59a1670524fc9044714a7f45f37810f03aca1930543f50c96ad696d84896a890b8c497e4129f343f02f5266f7c7485d902c1ba84d2896b51e2db6d473e43aa2250e227718c2289f1c82194c2e293bd106de82e4ec4132cc99f193de14efd7eda10a45dd6383a7b6ecaaa1323d511956f3a1e56e62d80009d7e377f063e5c1f0fbf7ded05eab0a42a98e2d5460c8873c4355b2a977bbba024d4dcf4767eea1b4287ddef522a437ac4429613731808fbf8e57ca3cdffb849d4978a319956cf568cac9dde97167f393a17cdcd652536f88f21e249aaf85dff1d1598b418b68ad1c45b43b8bcd24ac709ad2c899cd5af4ebf02ee9118b20cad89a818f9f3cbfebb067ab18d8d727c24c642c97e329d12d3497040b274097cbc751b509771dbb37f7f4a141f73a29ea0cf29999b68a4aa91a8fa8965cd235d0c1a5d4ebc6c78ea47342efff1fc660acda91e93d4a2b8c359ac6a20074989c90514130b8f074bcacb0c7fd9af60a980a3a173dd3f5a08573261c847235de140342c4fbb7d09f10a3910796229a86bc6905beefbb8bf265cc6fdc3f249cbd780dd17799949e428be61ed59360c99bf1e502b3216b2c1d78d64bee1d1375e9634dc22fd5377df343c88f4fdd68f643e70533ed505ce938e494fd9f1d5644741f6b4b5f7b4f61db9177bcedb47c06ad46f3f58b030d16c5720422b55fd7b08d1470a04a5e14d2cffbd3f22651729f193ad1fa53a1f1f0a6127a7cf9378a00bd430af933e086cd3237fc7c5e3db73d45fe2f4b6121442921e4bf82e55b555ac77394c1fdb1e2b9fc9677e2ce29a391682953c1ebb9791439acc488734417fd4fe7f2bfa043999a497a3e306613574b4529bc09d682421f23301a5c4614e4211068a5429a356977611730d035f8c0cce30b9ad027b58d59cde8670cbe2688ca9509b508d864fdf6592b5e4940d450e4b29ef61cdc1414342d8ba1cda884a23b8ebd9fd3b31446709aecba765e0dd5acae7dee944c11e1a73d26ab2e20e679e3542ca22f70bed0033cf8881f338195782698f4962401c300b4311691618fa4c2ff199d1e7c70c7c4429dd9bf613dc9bdfb3c815a60632285c192bfbcf90e53ef1fff308c9b5420e0baf10661c1ae5531d2b83fee4ffab47de49e274304e96d7c53125fc14fc83df0d837543ebb042de8d36c5b49222afc50f8e6a84e0fcc99d768db5a6f75230193da20c9e3d19f85b9219c4c011ef5fbe6c38e279d5145ae5967fd6fb7cd6fd8a1073cedfdaaeccfc921711f2a07c5837f8db6fa3bd2f7324364b3578f75539f9560f8ce0019c0d910fa864ce1076c2202f7fc284d5f5d4bbefe876d00f7d7ea89857dd0102b2e9355964aaf609fd4ca0271828982457c4465c6a31eeb707e34db5a1348653ac04fc1a71fa11bc597aae4d8ae710f5507d9d8f72bc15ac7d5510970876e5116bd244a8e14c0304fa008a1a72034af0a694653751f6da78da0a41274a6f5fba7517a19d8726692751478976e4074af5ecfb1629a87b5139af3d117c2644ce360eed8caff8bfc3323435308d52a66b4db8c5cbf0df26b93c1332ccc282e60641f191284be78d7433d92142361237d45fbc0954da734d9f4487b4c80527567d47e98cfd25d2b6d8513107928e559af72bc633284ec6a2f9aa5081e26f454a6a47d3867a0f935933f183eb13da1efe42ff75518a7119df03a72beacdc420a55986735ea3d3de4db3f330254d310fa76b9f8448694bb23e91a7bae89bb1d507500d0080f9888e3be11e9f59980ca87e675db22fff7b054eaf171b0cbea463858d091729a84e10fc8cc2b7178f413419799344e0f944f3fe0139e19ca3c3ba94a4acc37cf538f35419e32599c71234807165fc056821ad191aed1ab4ee3a729ee25ee79003dbf12f827928102234c68329778e9bde60ddaa089ef2c161a903b6e8cb0ca5d76cc8219fb46613c59561e63b3e3e0b7971d0205188d3ea37657c8e183a4e34928735eef39cd701c21bcd31451779d9cca9a945ed3423f728b0116cb38ec761fd56a0fc0e4720f1e6277df55e4e9cde89dce4c175227c3ebac0f1087b828232b864d9c8f4f6e138e0e1cf96b30d1c19122c9e3690553148578087516450423adaffce5a3e7a6ef3e6d4c240f76840a6e392fd3f4021ebbd9c7c2a67fa78b6d20043b3e905c69cd6ddb4d524f85ffde694ca261110752e392dbcc25c0ec25e5a3fafc02acc3bea0a07fa67e1009fb11b6744fefa3c2488eeab88a5b601caea07a467d58540889ee75f2fb6a9e99d496a0018137ec8e813e24a972afcd1f8244ff0406c6ee68c70a3ef766e2c07844fb5260ca7bf4fa11596cf647188c7e059c1d48325cfd5b3b48074ebbebdb8d02cfd4407e652ed11f3daa7888ce7996ff7251ac6be51bc0326da40ab8de5956419d0487830fb607d7f9121188a2e8d7270da467dbaff5e18f3520601a2799dfc7b6a366aeaeb3983dc230d51bda27477ea17d981abfa6c5d3b8ba9a185c0d2cfb7b18fe936576133719dd6362baebd8057bea6e2c699ece55373dec9e5334f054151e0918d1cb94e6813aa014486e74ef1da159e55b8e753ec665f81e5117397a2dfb3e2cda1b381b250d84df75bf2723f858b3b44d2128933633bceb85169f6db4b974014279dad55e2b7d8b5c7c82646c64ac7581524eb153b90fb8813de30030d152303e1bb6764d1d0eefc03751e9840fc98c20b497dd07ca8ea0d20322b677f99e2165e58fe289cf91cbc961bf1e6a08f8a74e28ecc58e1adfddbc77830128557b8c5adec349d0579e0d89e80ac9a678ea5278ce2c912b0d9806765f9afdab79aadf458704994c7992d91e9988442d7742cf15a2cb05320782f0b3987d112c2e526d5a748776067cf353574a9c89494bf683824a6d92426f1f8dbc48e72fc02a4a4054bb6aaa928f698064dc74654fc909d6488061b1a164d1514aa20855cfa3fe74993cf54494795302d05b940a0ed5b8e0a4173416335497288568f081eb39c4428df5358f614b1f52756c3c4714061543452c4da168aadc4d07b15cea6783d3406368c658773ab61815d6a4516d7b1e8124f18b10aab09b7a51d0553ac883d230e84f5898e767f898610aeedeaa47662916f7879a2138ef29e8621a1dca6cdce8a87930dcdaa0c809433037d4db239ecbc145816820759fecbdd16f9492c82c079f3260f5ffba81f9f2880a3d5568edb14252b608283eb67b995e01c5cfd3eafdefc7312e90adbe7ddef019e86965a9996c4839274e15e541eeb89276a55e3a781548df3fa9c0eef7d63c125262437c425bc84e7170c955e3667bc409a3eddb7e39e00831de0bd9b1b89a252e9c2b9d3307b63a3e6e307528ae67dc207d28db7d20d777973ea1a0e6e173db8b63bd5eb47b29c0ff5e86796cd02766b79c76bffd171e2b149774dd7782e71fa70394f4b499544f84af6b18691ecf28c932b63a1596d2465ee59cefad24da3d262961c4ed49be5abd637ae33d8d3772e168d8d513ad4c2ad03d3f493e0e7f2bd657766880054ce8b345db67ce6559a6ddcb35f7a4e9a131b42c328cba1b5c33f8a0dc99067ed802db8aa718f076260bfe05fe9c59c3930bbba8a3e69729c0ac40587199f3c2fb04fb238486cb1456fe3d278740861ed7316d4c28df04a5e3e6a9e2ad98c57627ff83ea8e67db7cf1fbb07614f6fa20c6a8e7da2fc85715d477c33d945dc0cb5927d01c61405ac4bb3ae2a062e6d5cbcae7d8d6ee57909370511308dcc87dd2336f9eaee02fee7b59edf8c14a71db529efad7d81b1c30e079e69d446384f08282d413e066954d5a18dbd7cbcc00f296c9a9b883d4caaef067c62d008fcf107df51b5eebb2b9bcf9de5364b5c7822af7cfffcca019bacbc3aee58baf442ae147b34fc8286359062c4d8e134cbe42d55068fe2baa76d2cf10b3c1f07ec169a7a9a2f517a67cd6881983c4ffe24bb7719d6ba47a65b811c0f75fb7853157df22580098b055f7039dcbf33b6e6caed82fa065ae8d90bd0d44d9ba11625ba780a2d94445bbad497528f5f31c22094e687ad7f0444ea6d23b2aaa9a0ec511811cca8814629bd985a103690abc50c77ed2eb5ed83819e5e1e67b46ca04ce3d9849578061bd18a057403832f242774759c59577d3f8a76fb320c259e3a71f8a8e67fa3441ec56b3941451b1f410e8c46f274480645fb5f9c68226f756f18babf3cadd483fae8749b61cb1616d6555da74f7f717bbf5c9d2ca7012cde866fbb75f70a52fad49780589cf211ce5bf7c9e9955b728d8f8e5a8de26e2660ebf6accd04fa6d5d16a040e859b4f35e6635d95208456cae3c3a198c75fc9f0d09eab437b97977edabb45f7fce5168853f55716275f3e238a2ccf9d28fd90c979c53cf272af33e85a329497f09ca7ef46fed509fee47c56721873aebcab5d41b2febade8855727118b08e34eaf68ceceae911dfe57c217c80c037f91ab763cc6656b6cf3f95866a9330ff9988ff0cd8c4fe9c8d0045b6d83ef87501408162efd0059b733d2f5534e9513d8f8a476977858135cd0496b655f1d953a94a707c28d9d3f6d2fef353aee0bc5627e0e416dfd499af11ee3c53f9f002a9e75402da8e14302251bbc17d19c16a83d97fd681793903112eb4a741c585c7359be6ed73464f663b2cadb9e031cd21f0dd2a04f9c61714b9a294ae6c497c008818bcb29faf73c7f5cf1aa2ba51d100dce529509113f6a2bc5fe4bd28959138aa4f2987535a4c57934d1657b0442fbd1384be96c4b911c1e13a6a138055abe10d781b08b5ae85b02a62fe08fe37b40305f3cf3cc581205cb00355e367ee8aa81b40afeb3a25a1b2478acfacb48dec4d7b6c90f1b741c96756769de6b1c4736bee084121ae7f37beba12b41fb1b063dca3c2780567aafb1e0003d7febb0774007e0494577b2c2b792d631410f99b0c5a533e91a75f10cf955a457d0f9d1d793eeb49a137095e130f6e4391028bdab4fd4418d04136d346c3d406145c4280770e1ba7edab43048c78c74b3410508cc0efe4554896b69d2584075043a333971221eb01329f8beb01c2700c14bc97a68032c68f78d43504e80c29315d88e5f7929e7d6a82d4fe3ee2dd5a4a8d2b36fe5b8342c05bcef7ca4701d5541b9476e2ff4da5e674a5e83be98a9600fb490010cc7d18e1806b0e016700152db22b42f0a22b8386b0084ef2ac16639e3ad1faa1a9f151d619f5fa5affc5d10f7d09a3709809e07165305aefefc46aa669ad01fa6e7b5b7d94ea367896290430917bdd2d5e0d7027d06ba6f15050881d713032a6890de32f7938b5bb8d2a071578bfe51db633520e148dfbcb9f133187e251ce036ec8e72731a9829cf0bbb2b88907a56e32cb435819c16cde73ee6947ddd848cd92bfd915aa1f10ab4d766b89e12e5cb0b8044f314a9a0b4558cb8dcfbc612ded0ab761583da769361efaa061726d45e53b3d35bc76b202f818bbb40856f4512c9c71ee45eb54b1f99c1cfc5f6cb18a4677baca8c4a2a2a75c7c2187b4717a779e8959ee908447eab0f4696701a43d9eda8c37aaabc9960c204c55ec589dd19e780386aa877f5a61cf8aff02dae5b869b321cbea7dd967dfd9d8e2651a0e0afbe2ae01c649051454585511268562d94cc8471fed249d8ed14994fdd5d88c4eb4643b8b45bce9a49b4814393f1017f8ee16d49b9808b9a80484bdd63a3504ec16d56ffd384f8f80bc98ce7a45a3660d5f96049df431b7d3d25fc9e178f340c05ef6d527d96f1fd50d8de99fed0fcb9e087fb04ccbb84db99032ad7f94da37f5af50d58a8272f51e77c8084ea43d20e09ca053ed92b9049fc68d8d5c29d74b806e04d8e6147bb74401016ac6265c633236d862b09c75b87f2873a57de63b3512c660cdb27bd83bd5b7d1b888e2d74e084e8e237040ab216e104750b8d919f9bfa93524cd9f78d1f0f4df9cd2a7055fb251801566955d87881242148ce282f9ce4ce8f699f598f0b06831762b8243e89867aca2d1056183aec5c1c256ceddce704eb6746374e787b1c7bbedad0cf941bc4c68906662f118c5113625bc5c2c3adea0b628e9067bd0b514349056f2a75a215192410836d941f688bc73eadcea8fd87263424e984e116a66701ddb6eb4daf8d1e82b16d7d03d0c1f734418b71ab4d855aa5a71d9b87fd1bdbf5dad1a9562da2e948fa8bcdd6477517f6b0a18cc2e5cd22a0795c3f049e05dd8f56364a3ad511db3a08f3374a46b999cd85970a31e4dfdaa10bf37a9a0b1f8a38027509ea0b50e6033a87172920c30466429616f2eb4a9e4ebec0a5a39027036b9266158ef65d47e7dac925d111e9bc4a4917b8d42155f6592999b04ee6146e10a112180fbce72c2350ab14ce28261244af4f0d478186c9c6b42f95ad61c75fd407a522313d8b040d77c2dbaca65d08596ca0c871966ca059fb93a36c1cbcded596d1cac174f367b599ddecc154319c6fc8d6a43cbc500d29fa78f7503301a2f896f844db88b0e96ac6d33b858f90a701bbecca303611a3f79001ec1df1f3daaefdcf2cc2f12e5f2248f42c4791e84933319c99b3f0fff8daf0c932ca4b99dfb61585f7e86620e674d2eec7d61657ac8001216ad7e8e0230c038dc59606131916748004816c46891fe6301fde24d7762644d1f14030ddfef976161b6d5b8bd04a3c1ff1063c0f4debbaed79ae1e3d6079d7feed0e5cd5f63634eff294ccf38e4bc59edc734643ccf302e9733e593e32d688f5987f9165717691442a0be893cdd9ebb06855afa3fc5c861b98bc25c3c7fb73a1ae312b117138afbd66eb2d31131158b059f8b3c76df361cf5ae4231145e4c7508d366ffe904b15ce65cf04a2c5a6da8afba622316b8ca3c3f85780c328f2eb285e1e7a0537bc08c8666df464a47c52849b00144f7cff9a75279123b082446c692650f638fa5d6fe607730282fad6058bb1180cab595965ef1adca04759e2e9c909a6ff0b61fdc0828bc07177a41c667a21463e12f9500aa2099ab5981c94bb21091d3b886d22dce9da0805d1b637e10a153156ed4327d8290348f2d6b553e04365bfdd2ea6c6446280f3ae8a13ffd30944bff67ecc744b41f75f6c8351cdef67ad8ca1d649eccda09a5b92a239574f0e22afad250d1b5a8c8a4db361598ed56ac415dfdcbda293c2b45e4539b4858ad8c5c413c4119fe080a07284fb0f5d22d7a1213f50736dee2f6a3dc97e7f2ab7f12e2b2701457a1d2ae9902c233227f795b56dca00413ac92af5d8039f042a8b37b9b08a360664950d60ab1c9ef954d0bd571ea17b8b917b1463b326a6b28259eee93ae2c19de05f0d4fd412f8a23b7335a92169863e3e9418e7086a7209121046decb232366eeab04524115817d2ecdfdd2601675d3e6427e24ae1a5a8acbe0dd91ffd962e975cb7713f15aaf22b533b5a7e8f2d0a790988d33d05c3ce8411d5f6e4bde5b15176a6a895104608dd13bad0eeaa1ef1672153be6790ae9cd6648e46fa9201c571a4e19c364e5f1f99e72a84019dda64fc2484a602d275d3c9746a3872ae50d4150088926da5e1276b671b6ee62ae78da53a6e4c6c6d482e6058cd4bc3bd37f5de4a80521ee0759e662f342fbfbce5c569ed466398ce7d6de1d123b1425433958267306c5fcffcf50f15201d3a4a218b3af9e2a7ba678b6f00d070ba1a185225223fe5a15f12590f00b595cb4699b28b7d2b14e98c14be6099343fadccd3788cafe7b46cfd0b1b840c3e2fa2b44b97275298e3540ff0fdc97e614b37ea50f254381bb0510ee997b8a0b7e4878f357525c8791a8bf4b9923337585f82d60f495f35447ba71e17c151a3e078f10ed7ffcf8157bd349e5792eadc1d4f40ef0bd7c13b682cc30904f8b9363cca692725f0926faafcefe6a9a5ac338981b16d2bbf937927df9222cfcf763b325d32e0310ec5d13ac665569576b5cad48f9b96bf177cd7c0161970e45035e0b9ec34bf2e39422591c17935c66fbb4d2b73b720b591451d9743163e59e3fbf3299381baa95c2d1a625c9da0d8bae84ea9e95bc64c5ea440e418efe6ea4dd8d9fa5e6dff471feb5934f11b89d8135b52692b1c5ebf0a9e6284c96d3acea29dc602734641c3dc2892ce34ef4db679475e214c6016f692e36c2f71b82f8858865e979b3ea568e69dda5ecfc2f1e32eda07dbc22607b6492681446b0cd57c4141439cc03271154f8aa020645d47f3160de22c5553cbc0b3bcab93af5485d217742b78d57ecaa45ebcfdff0b1d8ad77d23bd8f15a647b7481a159804ee123a86c88b748b61009a4cbab170d277ea13148d500fa2250b26b43c7123c7d7fb5f29b74c2e9029ec5c8076293b066f49f1d3d762e91c3b2e4e4a363531bfa785d75ac4ac74ae7403ab0bd27cd9ecdccdf3d751a6c7d9830f44197dc4f961dbd06c681830df0c235f86f8b4510dfd7c7c811dd8d3ee362e0c28e9c95fe15354ac277c87724db55c16cf39c4bd458a9732638c66db39f2e6a8620022903cd4ddac7bafa7e215d21546f630c5e1ff4dc6f1e9c5b31858b7075f7bcc3703ee2ef32815dd0743aaf34305728564474e0729c7a140e14a148d9b42ab014cd5d8c2b74a5f762a17ca1ab3128deda7c672f1d17a51f93f31296bf0f7f323dc7eed370db5e4ef8b38e6f460354dbba2cbe58349263029bd5e52560adf3a36b460b239baabb5e2d8601bf891ebeb82a7acc961193ded08ed5372589aaae1faa471475175e16d8b32a4789fd0712d69692880c5feaa2514492da093e69e99cd3f7bdebe5c482583743e8f97b331ba2b61ea8bd73b82e1d1e9be38e28d5b65275e93758447b36e1994d6862bbb221e5132e31e7d34bc11e58b01c90919a78570117ca0ecf4969314b3bae4415cab10fcc33dc1a5339cfcc7a221df47ef661b4fa67c9e6613d6c725093ec3a7838c60153ab54fb0e3d49c0f1468f3988894a59ba7bf1187c9a68191d8edaefda71212a62ee466e79ee6c521a8b9761e893a998d86e2c0a1f12dca33656c0d9f7fa1f94afabe83bff5f55442df6f62c7e24ec96cf19ceaca1dab704d4c6e943ccd670fbd10e1ea385aefe7c9884ea5bf5f6cf8023fc1771d0108cc1e9a2e0ee0bd4f46a3d81a4fad514939a82154db393a853c31aa94adb7f0db61c405fd8d2ebbe7f789ce1b813700ef1de00c45cfbb3dc5cc83fc8f8b58d1e0a67766a82b9cd8abda62f246c7939b70ae0f3251c0fefb15832d80fffe007070134221413db20b6239f7f2d1bb571a56b412782469f46459a618197e3df22fae57b2991f10e0ab9bfe1fdb2c04e824f1e3211273261a5c4a461d25301d29d62a9b7a4fbfcde088383cbfbdd6641216130f559feea2bca106de80e5368b1b05daf291098b9d8bca290b717e0e67dc51bd44429267d0b401de5d8ad35de74c29994e6e63776ad6b61678b39ae1f5410ffd4d4441b99aea3773621471985a6244dbdd583010c93fd42373e76f557469d92c7ba32b60914991039c9f07cd29c7635596c4d28cdd23d32be27f36f3c1b712ab3bf53b38b70698df861d3a847f1e8162bfc93fc679507430a265d817a9284dfc083d34f7073af8ca5ebbd06a7da48ca22c3c4d826903dbd27a09c611be9061e7b1f0139ceb1c804502b909ceb13f5b3a8115fd759c38f50d2fdb9c7977b8ff4a5ef9865360e7e92d65451a4aa1aa810f52c74469bc9fd30ac5ea641dcda98118d588ae731fbcb822c93ec1159defc1337e2927167bc26baba4e7d8f03a06627258c3bf7afb1ac46637b33cd09d9657c3adb29e98baed7efe0918655e6f94eac93dded9e19fb9de3159efb8f6c2f53cc66f15068f715e25de3ad66fe3e36ea09c2898ff9b9cef9a77c7b31e89d9ce16c1b38e23046cbc2bb6eac3f9a45a08d107380c88b990a8a1c0b6e4ba3077c050d7fd974023e97cec4e0ae55a31fc5d601434faec7415109efcc3a8db72aa0f6c1a94938e3348f2d275e3006c1485bf69fbf8f3cac6819934eed2d3601c40bade3593518bae6ed8d9ddee0d0f3b32d0277d7f2996c917da5d8197f516ccc0c8677dc6affda461708909fb6a8c322b7be367fa133166b705a132a01dc8136006b035f7528fa05071888ddbbaa7f290fa386ecedddafe24da91ec58648ab70c83675ab9983e4003d3b5f6312d1caf3f868b6c27da228b083b76e75bf1c877375356856b6fa7fbbd65819e616656e97983dea6f17e9ea15ce4d9b032c81aa6b2ac95bdc4c9fdadc5cdd35427c43e94f0e1f34396a34c1cbf95785ba5ceb4e6fd049017ab9f0266d8aea6f6ae2dfbf6efc17c4a29d64a41b3e4634aab7bd761214aa36e39106fa0e67efc0dc0979b48671bbf4a88e2fd474bc5c7c4b9e57cf0ac5032c0fb43953fa24e50f387cdd17795c5e61cc1e0a079819d348fd5dc9a9104ea9ffbfbbf1da088ddfdd42b7daaa2dffe13f6d7cdf70b72c643fc81475793d1b4a11f5b59c29e281b5f89d1692f80767f62579bb695d88a5de8b93081b1e6d6b6b0223796889e45357def80f05fce3667605dfe2d8eb89890db09e40dde08d2e7a511636e0329c57e9de9ca8ca086d4527636a08e77189a0a7f5acc2a779c42eb31a8d25b95782a427787c60c0799fc4aec8365b4cc2fb02b10f817dcbba580bd27823cba9fbd2012eadcd6ae673f95023a186778b4167acef0a46ec21e5b87d9a64659680c92594578d6d0601ff4082d6300b302176507393fbd7e80fd5aaaf5a98949bc44ed70468004896d670ee4c2d6ff125f20a5b6049303c6e6ae281929870227a2f5683e3d4771b95370e1413d13c1b41b5087d42ffe142d7ac7f03e1259fdde587aba36a58253e20fbd6e8e3f0d48d060f107edf593fb607967da14b020e9bfeb4253861838404bf78036ad960ad04ed02a43045771f2b87bb65cd810cae0936dc419a5325ec5f048b72f1494e81dfdbc212ab6e5121c7cc3b38fdef17a1398fb6a5b5579805bfc8a6ee5a70fefbb38030b5b4ca4558541407f1d1c509afb9f4ef68dd1809717b72287e7d50a243f99d799a52da1dac34f72d5574ef08ee419afde0b1e312e5f6793ab4c7073c7be27b458250487df57e7c2706800445be0156b15488e51770760f43ce9b3974ad65b2984e942af81a8bbf8e1ee82a404e5c30c50e37ccabeededd434725f913630ca68f91d48e8b68a4a4ac7984f6b469369749c6e9c50b429785ee93c2d4e3173a926ec6c3d606b541d6bd02f4085318e6673886e515eb3b0447283a28b699c87cb2a22d9f45276def3591347161912401bf9ae3e53569572c485dd0b937a440cb1b5b900dc2641c88a1bafcb585090ed9821e5c78f2b0dbcf84dad4848a8dae22e54552e0d9f869118e6b07929d57637636c93031c45e123a07a6c335bd28603f72d4beaafd498c0d4d7eb7f5e3150fef5e516ecaa95f265a7a9370449e29905f6d9c0ade8e5f4136511a29a036aa10df8ca059d8003af1a8da547f97a16636afc21c89df3c211e990ae2740ee163f11cdfc3bc7cc5c0a5470e246fdead8f512c90b9d66af9878987a292060d7b53e295508e45da443d7672f8b83ec780462cd025a219bf1ef9defcc1a96894420a23aa50548b97262d750730b0aa87297f459b44feb32e2bb3af851a9e0311ffa63b0a7e319b7487ca6f233544289c55725e2342cc1ae3a0a0f5c92c1e08df9325a764fdf38a6517d59cb3fee97cc0c5d65396229360f4342475a68b8ad9d55782b29dbcb88a3bfbcd95a9f40b5d9b471c2472b9eb911ea4e8bd454826c39066450c8552c773aece418f9950425d47677ce11b9eb51baf8b9a55d2657d0d531a034fdf34891e954c9868f6ff6eb9d047dae6233ea9bf6de0f90963555a53ca15665dd632134bc05d5be1c3fe75d256df3d9a46d0400dad57ae03b6f264f2d11f805ecffa10fdda7abdd1c3e43c7271cd30b1b05c45aa14b0eda3cfaa3a0f96dffda370e42b98e154d4cb6edde5f022f8356d347e892e5992c3661a439a2fa52caf0a3d0672b5fed267bcee6eda2ed7c74ea94d8d44e494510ac20cfc7038434d2809bd4ddfb8788ac682fd21bdc6bb00df6ecd8591b11dfc3b8c683ff033a4b6a49bd3235c752fe5a0375856c3b9571531e98ea5c6a026d2563c751e0064cf5b088a0b8425c8b2974aa5d85771d2a93b516fc29ca2cab41ca5ab1600b6ce5854e731138db6ad1ef0b03eae508d2b0c16cd43f6202a91a26d86e4385d8728058b670851ac7481f1ed72c6649b87c29a30fe12bf0bfcb200a49f0129bd6ce67706c6845254db58288ae8c86196117abc077f8cd7eb43c74f3e1188f654e1c4488e1f615a73ac9a70952ed8e8d8d8adeb68a9eae7537be4cc54553900ab5454e89c292580864624c5a2e2bb643b9aa83947e6f3d20c8af470fe1fd33a772739c9d64ce1c2fcb815a788e52ac1a4728a8c5d5898e8995c52a80bdb1c0b7b3b3459ac411be420d7c5af21f0596bcd0ff88fb62da9a5d2e1145fcc4184ee956f73ad35f9389fda57393c0ab2af071934de64cc95c12b7fbf69c2e88767d061dd6ae801b15b4632d5e6a55ea11f485ebfa39f7e1672516206204c011fa9c396e312aafd753bd68098871bee7988479da6078c457cd1dd2aab814748efc090df55b35e841e2f672e17a3e8223ba78771099320b35aa1287d73c42e5d206266b3bfb32b25098b606321f2d93bb45ebe25cd1369b1c4f43e23abd94c61276374cc89cf57991fa04a088759f16cd8ac8bf5de45c498e1593b73eeff5a359c171506c4e814041e48e9cb98f82b3ce92deccdbce25b8a08d999bebebe7aac38ceda152ad4166989a4feb7f9ba8e54ee799b2f3a6572625d860a9c080a4f9dea406a45850f3b055ec31c83efdd296ca3b470b709d5a7da0241a68226a10c18d0be5820a59c831c237c01adaa88b088db64f90d0d9587503b0cfb3941f92abcc8aeffc9f5cd1fc6fad5983055072f5c26c907caaf133f7f5d89f540147b859b2a4504f6c56316a6727213dda0e8835cf7bce532c461bd60276ca026cba512d8d1563bfedd1c12c7512fbc3df2d5106fdcf6ee92d0116b7de868aed801b4df5d88991b7236aeff50b61b149e994e0b47bb53cf4464c187c9fa59330eda91bc4bda7c862e62809c0cd69853f64a047c86aaca13dca3bc688a26027ce587480eebe37025c7547a7504ea1a7bd932e7416bc9c23df87b7a2e5c99ffc06c677db6a212e2ee6e71e1efd62f1d19d99f8c3bdb852c7932bc8e71bfc19ebecf9ee6a429ffb20c5dff5844ef130aece1a4b9786403374734f2064ca8c607d5846cdab8a59526d4a7d9d14181decd4713b47e3fccf81a306966aeb63fdfeb0f8316df62ec84c37ea95e8f8bdeead5ebc3f410c69c462bf72e780bda746f1ca81a8b70de83e7e669e3c36546142f36c7ecac0f60839bdc3929a70eaa2f6703b487ee8d233917fa0f18adda5ee35d53a73c14975984454e8d3b7cb0e3e33f25ca16e63e8bd2115510aeae506506331a0ea83cebb8d8408cbabd47c5e740e204f98a78e1b6c6decee60f2c19a952a7149635af56d2e112ccbf8288f1fcb828094695b5e3c7cbc6693ae7f0f3bf7bbb81f0ccd09b0d227be192caaf8749535ea7644af96f580c83f260a16ec7967ca11151938b4086952da1e0c7fbf1b2a1e403e67dd66fbc9747b2a1d84a6fdc74a4dc539a3903ba690c098e372cd21167eb95219a34b59d36ce7c99d6dccb62f3ac5fdd2b33a2bb097a178fabdddf42264680a3a634aea065327d6befba838277f410805248703ca32108c72d02e50707714e65bff5a247ca3bfb52909314ba75095a63d91779c2d6679310d51484685bdc2d50a8d2ee5bdabd81e960d6db4b6b14feab77236cc7628526fa44ae2c32f8f2675d466a4b1d552c36faed7b6911bcce05708cdb9b6e280a81a9606a99037d8d78f654d91f70c12bffa04ad59c5c24ad0fe34c0479576d7ef59890fdb4806657ad65b9c1cafaf60ef95bcf5cdd73bf3b59e17387bef8ad79cd3b0a1d6d753dbf78f338dcfb791a745ca767aba7da36cfb099fc535b2c0d603e3faaf240182dddf8d8e39f64a0a769c8bf96d4bf4d9b9eceab2fed97e9423b1b0341924099e33427ce9ac7489713c9df7a8ed7ec4348b2cdc9de98abc279b6bbefc0ce243405fd137eb45acdf52fb4af0b51b0e36ff863623f05753a1d285dbe4c9e25c7cf16755e9fae72a87a7dcf53eda40a210d23e84cb102d78781b6229d0cea8c6504422d19c750af89c19589efbaad16bc9735a184007c41c0f61f5bae38789c3c6ecf9c436932aa8f0514108666c1c78a9f920f75b54c8190369aa46c0f73192ff9dd027776b8764809e5474ad8f1256e0484f8e989b1b43c897748941ddd0c6b7408ed403ff7b8ce3e39755e0dd12d072b6f7bf12921111903dddeb45d7a32ebdbe038031d160aab01c8f2d8d34b2cf186d970cfb1873a7e74f067b25b1e436674783881c5babc335069a8b9681761d5bb23673d30f0e82b7918090b4f33c034b78f888338238e9b6928feb358a00e373c316853ac50b09df77ad960ac43a5ceef329741d1c99403d92ac9d534ac8c6ccb78b274845a2cbed7c76742684469b7b7e653267bc61910d136ccf4c71217c234ccd770a72ff33cabaa8b2b390c71eed67a03483733e6edd9a40f1ff393a9e926a537d4aaa51e8a379a7f1cd87a2d991d7ffecf41f3c040256e83a9a197f3faa9cf8ee9f6ee1c457adeefe3c14bebd765c9648d182ae20bddc6ebef13c5b3589394f4a4ebc94b128d11b19a89aba98687dd6df4783a8b41624c71dbda212c75cb35155c3ee8595037aeb03e9b2fbced71a4404d48590861a6e4379c2250109b89394458939166952809525c194d0a289ff8a6a44ab83ef0311f7e958b538b861f6d016ab5cd39a6edc177b60805f604799319fa12b372cab0e96897d1264a00ebee8b6ef64460b53e2437f3f625d901c40ee7fcbffeeab9dbd1f7a4b8c6197a6f64b044c1ed38505d2a323bcd5a3cd4ceaeabd8896e1ec3aa63edc859f41fd1ce7feea5640a7603f9d02e4b8e0c34bdfc8dd90ef4aca93cc16dee061a4432a24b3ade4b680cd3af0bdc03f8eae26fe14143f5c0195bebe6a87310e40ff2b14aa5ea4b9835c2ee2afbc3b97671b4acee1ee9e6d162a575af3e4ec4b7816c6494520c4ef9e8645d03468b866695ea8cbdd38f7c852f63fc7d975656738b30ce66799476eb782ac3953761c487f5ad622b8d22d31eda5f0de8de6afcf6055b1d811662f29f2d32f6333b8384bc1696c00e2820688b28df89bbed5772d738907aa0928fbe86f79e10e427e2c6da21bc0bd15cced93b971b09e2a8fb1eb380211218c64d6eb7bc74b5ba4242e8cd4d0054847fea47f1074f7d005fc93f4de6018009c5eb3167ad6343fcb552deef4acb87ddddd75624669c78e646d3d5111aa411b1341619e505b5c1a947e0c2ba64d30d1434adbb51e6b1444db55783feaa258bdeaa63fa710fe19b51a49dd4fa4bc5d54785e3d33dbe2060128d8a4e19d91b4aa3db6ffe228b73a0de19b5dff68ec4cf9b1e98274a2c7cefe2ef02e6edbecd552fcf1aff14d9ed300023fc2eaedf9bc3d42b640f3b19613a9ea8cfc76ab793d2c0cb573cfb4739e141e97d6150d3fd4e10015b9514e8bab8a23de560578fc1014a5c0c3f06b764ea5c5fd3a86a431e1a38b57396b2fdd52a51fa7a3d7378bb3f42347231608f6c362e6c617a2c84a5f134e7b957b86aa56a51d881e6e823c8e8916fc1be2ed052d374c7815d8f7a10b3ace98a67bfbc2331b071f03835ee335ee4c731ebf1444afbbfdde6de066c5f1f6b9a9a5ee63636a52eb2ffa1bc298f202a3b8b7b3bd1e29ac09f6534f4c342ee8de06d507d34b8cee91c88617b81bb9d92e87dc56c62258dbb86cc8803d48c9ec24ff832e261d5e414806a806875fefd6fbe7cef138218663221e5a58b3c3d640f6788a5a4d49e8a97bb9fe2c1bc2edf2a286bdfcad47331f684e466514e22c8a375d6e3155263da3624da063719d5dbe5dadc2de69e7fd6679ce707daa632774d6cb3d28e661dcb4c5beacda9da2bd00261826767614c657971c85fb2d60edfc3316fb426f7ed1ddbcf7de204dfbeef066779c6318b07ed578893aa1f7170913f836eea0a77695d574879c402533fa7246b67daadb969431e95a3f3cda1e6cd0a310cb3eee21412c394815e8e91da433faa0f1122d8aae03c6cd482607ca631ba82816e2a2f8110176a9ae3a333c41f19e3f571c4c015a7e5208e195c4cfb159d04539c3ee655c06f54ce1ee2fe3d84f36f68e1de73023209fc6dde3854b04ca1721c8faab7a970d2ee47e12df26a703561d04ab894df054153a9562f7cce07f3609b2772d2881b14ab2eee266956d58730bd788ae0b822267396455a966266cbb2c74287fdd84222fa8d13c032370a9586718b663b4b6c7d51eb6743e0ca24429f822a495899caca75acfd4fb82924a4710f06eaa59b073feac96fc0dc6d9b9d01152e6f8b4270e947bc44c2b37f3fcab390c01e729630d0385e349256f584c70426af0ea9ca2bff3a0b29ceb5f7326bb61a9b68d788a13e751253f7dc5080746e3ce381e7d407aaf26884812588939525b2ab5dd8ee915223c4e1d0f3f66e01f2d40cdc619969f7c96e8d5c77ff7f1a86e7afbb057cdafc4292ef6605798d19a0cc8dcf2abbebea6ed900e3fbf302483ce9baf3e9fc7986790d05ee231eb2df60252f4827c446c46358e67cb6e9db63dcf4eda16c0138785e074e8d4479dda36ccffacfaeaa131ceba4928338abe29c4740d8795bd1080a891addb54a60e74d08fe71b6ad0e656e8db0c1a3d2486c4d930d91669983fabb52f716af2ee1eb5225e2a7fc9d74cfecc732d109dc5f44c99a87179dd560b175ba06a4a32da5042445eeb69fc5fdebdc02001072a4c9a4fd2e635855ceae683141c699ae97fe54f2993b7fe608b947cc4b30f237560228befed401cdbafae3c3fba03d62ea28574dfd3632017a6ac24ba59542c8b1667f1d34d78922c4af83fba0b0822acef9dfad03425342fcb4c029d854de1c641bd8a5a0d6cea0048659ec47dda1e69c9662cbadd1a89aa19ad5b994789bdd22b5be55edc7e9a7d3676ef88ec5db38a138485636042da208063493ca51db8ee6b45521de485cd5d773d0e06e918cf15e84c6af7ece0856a64da429be7c121055c0ee454e7517d549bd2caa8b6170927f370dde2dc21eb4c22985195571f11ad5e1c157c61a015894ea59918cb855026557ea8821a8cba9fad799964adf6bee093c16eaa327cc81ab8661e606b83359f966b7078b6de3c15db2a6e97947f1b4eb03d299cfe15aef820e7b50c59486f0660de83773c3102680be3b74528b9259ae05fd5a55d163efd9516352c26e690ce96f29df38da77ba8828fb9133b78abd12876bef2e2bb566466f7eb9c3e5b81d6cd4712f1ca12a3ed1601d5de30926bfd285648247e5ca540a69a254f683b540f99494594ec9b4668997fd5a79f198d6d50ac63aa8ba6fcb770efce1fc6a54f5b3f620cf9a8cbce078efca6c8ac132cd95d24828370ee2e1c5f56b52283fe5cc7d1d46faad2b3023f01be5a0d1c65c1dadc3f83fd713133e3927e0df685bba46be7f3ce406724e9b3c03f875698e87ac30db8d8d1b131d265c7d84279804f16cf87b338e42fef9bbfde30aa4afe2614338b72ec8e28c956a09bd709b8a87f7c657b2f2cccabcbe60adf4bf4b1ff498ace0c00f29a51057cd6d2f28a2e58af0b5ca7a654cc024274bfd4a01a1a8e73fd0ffea6ab84dd34d50772bed3f0d4159fb3e50dfab41494cd545e7fd4199c93a290443ba9125a16ebdab38bc576c50599e27595718e9f5db4ec742596b9e6ea5c6e2860e941c66d0d4e97bec94cb9c07f9a9810e45be06848f26bc9b1013b5fe3d5ba902e0573fb5d08d293bbaa2e1f13382cebd7ddf59ca6869622a430dcebed41cfb68d85f34b87683e9f0613d491d258dc9c9bb0899b915e55059bb327ce05b33135eda11319c9a65487bf6f0ab918c2f099170bcae872f78c936f6db1e59f5118b1c1822e9f69cc99b4da862d77cb67c18cbcfbd1022d6a7b9914d6f230a21e5b14e6692dd0e45046762d44f1dba4c8813278934317520e59d65671ba342442db812cfb90bbad498d4d4822a651418d368c3fade84089a3bcc6d17e231f1f9cae7a3b1ae1fd2023907634c4ef92a4baa4742a95d617cddd80d5e7befcff238535877e5aabbd919243cbf62982829d832ac2871ce952805682dfbc4239e00ac5a61eb61edc390ac8723d4b5bc586abaf4319334371dded88ecd25cc337f8538f94a6f5a4bfea989b424aa97feb90297208715839bf41b576545292a5f1a5a744c408694b7f9f8805806c26299cacef515295dc59f8a5bd80ad0284fc7da3573ad468ac3128a08acd99d6c30c3744d5cb8dbf7a66c68ddb85214284b8804e05a1c9f7ea031e660c79e4238a8cec64aa473143f79d79cbcb5fb8e6a3c25ec0691dc39f7e62c7dd3a43df8d6560dec125411c79d40d1f9eaa7a7b4915fa3725c2e93a0408e776c314096203d51e18b74bd1818f3cdb472dabfdb982bae61ef98fabafd1549a4a312eef0293262c41c8bd402001e3ebb9af40d80b8261ae4b8af41d07c3f1e612570a1e6432d0fb9fd39274977689bcfe90f8edfd5d81cf8cdf7ce72d9b3dfa18a4c1806472277efb70b9166231a9eede72094f1549eecd79478bd02e8cb1d859e7eeff698b361ba14a068bdb1cc0150451ca47812e0dde5e98872f7bd30899e735dae31f03e9d9f9894c4876c0124dd7df35e5146e719c6d0c9a742ee57d4df46e64938f70a64adf82421e47ff33bd1126e5c546c839f4b146401ec11d0d9df89bb1f7b88464797057cc934b1e8cc4db560fd5a671e85fcaf968b388c71b047d5528e476d80c3ff592508991c0fe5778285106a76d05dd2f67d44562152f0d8ed02ce1e1704b961f257baf6d0dd0e2ecf329b94e048b7b2b13a00f73830a4ae81debe46412e84c562df66000b6e3630e2a642b271ac6b8831bf3b2fd59c3a3b07ed2fc93cd8724e1b4cfa37f77636951109999232a04cd703939079bf244ec3772d2710673648300bf0f2ef80c68ca72f946a5682422bdc854988c85c7b53104fcb4fdd2d3b4199c245957a2e08c2695f86c6aa4a169b2b2b53b83cd2898ef1a59236d3452bfc831d72317f6bed58b22bea200afd2f6aa79d6ea2589f170a0a3d4b0fbd5193407c855621d8173c5519d011ba36127bb5f637893da562cd9923ca1fea9ae26ab5a9d92cd416096277163e92f1c102775e173279d669381a3ca5766c980b895a39521fcb7feabd461b8aac497f6fab7b969a0fbc238b4139b98fafe22dd0ad278f66136efd7d4f30f3f1c21ef52d3c91ceef43c90af26b329ec8614a871a73bd90629af55a01afb46140a8e5d03f1e56182a91f78e17ef5e5d88a3eca76a3b15505bc4bf0bc16e18b99542752c9be44c877c0f278063aea9f187b7989ccbe9a16e8f77cd8cadaf6fa8394ff08b22d67c03723243ee9b7868d6e3e3f7e6b1e11ab6db35868736eeaa525841d62042d1f2dbe024df5c7d02c82ab732bb5c696eda66f20cace42fc901ec7541df74fb7363675409f12d1a4b9993bab3c70c1be32c87c08c4ad9ca60efa6b8cebf29952cf00c3e86610af3f427557d5196726a35f5a8c383ee657662830cbe381178dfdd08f50839689e13aba0f92c392daff18c6a6bc71d2ff56c359ccbaab7ccd40a07cbb2bd5e983d0cb8ac44ea8b3f5b56da549b951f1912c7af02bab5dcee291702f28ffacb5a0ecf90040fcece05f6bbeded05a31b48baf0e654b45655389756413d4ee2fbfe0fcccda0634cbce1ac1f7e438c8960e0b445fdfc2ce81baeeb0c82b440d8d349b71750245afb8850a69bf25b26c25e108f3c82b0b0ce73b22842e7ec870404c70e1cb29ef5783aebf12fc5d8f2decdb32a61483df46c75c649db519ac2bee85482217f65082e73a585b0d74871a14cc765ccb283df0d804f4aeaec3f28a35f45bad1c5fdbe9cee0fd4118d8ebe2dd23b99fe78d2109f7bd0cc21177fc81384153516a85bb7b8ed40f36d1ead13279d243e0b8ee70dcf5827af3a3f529ef9cb5e3c0a6e8ce0c4c0d972acd5c1cda407cbef7f4fcb4a6eadd1220ca36c0e5c2ee001ce463bd97d644c2a1dca1f2305a824498219fd93ad8aa7eac33e6ebdff42d862132d052659106e4ca51b8a37e3d70bb6c317e9aa26fd2ccfb3236733de43f73b62fd573d52d9328390a49eababf2d85f064f5b612accc0271f3e07fc34e2ed73e9e4141b8ff9d3729c804b928cab21ac0db350ff7326e9369c4f462958e300e7551d7e4501dcc89e2716cdbfe4c9d441bdebfd00c329f2fa24c589082c69d843238d35ed11666581ec65d61ca014f5fdb3ca91c4122589ffeb4c166a82e4f9ead6818e1be2d31938f6b0a93e43cf0c9f3bee55baf3c52635f00305154ecdbeb0ee4357efe3ceea528139f9cee744105a9579713b42ba88b6eaa8222092081b0de285f64eda6134d5e25e41579cbb053010339dd1dc93b0f6e8a3ad4162d22ccef95044efac36db4008f1169ac980aeb44f5f60141c2c541b5c907074697351e3d22ddc34ed939943cd1aafc5090ae61ebfee8374daf68f2e8ccea8c910272ac4f7c02807f514fe3690fa4256eb4b48ede2f5cc9b933b5d6ec317fb097f57244c73f89aea5ca57d1ff03c6738083b151d2ec56f411de566a5a2a65e0d90a5ec64140ef229bd69c40f67cda2377c4838fb88fcc22251346c56db36eddf7e6eab777263da727c88f3ddd8924ae83593338aff452b7dbf5f724bae5c6e23efe5e93bde1efbec557961bfcce7f2695a548942252904fea407e91b1e4b229ef5d37a89f4cd823dcce8f72ecf2b23354fc39d4cdc1df1c7b412b134c1ae4138ad432a4e78ed462cae9efc267f74b66783c7b5b60efed0b9fff47ca72e91ef4fd57556c93c62e48f8237ad5d2406995dd82fbcbd9d578b5b99b40fd0002f27dd0d6c951cfcefc40262a792c94df48a7f966e9026c84e98eef54b37a28ce240c6903b5fb89c6f61f930751f0473c02db75c1ae1b4c69d0f3c7b8fb047928773fba40c817643ccb5541717bdd7858db7ba547bc4b1d2d9e49e777c34556c17008058a30c77b54e3e4bb2e408cb59bbebec3bf3418f626cfffd3df337ec54f3838bf7bea8cd9cec74dc3ab96109dc3316a050e868847c6dc7b0512335d29936b3b5aa7f7bb55502332df93e9d7c2881727a0636e3d72b3e4f22d30ff3417c1510a106d67bac508402bb0e138c5782de1622c2a0570923384349269d59bbb54b9a2ab8f1ea139684373588d2aa17a100c14c5a08e473a173476b9b2252d62adc1ea2ee9eeb3f0ac72b1069e33b290009dcef6199622d2267281d472d70b1f8b010b06513c68f07f68787f47e0baf2a1d057b4a68b7816a9c5341da5ab3612fc6a80d20fb3fe723ab0bf76f433cb0865f012d224aa80be7d232043741122e30379a02e2fef7c70d00ccbfca0ef9d16a1259d69a19d7c54e11cf39521fe8aecef2a6f744fe55bf445a3c715c081e0c02778f020c63ed02c20c777e35d5870db923f223c00dc2f078a4ebc30844527f3a45323d3e90a727979002fc85bd509ad80af00c8d7c33d0197b39b95e825d808b20a28f87fcf90ceddd188d2ada7dc309b618c2b8f15887aea9a3592e50b0ddcc3f0cd69090ae60b2a75caabdb45332e4685df92b3f0910ed8e4e0436cf3df59b33b8445736b71c311facd4f7c26a0a8e12a7088d2d233bc8fe3861ce11e799c6efebd2187501bc2a1b9de98ca80c53244dbf251d9522862239c7014d62b2b38257f76b849e8b1217c7127ed9a83da6d92fa2387d5659e1f306f92e163a371887dd333d251b04c5f538411c824dadb4f459126833d00efda849366132cb61e27205919b8ecf5b89d58f680330402918b7fc68e9a3eaa87764373a931b275746f2562f1fa86a293cec84830e40fb1dc206710949f1a7ac2e045f56b46a2e0ac13c100d461e6141db07a70eb052695dec9c2cd28d4db4fe31c8d45df1c72a5b1b13f2b88606705dd3d736119e4ed802bfd14dc0e90876cfa0c608fbca8fd4227d1ce6eecd8043d4066c01f8578589e0026a25c49d0d9a21fd26b3339c5d9ce1812d7f602a99539c07d97631b7028216b3f240cf324f0e1f1d9424efeb283c7193ff183449bcb77b1f620996ce77219c6b08c41ff0756c061f04671cdd1e17728a48e383f5318d6b5049d63a41351b0df35b475f61872320b87f11ba4ac3789e7aafd15c256108b1a1d7dd372487ddd796286e950fe20abb239700527d1925fb1684cf4a64a3869d1dbd46fc15ca39090e15937a01bd76596ec608958de51e437986b06a80ca54e4e59531a33621a619c44a227ff0543f7f77bec982d04922075e66c94b1c2c7a608aa94a60a63d12ce2db7a3c2e2cfc34c3bd9787380baf638696ca4ad55c46cbe760b70f81a3a2c1a618c173e10172036ca55d0aa5dc94ea77ad2f23c6ed1a246f27e0f130abb48555d33fee85402ae31871334133dcb403ff9f6812483619d82876389be88c86c48dfe8292ea157ca81dcdf56b1376bc2f4dbedb3f2da4d0b6e3059b24d9b3be801064e386a39ffef73a72eac5e8a15b08cdee7765b152755998b2f5ed72cdecca0941e71a3b6b70f398943790b6c9ac807b900e6558918f768d4f200934ff6c2b069796a4f12cac52665ec6abfb792583e36d8ce04aecdf1e059f6f25cfcdc294cea7188d6e5f98e4711ce82369dc34864e2b87df3f14952add15140a85528b7b717b315d5da47fe1fce8875f8f3bedd293aebc99cc475a3fbbdbaedf353be4e82d3dce046964f2656982f10332a70544e862cbf5795bf3f4b4eb1056a1a2a3483357c86560f28f95f5774ba6b099a2dfed4f4c4d3d65dbbe384bc499ef953deac130bb8af0e44e6fa4d6ffa0cfc1a7930664598f6f16e9d47621def744448ecdf22e3aec583a11d379a1d2b3f1b7857372972c655809ed998ed712751c043a483a98a5862068588df4d93ff7179cde7b0be1ef2796f2164238c9e8f04b249c2c0eec21ad3a433fbd56f67bf2588b4a4e75e7619d45ccc8033eb74df1e3b800f4d7fa05eb599cfa6502b2a74aa2caba2a9852a119546720a5ae0cfaf96c057ca0c2845621ed301cc2bc578abd615ee9732cda619f9994cf4ac20d702fcd66da096d97e537a508172cf32996435f91c9049c56e6b40ac753de586c1de8a60ffd1e9c5d31a94c4d5bae5a046dc0dbe692f48975976e3fab77a8a068d0031f70bad53840f7b7bd43232e7c31e7e30b69adb0f83e67efbbfa38c1e2a75cf2679cf7994f858f2ac32d65e163f7a1ec7de12271858cdda477691058ec1a77ef707523aaf4dbb68ce60d4ebd1fe91ca2659a7be12c0d1c026236aa4f388642d5884f9e955a57547f56ce44804a85a1d1b6f038e72abcabfc5d49a157c46a98482ebf2b5a045c49062d170bb17e94bfb287ec6c002b7802dca61268a2aa93f4ccb3af100d142a0e319c92365092ebd14250c8ce712a06c3fe6525fb5ea2af526e4465c0c7e219154237321b5ab2ca7455e94b9a197ad491f511df2e46b864519454c80386a6e5ca21299ab92830dfaaf112b256393cb53b7804dc9eaefca363972e80a9c9357b4afaf0995298183353e7d0e55388e01676392930aa786c40a90a4e4b92c2cf622dee1d6bccf71df4bca6e4da7d4e0ae38515ed00454dc8d44c8dc7a878660d9b9cd7a6780691eb4a27f37379d780ca0f52f4a5c330aa1c86ccd8d9102ecbb8f4b6338a21c8d56cd48fa676bb4caa69225e0c7f8ee0550a051e92d6d54afadda3fac4ec96da797091baa31db675e7d339380b7e6cda3b60a79ea7f6edf9b3f500ddd6984093e155b59d541edefb03c292c7de64adda2ccfefbf5cbe313d03c2c2fc9f384901e962416b45a756c5075a8daa84fbddeb8da24f1fcc5ced6321c50ede7b78247b48bf4df99e5d02360a5cb8376efe297cb8abcfc609e7c6e091b0991190ce27c5b3c2f277cf46d57cf9ba62f3b460acd9d5430c35f87c584b04e938e877f676a18828215e110e6a23b9223794dfb448bcaa55b69ef0cb481b15506045d5740110539560f2590479a88d442ec2cdb216e7c1da7d46d40a99796ca8aa2c3d50562b1ced72613e5d9e2a2ecfdcf0c4beded216d3129fa960eff4a92ad189b70fa9b6935b5077cde1e04abb1902dfd885e7318ee20efc03b0202a28b969f8dfe677744a87e8b2afd618c89bb04f13c3aeb7bf82274d6d74de5c367bca658b34948e5acc15cb59b660d8b407312cfa356f8bf646fa0339dc6149df569e9d311733391246cb434052a0457f52ed9f5b689a18680eab622197bb5bc30c78c14f7b6238ed6f33accf12069e11e6a99ee4d0a590bc3f791a71a4489290cc9e455ff8dabd6bd1a9c8a50b1aaf076a6e9aaeb06dff7f7688f2fa2b7934c57bc7062bc68e263384cab2b44abd6b253cc95d9b4aafb0e8cddad5e8fd6eb564b2f598ab673bbccb2964051d8aa3a52f942c412cf7ab8332d76e3a43eb25fcb93748abafd806356d73a27fc8ff683825227ebf359a6d456599f7f46ecf67c3c111908fb6c5c6da3badca9301891f69ae68038780bcfbdd06cea49dfc853f1535acad55bb67416631a2ccbd82635721ed41f41ad31f4e29ad60b643f7e88f380e40624344b164b13c3a00615f382e26972bfbb33e1cff1f8f9a52d72d2e61be4154a152dbfdc1fed85ac0e5404ce29a48cf201a58287814859554ea0b5e2742c2a1f29c39a418b4d59feb9cdbbe1e0dfd3f4488737e81ed276492843021c3bf40f31287da7d79e8840edaf2e3bcea8b957974a5a25471d321fa2889401fc76b0bc981b9a7f124132097bd46853b94305b74e58cc16b1acafcfb1cf7644334eb713ebd2800296c26b66c747259336059f7ab66e7341b0cea5f9f868d62ed91b295920a23e26166fa088099808ca1f9d164a420e0aec71f9793732b0963ba165be8ec794c4d81db1de15c47d32ab4ce9759a7c1e5b44967979f851d254ecc01a8b3fa6b8419549344fc487b7071b91ad2a99ede8b49efdb4736c43685037bcfffb7b5aa801cfb6ff41775926fa272ad7e4b2f9d381d69caae725d3c75ae2f8d53a45ba31f6d19f80d96eea3b9b651ab6d9346148d37e31398b3c111edcedf4cd08359b41ccd4c7da057c2ce7d9a840ce2a57af0fb391a4f69747441c5fa4bfc643184b87aca666eafed60340bd6e875d0cb41bf4fa2b41a595598bb804948d339407fbef5a2ec4177e21aefe384c206f3351befc6d953a3aff291011e3513669707605f14a78635e50f4e834b878f4a631afdc53d757478f27568f044bd27e45daf8c6ecb9a50cfbd35b7c9d53b53b81019e4f9ce5ff1d749a818d3a8da91a81eae53d50a99aa794b309fe7052155923603846e3a6fda1e87c6b8f21d842d4af5071a5e062c2bcab784492901f47f5ac6bd1a70aff0dcf462435eff54fe886d2d8f2cc0fa67f19ff0c17fc460c089995c9744b6ba03ec89be31b2bd0e506ea8a9642af0cf2177e7c470b60e6010120a7966dc8c65f92e2ec755c1f96194841e06c3b5840217121372ef89f1036508c8213d753369135c208aea69aebb817e993a87bfad2a0161a4b85d4d7710d509b50de04e3c9e11ced89437bfcadf9ec74065cb89a8b3d41c599843427d0c81cb315c23d18f8fd6fb652e5520b6a17d24bc9a6197c37561629f9aeab93a595f45318af80300a3ce0fa745403fac0eeac343a9bfd0cb9c8fa41de7ca045d9de34443b2380ac9fd8f38d5bb2ff4a52bf3e0976f48da777a2c9981413e288d3e299d1a8d1af1f3be2ca470ac793764660a19e20d3863a97de28baaec8eaf772fef94ed49fced77c87e9c0f8445f20d2895205dfcc31d882fd10606438a5bf73ff87fd4759965672efb23a4a27e0212fee600105feea971fd53528cd2ebe39ce3dde886d4bab996a9c423f92c8b5bbc0576d132432730e7c99885797d8aebef051b27edc0d744df07df5cef8c78628c60b540b1ff0fb6e350f12a274a3293352889e4b7e15c7567d1a077d2328d7d78d062755f30611060fbe94750e6360da6fa64fbea69faafcd9448b3b87bb78273e2a9df6758a66aa8f547124d2e8b759f08b297f366594231b7d694572f4288f4fbdb93d4373315ebc9d951cc56c58ab293c4b60c2a7e3fc53a1aa1986f212f1d810aa068374913adcc1542a735b355a2c958da4e379fbd9638d9c30acb3cd720ad8edcb4fa5638314bd9fce290c0ef28f0d60b082157139838a48dea204fe845da8c42555f35806ad5abf188cb010d6245e60bea5e29872023da55acd0792fbd58a2c5c489affa0bd55502340f2528db966cac7835cb906051c9026f8c7716c4df66024cc1b21c30e3af15a1bb930eb1efc9d77155414de0ca4eee2864f75547a5509cf9591a7cd1fc85e11cfe32e08fba18a5943b18e3116f12525be448056c02aa304ec9c960219a17554a501c7a1f1b97ab46228cd6c5723be5790489ab77cb92dbea8780403af16f24d7b999b50a4621dfcb23bbbbe3f75dc24499d7a7367b456850d7956904a7846dd2fe4adca735efb51f246f2ad678710c63b1058d52078aef9fd9c8755dd2d96fb7e99860c8cd58dd442c8bbeabdee7ff5b3adcbc1a366cd585eb8048280ea9451fc401fd6df45b24702ffd0ca4a060833454283e1fff83420d03c4a103357d1b0a82e415351360279f0ce9ad9b3213c7ce2e12f848b5074dcf9747fe00f9ea7cd49212435d81fa600a4e3e48da0f6565c83f866ca06653128df95a3b01d2b79ad0832233cd29e46776e5e137ebd835255ccf9a6318d1c01ed2b35f565795984e55ab28c8b32d36427a86541e9fed44532f860880e23db023e09acb2a2d5e593a8ea7e4544d33a8f239b1a1c4c97623159c454a37f7dd5227855fb1673f7c9a7113734fb660b221a98678cb2dafc14242f44ba7b15e8b38c994ec34ccc33cbc320f3a756966e47422fdbbdc827d1f860230c5dee990dc6bd2eaa452a75229192b3dead3ab3fe7d1804535f27223a9dea18380c0f8448801555929e242916d251b3e719ca0b22a3a7d7c5460e4c0b67dffe9ac6d530c4f483ccac91ef790b2cf7cc9c6c17bec20a0da8b75a6c1355032d537854ee4431159eb7fd85e6464406cee1d6209a23a0970ec34ed6c974bf321ef7685e582e2fe71e4434aec997c28bff0a610c9f069269ca6102e9e8cb32259cd58d6b239d0e904131ce6e21bd50bd61731aa43fb188cf472914c87a6652310134ffd39d7d966754fb03edb083422844a8b44ef1233095f83fe77ef3ed2a9dc872944b298dbbab33f46a9aa5fc1ac5314f5d7526106d7f7d76a5c7a21928551bbfb0a4f5ce07aecc0c88b5251194aa04573f56beb53ebab24c5083e79b36ea1bac6b9fce352d7461993a058756719d9b1244397e7ea0b4d6f6da9178ea68b8069163c18caebdc11e1172bc083cd1b362bcaacff8eba83a11e5ebf3c010ff4e184a522ce24f1cee3d0ae86d339d08e0e11a5f2d30f5a1fc44dc6cad2ca98b0dca00ce7216bfcd505a126bf6a2079409b71518f65121b01753ffe5f04043a2d586d26260b59706d0a738aba3ac5f739dca45e9b6e8316a004d20d4e3e276dadef1c6e8abd4a07389be8b39d3b75cfbed162e77161e263bbfff13c7092c141c6eb970a6dcdd38470728708a415bdcf500d950ecd8d936829008facd81204e98de177ff90bf6ee11c92ced346574e652ea5bda000ed05d8b9bb4ea7d49894c61b46da8bc8d5115a931ac6b2a0e17f4c15b797b1e77766b111c7ff4b26d6ff65c98b68204c4100f00fae6ab12e38f75f6b21ca4de70fda1f1087dd82527aadc1163b0d6d10b1c1785543865e65a03a45ddd85cb515a232ee71a07874307cf6b3080a8612d7afe1aae74e1293cef820514482038bce0ae9d82fb5d699047c226a24ccdff9880a64944230fb8c9349f20da7003892a8533a63b1c81c97f80e138d38622980d673f18090d54ce0c9408198fd26ee21d94bf6f303ee659b541b360d59f8bad6475526f5c2d29309cf929ec5cb011f2f9c7de57d140fe1f429528dffe73244d8303733fcd6449642f64303aebced2d2e01730516f1b0dc78dd78a59ff2717857aac017f88ddbfa19bfe9887b4260c076e2daa1b1a3ab846235ed1df48d1d77c5cc2a7bb274267cb89380774e6bf50bd63975b97189c3e6660b513020d60fd9d34f795f6ac17e7dae38746328c943e073fe2c11f783b3f8e6052913e35e93e41b1a1befc6d0753f0b023badcd9a7e66d6aba2cda2b8fadbfa9cfb5a7caa6130c84f7151ddb45f531d301c5dfd080139ea5efb54cf93efe16e0e3a8616db04bef2847181ffa784a5409290b8c0d51c50045ecd7374e1f82db97682d554312e4e5fbf40b609301c9d9f0f5064fe8ff7d9c0cd1d49004e72c090e9d7779e3cab278bc8463520d97070d80b938951f2894c359b16813d3ec95f1bd9f3c6bf8f1d2a42dd768cd800074ca920fc258f9cadc01cd1d453583e38059fc583cff68504e8392407ba2dd1ac38c98b58ca6943c39fb225bbd4055a04</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      有东西被加密了, 请输入密码查看.
    
    </summary>
    
    
      <category term="量化" scheme="http://yuanquanquan.top/tags/%E9%87%8F%E5%8C%96/"/>
    
      <category term="面试" scheme="http://yuanquanquan.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>量化交易系统开发框架-vn.py</title>
    <link href="http://yuanquanquan.top/2021/202211125/"/>
    <id>http://yuanquanquan.top/2021/202211125/</id>
    <published>2021-11-25T03:27:39.000Z</published>
    <updated>2021-11-30T09:19:39.084Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>vn.py是一套基于Python的开源量化交易系统开发框架，于2015年1月正式发布，在开源社区6年持续不断的贡献下一步步成长为全功能量化交易平台，目前国内外金融机构用户已经超过600家，包括：私募基金、证券自营和资管、期货资管和子公司、高校研究机构、自营交易公司、交易所、Token Fund等。</p></blockquote><span id="more"></span><h1 id="1、VN-PY介绍"><a href="#1、VN-PY介绍" class="headerlink" title="1、VN.PY介绍"></a>1、VN.PY介绍</h1><blockquote><p>工欲善其事必先利其器，有一个好的回测框架，才能更好的验证自己的策略</p></blockquote><p>vn.py是一套基于Python的开源量化交易系统开发框架，于2015年1月正式发布，在开源社区6年持续不断的贡献下一步步成长为全功能量化交易平台，目前国内外金融机构用户已经超过600家，包括：私募基金、证券自营和资管、期货资管和子公司、高校研究机构、自营交易公司、交易所、Token Fund等。</p><h1 id="2、搭建回测环境"><a href="#2、搭建回测环境" class="headerlink" title="2、搭建回测环境"></a>2、搭建回测环境</h1><blockquote><p>再好的策略也得经过历史数据的回测，才敢放心的去实盘</p></blockquote><h2 id="2-1、环境"><a href="#2-1、环境" class="headerlink" title="2.1、环境"></a>2.1、环境</h2><ul><li>Python 3.8.x</li><li>vnpy 2.30，</li><li>MongoDB</li></ul><h2 id="2-2、安装"><a href="#2-2、安装" class="headerlink" title="2.2、安装"></a>2.2、安装</h2><ul><li><p>安装mongoDB</p><p>安装mongoD环境是为了存储数据，方便回测。</p></li></ul><p>安装教程，参考：<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/">https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/</a></p><p>建库建表的语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use admin</span><br><span class="line">db.createUser(&#123;user:&#x27;admin&#x27;, pwd:&#x27;xxxx&#x27;, roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ]&#125;)</span><br><span class="line"></span><br><span class="line">use vnpy</span><br><span class="line">db.createUser(&#123; user: &quot;root&quot;, pwd: &quot;xxxx&quot;, roles: [&#123; role: &quot;readWrite&quot;, db: &quot;vnpy&quot; &#125;] &#125;)</span><br></pre></td></tr></table></figure><ul><li>安装<code>vnpy</code></li></ul><blockquote><p>安装vnpy,别直接<code>pip install vnpy</code>， 因为<code>pypi.org</code>上的库已经好久没有更新了，所以用下面的安装方式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install git+https://github.com/vnpy/vnpy.git</span><br></pre></td></tr></table></figure><ul><li><p>安装其他的包</p><p>成功安装<code>vnpy</code>后，还有部分包并没有成功安装，需要手动安装，如下：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip install tzlocal</span><br><span class="line">pip install plotly</span><br><span class="line">pip install pymongo</span><br><span class="line">pip install mongoengine</span><br><span class="line">pip install quickfix</span><br></pre></td></tr></table></figure><h1 id="3、项目结构说明"><a href="#3、项目结构说明" class="headerlink" title="3、项目结构说明"></a>3、项目结构说明</h1><ul><li>代码结构</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">├── README.md</span><br><span class="line">├── .vntrader  # 这个文件自己创建，默认是~/.vntrader/,但是为了编码方便，我会在项目创建这个目录（注意主要信息的泄露）</span><br><span class="line">│   ├── cta_backtester_setting.json</span><br><span class="line">│   ├── cta_strategy_data.json</span><br><span class="line">│   ├── cta_strategy_setting.json</span><br><span class="line">│   ├── data_recorder_setting.json</span><br><span class="line">│   ├── database.db</span><br><span class="line">│   ├── log</span><br><span class="line">│   │   └── vt_20210522.log</span><br><span class="line">│   ├── risk_manager_setting.json</span><br><span class="line">│   └── vt_setting.json</span><br><span class="line">└── vnpy_strategy    </span><br><span class="line">    ├── backtest_fixed_time.py   # 运行回测</span><br><span class="line">    ├── run_window.py            # 通过图像界面操作</span><br><span class="line">    ├── strategies               # 自己写的量化策略,都在这个目录</span><br><span class="line">    │   └── simple_double_ma.py  </span><br><span class="line">    └── utils                    # 工具类代码，都会放在这个目录</span><br><span class="line">        └── download_data_binance.py</span><br></pre></td></tr></table></figure><ul><li><p>代码说明</p><p>​    使用VNPY创建自己的策略需要继承<code>CtaTemplate</code>, 下面也是官方一个简单均线策略，来对<code>vn.py</code>回测框架的熟悉。</p><p>​    双均线策略，指的是运用两条不同周期的移动平均线，即短周期移动平均线和长周期移动平均线的相对大小，研判买进与卖出时机的策略。由短周期均线自下向上穿越长周期均线，所形成的交点，称为金叉。当短周期均线自上而下穿越长周期均线，所形成的交点，称为死叉。</p><p>这样我们可以构建一个双均线策略：双均线金叉的时候，表明该币很强势，市场属于多头市场；反之，当出现死叉点时，市场属于空头市场。</p></li></ul><h1 id="4、回测"><a href="#4、回测" class="headerlink" title="4、回测"></a>4、回测</h1><blockquote><p>回测之前，需要下载历史数据；如果配置了MongoDB,数据下载完成后可以在MongoDB查看</p></blockquote><h2 id="4-1、命令方式回测"><a href="#4-1、命令方式回测" class="headerlink" title="4.1、命令方式回测"></a>4.1、命令方式回测</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python run_backtest.py</span><br></pre></td></tr></table></figure><p>回测结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">2021-05-24 23:18:06.187119    首个交易日：2017-09-05</span><br><span class="line">2021-05-24 23:18:06.187126    最后交易日：2018-05-20</span><br><span class="line">2021-05-24 23:18:06.187131    总交易日：258</span><br><span class="line">2021-05-24 23:18:06.187137    盈利交易日：139</span><br><span class="line">2021-05-24 23:18:06.187142    亏损交易日：117</span><br><span class="line">2021-05-24 23:18:06.187151    起始资金：300,000.00</span><br><span class="line">2021-05-24 23:18:06.187159    结束资金：300,969.58</span><br><span class="line">2021-05-24 23:18:06.187165    总收益率：0.32%</span><br><span class="line">2021-05-24 23:18:06.187170    年化收益：0.30%</span><br><span class="line">2021-05-24 23:18:06.187177    最大回撤:     -608.35</span><br><span class="line">2021-05-24 23:18:06.187183    百分比最大回撤: -0.20%</span><br><span class="line">2021-05-24 23:18:06.187188    最长回撤天数:     8</span><br><span class="line">2021-05-24 23:18:06.187194    总盈亏：969.58</span><br><span class="line">2021-05-24 23:18:06.187200    总手续费：101.55</span><br><span class="line">2021-05-24 23:18:06.187208    总滑点：0.00</span><br><span class="line">2021-05-24 23:18:06.187215    总成交金额：101,552.30</span><br><span class="line">2021-05-24 23:18:06.187220    总成交笔数：171</span><br><span class="line">2021-05-24 23:18:06.187226    日均盈亏：3.76</span><br><span class="line">2021-05-24 23:18:06.187231    日均手续费：0.39</span><br><span class="line">2021-05-24 23:18:06.187237    日均滑点：0.00</span><br><span class="line">2021-05-24 23:18:06.187243    日均成交金额：393.61</span><br><span class="line">2021-05-24 23:18:06.187250    日均成交笔数：0.6627906976744186</span><br><span class="line">2021-05-24 23:18:06.187256    日均收益率：0.00%</span><br><span class="line">2021-05-24 23:18:06.187262    收益标准差：0.02%</span><br><span class="line">2021-05-24 23:18:06.187267    Sharpe Ratio：1.11</span><br><span class="line">2021-05-24 23:18:06.187273    收益回撤比：1.60</span><br><span class="line">2021-05-24 23:18:06.187780    策略统计指标计算完成</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><h2 id="4-2、图像界面方式回测"><a href="#4-2、图像界面方式回测" class="headerlink" title="4.2、图像界面方式回测"></a>4.2、图像界面方式回测</h2><p>运行<code>run_window.py</code>文件，即可启动图像界面回测。启动成功后，整个界面如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python run_window.py</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><p>图像界面回测结果如下：</p><ul><li>回测之前，一定要先下载数据，有问题，可以多去看看官方的文档;</li></ul><h1 id="5-如何运行VNPY2-4-0"><a href="#5-如何运行VNPY2-4-0" class="headerlink" title="5 如何运行VNPY2.4.0"></a>5 如何运行VNPY2.4.0</h1><h3 id="5-1-环境配置"><a href="#5-1-环境配置" class="headerlink" title="5.1 环境配置"></a>5.1 环境配置</h3><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzA3NDYxNDc3MQ==&amp;mid=2652390042&amp;idx=1&amp;sn=1b76748baa613014f9a0fe3d0922811d&amp;chksm=8491f006b3e6791072f6f76777e9b6f3ffd38912e0ad03b36b7a5ef81932b23b04bf57a9daa3&amp;token=2142790632&amp;lang=zh_CN&amp;scene=21#wechat_redirect">基本的环境配置，安装参考上一篇</a></li><li><strong>系统</strong>：Mac</li><li><strong>Python环境</strong>：3.8.8</li></ul><h3 id="5-2-拉取最新的代码"><a href="#5-2-拉取最新的代码" class="headerlink" title="5.2 拉取最新的代码"></a>5.2 拉取最新的代码</h3><ul><li>拉取代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 拉取代码</span><br><span class="line">git clone https://github.com/vnpy/vnpy.git</span><br><span class="line"># 切一个分支，如：local_dev</span><br><span class="line">git checkout -b local_dev</span><br></pre></td></tr></table></figure><ul><li>安装依赖</li></ul><blockquote><p>下面几个常用的模块已经拆出去作为一个独立的项目，如果要运行<code>VNPY</code>项目，下面几个包是需要安装的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install vnpy-ctabacktester</span><br><span class="line">pip install vnpy-ctastrategy</span><br><span class="line">pip install vnpy-datamanager</span><br><span class="line">pip install vnpy-riskmanager</span><br></pre></td></tr></table></figure><h3 id="5-3-新建一个目录"><a href="#5-3-新建一个目录" class="headerlink" title="5.3 新建一个目录"></a>5.3 新建一个目录</h3><blockquote><p>为了原始项目干净，新建一个目录(名称随意)，在这个目录可以写自己的策略代码，工具类等</p></blockquote><ul><li><p>比如我自己新建了一个目录<code>workspace</code>,</p></li><li><p>在<code>workspace</code>目录下再新建两个目录：</p></li><li><ul><li><code>.vntrader</code>:  存放配置文件的地方(mac系统下默认存放路径是<code>~/.vntrader</code>, 不过编辑什么的不方便)</li><li><code>strategies</code>: 存放策略代码的地方</li></ul></li></ul><h3 id="5-4-实现代码"><a href="#5-4-实现代码" class="headerlink" title="5.4 实现代码"></a>5.4 实现代码</h3><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640" alt=""></p><ul><li>策略代码：<code>simple_double_ma</code></li><li>启动App(图像界面)：<code>run_app.py</code></li><li>回测(命令行)：<code>run_backtest.py</code></li></ul><h1 id="6-问题"><a href="#6-问题" class="headerlink" title="6. 问题"></a>6. 问题</h1><blockquote><p>系统的策略，还有自己写的策略，都加载不到</p></blockquote><p><strong>版本升级有风险，升级到2.4.0后，发现自己写的策略程序都无法加载，阅读源代码，才发现官方没有做到系统兼容，等待下一版修复。</strong></p><p>Mac，Linux用户要运行代码，肯定需要改下源码,测试就OK了：</p><ul><li>包<code>vnpy_ctastrategy</code> ，文件<code>engin</code> , 803行</li><li>包<code>vnpy_ctabacktester</code>， 文件<code>engin</code>, 95行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 源代码 pathname: str = str(path) + f&quot;\\*.&#123;suffix&#125;&quot;</span><br><span class="line">pathname: str = str(path) + f&quot;/*.&#123;suffix&#125;&quot;</span><br></pre></td></tr></table></figure><h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h1><p>新的版本问题肯定是有的，下载源码，运行调试，不断探索。</p><h2 id="1-更新内容"><a href="#1-更新内容" class="headerlink" title="1. 更新内容"></a>1. 更新内容</h2><p>详细查看Github更新日志</p><p>主要看了下2.4.0版本做了很大的调整</p><ul><li>将Deribit接口剥离到vnpy_deribit项目中，并升级到2.0.1版本</li><li>剥离CTA策略模块下的穷举和遗传优化算法到vnpy.trader.optimize模块下</li><li>遗传算法优化完成后，输出所有回测过的参数对应结果（而不只是最优结果）</li><li>CTA策略引擎加载策略文件时，增加模块重载的操作，使得任何策略文件修改可以立即生效</li><li>CTA策略引擎扫描特定目录下的策略文件时，使用glob函数（替换原有的os.walk），避免对子目录中文件的错误加载</li><li>将CTA策略模块剥离到vnpy_ctastrategy项目中</li><li>将CTA回测模块剥离到vnpy_ctabacktester项目中</li><li>将XTP接口剥离到vnpy_xtp项目中，并升级到2.2.27.4版本</li><li>将事前风控模块剥离到vnpy_riskmanager项目中</li><li>将数据管理模块剥离到vnpy_datamanager项目中</li><li>将Deribit接口剥离到vnpy_bybit项目中，并升级到2021.6.21版本</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;vn.py是一套基于Python的开源量化交易系统开发框架，于2015年1月正式发布，在开源社区6年持续不断的贡献下一步步成长为全功能量化交易平台，目前国内外金融机构用户已经超过600家，包括：私募基金、证券自营和资管、期货资管和子公司、高校研究机构、自营交易公司、交易所、Token Fund等。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="量化" scheme="http://yuanquanquan.top/tags/%E9%87%8F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>关于时间</title>
    <link href="http://yuanquanquan.top/2021/20211013/"/>
    <id>http://yuanquanquan.top/2021/20211013/</id>
    <published>2021-10-13T13:21:17.000Z</published>
    <updated>2021-10-13T14:36:46.378Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于2021</p></blockquote><span id="more"></span><p>人类对于时间的感知，似乎总是和色彩与光影纠缠。从泛黄的黑白照片，到河流波澜映射的斑驳光景；从若隐若现的点点星光，到绚烂隐密的似火残阳。大概是因为色彩与光影在记忆中的定格，正如后视镜里的故乡，越来越小，她定格在那里，定格在记忆中，然后我们才意识到，渐行渐远。</p><p>就像我仍然会想起那架把我带离故土的飞机，在凌晨起飞划破天际的泥沼，就像那座城市微光与夜空的点点星辰，我仍然会因此而潸然泪下。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image-20211013223629777.png" alt=""></p><p>我想我们悲伤的都是时间吧，这个世间最大的谜团。</p><p>这是一种微妙的错觉，我们不能存在于历史，也不能存在于未来，只能在现在，那么现在又存在何处呢？就像爱因斯坦的名言，“现实是一种错觉，只不过是一种持久的错觉。” 当我打下这几个字的时候，刚才的“现在”已经成了过去，而我又来到了未来，但是这个未来又在不可精细测量的微小时间里变成了“现在”然后又变成了历史。这么说来，“现在”其实是最缺乏定义的一个概念，它是那样快地衰变成过去，如果我们可以测量无穷小的时间间隔（目前所能测量的最短时间间隔大约是光通过一个氢原子直径距离的时间，~10^-15秒），那么“现在”这个概念就完全失去意义了，因为历史和未来的过渡只需要无穷短的时间。而我们对于变化的捕捉，只能依赖那些看起来不变的东西，就像里程碑，就像北极星，就像阳光穿过你手掌照耀到墙上，映出心的形状，又或者是一只鸽子。</p><p>我们的文化，以及科学，给予了变化在一切形式中的中心地位，没有变化，那就没有时间。比如说“热寂”这个概念，在无穷远的宇宙未来，当一切都，包括黑洞，完全蒸发为光子的时候，我们就失去时间了，因为宇宙已经无法让自己变得丝毫的不一样了。</p><p>人们因而在这长河中投下一块块路标，他们想要模仿宇宙永恒的秘密，除夕，春节，中秋，清明，谷雨，新年，，，这是我们共同的文化记忆，它们超越了个体的生命长度，就像是永恒的符号，我们来到一个节日，又来到另一个节日，因而我们有了共同的记录变化的方式，进而体验时间的方式。</p><p>或许人类真正的悲哀会在于，有一天可以测量足够小的时间，有一天我们已经找不到未来和过去的区别，有一天我们已经找不到真正永恒的路标，那么我们的时间还会存在吗？</p><p>2021的新年，我还记得我在朋友圈写了一段很长的感言，里面有句话我其实很喜欢：“走了足够远才发现，过去和未来一样神秘而未知，都笼罩着魔幻现实般扭曲的光。” 这是一种悲观的事实，就像时空里的光锥，我们只能在过去光锥和未来光锥相会的那个交点存在，它们存在着，但我们绝无任何可能可以接触到它们。对于我们无法在“现在”体验到的东西，它们还存在吗？我们说过去存在过， 那么它现在还存在吗？存在是独立于时间之外的实体吗？物理学是一种悲观的意识形态，它告诉我们自然所允许的与不允许发生的事，而注意到这样的事实，则是痛苦（suffering）的来源，因为注意到了，然后呢？然后戛然而止，只留无尽的沉默。</p><p>常常有人引用罗曼罗兰那句名言，“这世上只有一种英雄主义，那就是看清生活的真相之后依然热爱生活。” 其实从来就没有人真正看清过生活的真相，假使你真的看清了生活的真相，你也无法改变生活的样子，它就在那里，就像过去和未来光锥。而所谓热爱生活，不过是接受现实，融入那个古老如一的故事（the same old story），那个永远被重复讲述着的故事。</p><p>时间来到2021年的末尾，我想我还是会继续将这句话加在感言，或者说新年献词里面：</p><p>“走了足够远才发现，过去和未来一样神秘而未知，都笼罩着魔幻现实版扭曲的光。”</p><p>在时间的游戏中，我们唯一的参照物就是那些相对不变的东西。比如共同的文化记忆，比如希望，比如对真理的探寻，比如和他人的关联…… 当我们蜷缩在渺小的“现在”，这些路标便构成了与时间谈判的基石。</p><p>2021年即将过去，这一年的非凡的事件，这一年我们被改变的生活版图，终将成为历史，成为新的路标，去定义我们定义时间的方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;关于2021&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://yuanquanquan.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Moving Deep Learning into Web Browser:How Far Can We Go</title>
    <link href="http://yuanquanquan.top/2021/20210830/"/>
    <id>http://yuanquanquan.top/2021/20210830/</id>
    <published>2021-08-30T10:06:38.000Z</published>
    <updated>2021-08-30T11:11:32.061Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是对发表于WWW 2019的论文《Moving Deep Learning into Web Browser: How Far Can We Go? 》的回顾。论文第一作者为中心的马郓助理教授，通信作者为中心的刘譞哲副教授，其余作者为中心本科毕业生向东伟、硕士生郑舒宇以及博士生田得雨。本文针对在浏览器中运行深度学习任务的新趋势，调研和测试了最热门的7个基于JavaScript的深度学习框架，以评估这些框架的功能和性能，并与传统的深度学习框架进行了性能比较。本文的发现能够帮助应用开发者、深度学习框架开发者、浏览器厂商对浏览器上的深度学习效率进行优化。</p></blockquote><span id="more"></span><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding/1901.09388.pdf" width="100%" height="550" type="application/pdf"></div><p>​    深度学习技术在过去十年极大地拓展了人工智能的边界，在图像处理、语音识别、自然语言处理等领域得到了广泛的应用。学术和产业界也提出和研发了多个深度学习框架如TensorFlow、Caffe等。然而，人工智能应用需要运行于Windows、iOS、Android等多种类型的平台上，将人工智能应用向多种平台移植极具挑战。Web应用具有较强的可移植性，因此基于Web的人工智能应用开发成为了研究热点。从2015年起，ConvNetJS 、TensorFlow.js 等一系列基于JavaScript的深度学习库和框架被提出。然而这些框架在功能和性能上能否很好地支持深度学习应用仍然存疑，本文所进行的实证研究回答了以下三个问题：现有框架提供了哪些功能和特性支持多种类型的深度学习任务？现有框架在不同的深度学习任务下性能表现如何？在浏览器中进行深度学习与在原生平台上运行相比有多大的性能差距？本文选择了7个基于JavaScript的深度学习框架进行研究，并将Tensorflow.js与基于Python的原生Tensorflow的性能进行了比较，得出了一系列结论并给出了建议。</p><h2 id="1、现有框架的功能与特性"><a href="#1、现有框架的功能与特性" class="headerlink" title="1、现有框架的功能与特性"></a>1、现有框架的功能与特性</h2><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image-20210830184828621.png" alt="表1：基于JavaScript的深度学习框架的特性"></p><p>​        为了选择最新的浏览器支持的 DL 框架，作者在 GitHub 上搜索关键字“deep learning framework”，并用 JavaScript 语言过滤结果。然后<strong>选择了 GitHub 上星数超过 1000 的前 7 个框架[1]</strong>。对每个框架的具体介绍如下：</p><p><strong>TensorFlow.js[2]</strong> ：2018 年 3 月由 Google 发布，是一个 inbrowser 机器学习库，支持使用 JavaScript 在浏览器中定义、训练和运行模型。TensorFlow.js 由 WebGL 提供支持，并提供用于定义模型的高级 API。TensorFlow.js 支持所有 Keras 层（包括 Dense、CNN、LSTM 等）。因此，很容易将原生 TensorFlow 和 Keras 预先训练的模型导入到浏览器中并使用 Tensorflow.js。</p><p><strong>ConvNetJS[3]</strong> ：是一个 Javascript 库，最初由斯坦福大学的 Andrej Karpathy 编写。ConvNetJS 目前支持用于分类和回归的常用神经网络模型和代价函数。此外，它还支持卷积网络和强化学习。然而遗憾的是，尽管 ConvNetJS 可能是在 TensorFlow.js 之前最著名的框架，但其在 2016 年 11 月后已经不再维护了。</p><p><strong>Keras.js[4]</strong>：抽象出许多框架作为后端支撑，包括 TensorFlow、CNTK 等。它支持导入 Keras 预先训练的模型进行推理。在 GPU 模式下，Keras.js 的计算由 WebGL 执行。然而，这个项目也已经不再活跃。</p><p><strong>WebDNN[5]</strong>：由东京大学发布的 WebDNN 号称是浏览器中最快的 DNN 执行框架。它只支持推理（训练）任务。该框架支持 4 个执行后端：WebGPU、WebGL、WebAssembly 和 Fallback pure JavaScript 实现。WebDNN 通过压缩模型数据来优化 DNN 模型，以加快执行速度。</p><p><strong>brain.js[6]</strong>：是一个用于神经网络的 JavaScript 库，它取代了不推荐使用的 “brain” 库。它为训练任务提供 DNN、RNN、LSTM 和 GRU。该库支持将训练好的 DL 模型的状态用 JSON 序列化和加载。</p><p><strong>synaptic[7]</strong>：这是一个不依赖于 JavaScript 架构的神经网络库，基本上支持任何类型的一阶甚至二阶 RNN。该库还包括一些内置的 DL 架构，包括多层感知器、LSTM、液态机（Liquid state machines）和 Hopfield 网络。</p><p><strong>Mind[8]</strong>：这是一个灵活的神经网络库。核心框架只有 247 行代码，它使用矩阵实现来处理训练数据。它支持自定义网络拓扑和插件，以导入 mind 社区创建的预训练模型。然而，这个项目也已经不再活跃。</p><p>从提供的功能性来看，多数框架支持训练和推断两类任务；不同的框架支持的神经网络类型及操作有较大差异，仅有TensorFlow.js等3个框架支持了DNN、CNN、RNN三类神经网络；多数框架都支持以层为单位构建神经网络，TensorFlow.js相比其他框架支持了更多的层类别；TensorFlow.js也支持了更多种类的激活函数和优化器；7个框架中仅有TensorFlow.js支持使用GPU加速训练，TensorFlow.js等3个框架支持使用GPU加速推断。</p><p>从开发者支持来看，TensorFlow.js在开发文档、演示等多个方面优于其他框架，但因其支持较丰富的功能，其软件包也是较大的。</p><h2 id="2、现有框架的性能"><a href="#2、现有框架的性能" class="headerlink" title="2、现有框架的性能"></a>2、现有框架的性能</h2><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image-20210830184912849.png" alt="图1：平均训练时间"></p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image-20210830184950411.png" alt="图2：平均推断时间"></p><p>测试结果显示，ConvNetJS在训练和推断上性能均为最佳；Tensorflow.js是唯一支持GPU加速的框架，且性能与ConvNetJS可比。ConvNetJS性能更佳的原因可能是其在实现上与其他框架存在较大区别。</p><h2 id="3、浏览器框架与原生框架性能对比"><a href="#3、浏览器框架与原生框架性能对比" class="headerlink" title="3、浏览器框架与原生框架性能对比"></a>3、浏览器框架与原生框架性能对比</h2><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image-20210830185032610.png" alt="图3：Keras预训练模型的推断时间"></p><p>在推断任务的实验中，Tensorflow.js在nGPU上的表现弱于原生Tensorflow，但也仅慢1-2倍。Tensorflow.js在iGPU上的表现则优于原生Tensorflow在CPU上的表现。</p><p>在决策树的实验中，尽管在任何配置下Tensorflow.js几乎都慢于原生Tensorflow。但两个重要发现是，第一，较多使用CPU还是GPU对性能差异有极大的影响；第二，任务类型对性能差异有极大影响，在训练任务中Tensorflow.js平均慢33.9倍，而在推断任务中则只慢5.8倍。</p><h2 id="4、主要研究发现"><a href="#4、主要研究发现" class="headerlink" title="4、主要研究发现"></a>4、主要研究发现</h2><p>第一，浏览器端的深度学习框架仍在早期阶段，仅有Tensorflow.js提供了较全面的功能和支持了较多种类的深度学习任务。</p><p>第二，浏览器端对深度学习的支持主要仍然集中于推断任务，训练任务仍然受到较大局限。</p><p>第三，模型加载是推断任务中最耗时的部分，因此对于较小的模型，使用CPU的表现优于GPU。</p><p>第四，在没有独立显卡时，集成显卡对浏览器端深度学习框架性能有较大帮助。相比原生Tensorflow仅在CPU上运行，Tensorflow.js利用集成显卡表现出了更好的性能。</p><p>第五，系统资源的利用有待进一步优化。对于Tensorflow.js，CPU没有得到充分的利用；对于WebGL，分配的内存受限于浏览器，导致部分深度学习任务崩溃。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是对发表于WWW 2019的论文《Moving Deep Learning into Web Browser: How Far Can We Go? 》的回顾。论文第一作者为中心的马郓助理教授，通信作者为中心的刘譞哲副教授，其余作者为中心本科毕业生向东伟、硕士生郑舒宇以及博士生田得雨。本文针对在浏览器中运行深度学习任务的新趋势，调研和测试了最热门的7个基于JavaScript的深度学习框架，以评估这些框架的功能和性能，并与传统的深度学习框架进行了性能比较。本文的发现能够帮助应用开发者、深度学习框架开发者、浏览器厂商对浏览器上的深度学习效率进行优化。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://yuanquanquan.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="论文笔记" scheme="http://yuanquanquan.top/categories/%E7%AC%94%E8%AE%B0/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>SETI Breakthrough Listen - E.T. Signal Search</title>
    <link href="http://yuanquanquan.top/2021/20210817/"/>
    <id>http://yuanquanquan.top/2021/20210817/</id>
    <published>2021-08-17T13:43:40.000Z</published>
    <updated>2021-08-17T15:29:55.013Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>比赛链接：<a href="https://www.kaggle.com/c/seti-breakthrough-listen">https://www.kaggle.com/c/seti-breakthrough-listen</a></p><p>比赛名称：SETI Breakthrough Listen - E.T. Signal Search</p><p>比赛内容：利用算法来识别异常的信号，CV类型赛题</p></blockquote><span id="more"></span> <hr><h3 id="比赛背景："><a href="#比赛背景：" class="headerlink" title="比赛背景："></a>比赛背景：</h3><p>“我们一个人在宇宙里吗？”这是最深刻且长期存在的人类问题之一。随着技术的进步，我们正在寻找新的和更强大的方法来寻求答案。加州大学伯克利大学使用世界上最强大的望远镜对数百万颗恒星进行技术扫描。现在希望Kaggle社区能够帮助解释他们收到的信号。</p><p><strong>加州大学伯克利分校的Breakthrough Listen 团队使用世界上最强大的望远镜扫描数百万颗恒星以寻找技术迹象。</strong></p><p><strong>现在它希望Kaggle社区帮助解释他们接收到的信号。Listen团队是外星智慧搜索(SETI) 的一部分，使用地球上最大的可操纵天线，即直径100 米的绿岸望远镜。</strong>与任何SETI搜索一样，交流的动机也是主要挑战。</p><p>人类已经建造了大量的无线电设备。很难在现代技术的巨大检测结果中寻找微弱的外星传播针。当前的方法使用两个过滤器来搜索大海捞针。</p><p><strong>首先，</strong>Listen团队将目标恒星的扫描与天空其他区域的扫描穿插在一起。两组扫描中出现的任何信号都可能不是来自目标恒星的方向。<strong>其次，</strong>管道会丢弃不会改变其频率的信号，因为这意味着它们可能在望远镜附近。</p><p><strong>运动中的源应该有一个暗示运动的信号，类似于路过的消防车警报器的音调变化。这两个过滤器非常有效，但我们知道它们可以改进。</strong></p><p>管道无疑会错过有趣的信号，尤其是那些具有复杂时间或频率结构的信号，以及那些在有大量干扰的频谱区域中的信号。<strong>在本次比赛中，利用您的数据科学技能帮助识别Breakthrough Listen 目标扫描中的异常信号。</strong></p><p>由于没有确认的用于训练机器学习算法的外星信号示例，<strong>该团队在来自望远镜的海量数据中加入了一些模拟信号（他们称之为“针”）。</strong>他们已经确定了一些隐藏的针，以便您可以训练您的模型以找到更多。</p><p><strong>数据由二维数组组成，因此可能存在有前景的计算机视觉方法，以及数字信号处理、异常检测等。</strong>成功识别最多针的算法将赢得现金奖励，但也有可能帮助回答科学中最大的问题之一。</p><h3 id="赛题目标"><a href="#赛题目标" class="headerlink" title="赛题目标"></a>赛题目标</h3><p>比赛的任务就是通过给定的频谱图预测对应的标签：0或者1在这场比赛中，利用算法来识别异常的信号。数据由二维数组组成，因此计算机视觉中可能会有一些方法，可能涉及的知识包括数字信号处理，异常检测等。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20210817224014119.png" alt=""></p><h3 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h3><p>Submissions are evaluated on area under the ROC curve between the predicted probability and the observed target.</p><h3 id="赛题赛程"><a href="#赛题赛程" class="headerlink" title="赛题赛程"></a>赛题赛程</h3><ul><li>July 21, 2021 - Entry Deadline.</li><li>July 21, 2021 - Team Merger Deadline.</li><li>July 28, 2021 - Final Submission Deadline.</li></ul><h3 id="赛题数据"><a href="#赛题数据" class="headerlink" title="赛题数据"></a>赛题数据</h3><p>赛题数据与频谱图类似，但通常跨越几个GHz的无线电频谱。数据存储为滤波器组格式或HDF5格式文件。</p><p>通过交替观测来做到这一点：在恒星“A”上观察 5 分钟，然后在恒星“B”上观察 5 分钟，然后回到恒星“A”上 5 分钟，然后是“C” ”，然后回到“A”，然后在“D”星上用 5 分钟结束。一组六个观察值 (ABACAD) 被称为“节奏”。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20210817224118204.png" alt="异常样本"></p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20210817232838744.png" alt="正常样本"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;比赛链接：&lt;a href=&quot;https://www.kaggle.com/c/seti-breakthrough-listen&quot;&gt;https://www.kaggle.com/c/seti-breakthrough-listen&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;比赛名称：SETI Breakthrough Listen - E.T. Signal Search&lt;/p&gt;
&lt;p&gt;比赛内容：利用算法来识别异常的信号，CV类型赛题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kaggle" scheme="http://yuanquanquan.top/tags/kaggle/"/>
    
  </entry>
  
  <entry>
    <title>MLB Player Digital Engagement Forecasting</title>
    <link href="http://yuanquanquan.top/2021/2202210803/"/>
    <id>http://yuanquanquan.top/2021/2202210803/</id>
    <published>2021-08-03T12:16:23.000Z</published>
    <updated>2021-08-17T15:22:35.036Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录一次kaggle比赛，这次比赛的场景主要通过MLB球员的历史表现数据、社交媒体数据以及市场规模等团队因素来预测在未来MLB 球员的数字内容互动趋势（社交媒体互动）。建立的模型将预测出MLB球员在未来的数字内容互动趋势指数（target1- target4）。</p></blockquote><span id="more"></span> <hr><p><img src="https://www.googleapis.com/download/storage/v1/b/kaggle-user-content/o/inbox%2F603584%2Ff7c0669c09db26bd45f76ade61b2a91f%2FGoogleCloud_MLB_Lockup.jpg?generation=1623359034713516&amp;alt=media" alt=""></p><h1 id="MLB-Player-Digital-Engagement-Forecasting"><a href="#MLB-Player-Digital-Engagement-Forecasting" class="headerlink" title="MLB Player Digital Engagement Forecasting"></a>MLB Player Digital Engagement Forecasting</h1><h3 id="比赛背景与任务："><a href="#比赛背景与任务：" class="headerlink" title="比赛背景与任务："></a>比赛背景与任务：</h3><p>A player hits a walk-off home run. A pitcher throws a no-hitter. A team gets red hot going into the Postseason. We know some of the catalysts that increase baseball fan interest. Now Major League Baseball (MLB) and Google Cloud want the Kaggle community’s help to identify the many other factors which pique supporter engagement and create deeper relationships betweens players and fans.</p><p>The sport has a long history of being numbers-driven. Nearly every day from at least April through October, baseball fans watch, read, and search for information about players. Which individuals they seek can depend on player performance, team standings, popularity, among other, currently unknown factors—which could be better understood thanks to data science.</p><p>Since at least the early 1990s, MLB has led the sports world in the use of data, showing fans, players, coaches, and media what’s possible when you combine data with human performance. MLB continues its leadership using technology to engage fans and provide new fans innovative ways to experience America’s Favorite Pastime.</p><p>MLB has teamed up with Google Cloud to transform the fan experience through data. Google Cloud proudly supports this Kaggle contest to celebrate the launch of Vertex AI: Google Cloud’s new platform to unify your ML workflows.</p><p>In this competition, you’ll predict how fans engage with MLB players’ digital content on a daily basis for a future date range. You’ll have access to player performance data, social media data, and team factors like market size. Successful models will provide new insights into what signals most strongly correlate with and influence engagement.</p><p>Imagine if you could predict MLB All Stars all season long or when each of a team’s 25 players has his moment in the spotlight. These insights are possible when you dive deeper into the fandom of America’s pastime. Be part of the first method of its kind to try to understand digital engagement at the player level in this granular, day-to-day fashion. Simultaneously help MLB build innovation more easily using Google Cloud’s data analytics, Vertex AI and MLOps tools. You could play a part in shaping the future of MLB fan and player engagement.</p><p>该赛题为<strong>时间序列</strong>任务，通过MLB球员的历史表现数据、社交媒体数据以及市场规模等团队因素来预测在未来MLB 球员的数字内容互动趋势（社交媒体互动）。建立的模型将预测出MLB球员在未来的数字内容互动趋势指数（target1- target4）。旨在为MLB 球迷和球员的未来社交媒体互动参与度挖掘价值。</p><p> 至少从 1990 年代初期开始，美国职业棒球大联盟就在使用数据方面领先于体育界，向球迷、球员、教练和媒体展示了将数据与人类表现相结合的可能性。MLB使用创新技术吸引球迷，并为新球迷提供体验美国最受欢迎的消遣的创新方式。 </p><p><strong>评价指标</strong>：MCMAE 计算四个目标变量中的每一个的平均绝对误差，得分是这四个MAE值的平均值</p><h3 id="方案简述"><a href="#方案简述" class="headerlink" title="方案简述"></a>方案简述</h3><p>通过竞赛提供的在2021赛季活跃的2055位MLB球员的四种不同的数字内容参与度 ( target1- target4)和对应的球员团队、历史比赛、历史得分情况、所获奖项、比赛事件等累计7.9G的历史数据信息(2021年1-4月)来结合机器学习构建MLB球员未来（2021年5月）数字内容互动趋势指数预测模型。通过季节性EDA、MLB球员历史信息统计后进行特征工程，分别使用ANN（人工神经网络）和LightGBM、CatBoost（集成学习）进行模型融合并对各模型的超参数进行了网格优化后在排行榜取得了铜牌的成绩。</p><h3 id="方案流程："><a href="#方案流程：" class="headerlink" title="方案流程："></a>方案流程：</h3><ol><li>mlb-ann-training：ANN模型训练代码</li><li>mlb-lightgbm-training：LightGBM模型训练代码</li><li>mlb-catboost-training：：CatBoost模型训练代码</li><li>全流程推理代码（特征提取、超参数调优、模型融合）</li></ol><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><p>I used ~440 features. In addition to joins and asof merge of basic tables, the following features were used:</p><ul><li>lag features per player<ul><li>Average of the last 7/28/70/360/720 days</li><li>Average over the on-seasons</li><li>Average for the same period in the previous year</li><li>Average of days with/without a game</li></ul></li><li>number of events, pitch events, action events</li><li>days from last rosters, awards, transactions and box scores</li><li>sum of box scores in the last 7/30/90 days</li><li>number of games and events in the day</li><li>event-level meta feature<ul><li>aggregation of predictions of model trained on event table</li><li>group by (date, playerId), (date, teamId) and (date)</li></ul></li></ul><h3 id="Cumcount-Leakage"><a href="#Cumcount-Leakage" class="headerlink" title="Cumcount Leakage"></a>Cumcount Leakage</h3><p>There is a strange correlation between the cumcount of the dataframe retrieved from the Time-Series API and the target.</p><p>I noticed this problem 3 days before the competition ended. I did not post it in the discussion as it might confuse the participants, but contacted the host immediately.<br>Adding this cumcount to the features only improves the CV a little bit, so it’s probably some kind of artifact or something, but even if it doesn’t improve the CV much, it’s better to shuffle the test data since it’s nonsense that the order of the rows makes sense.</p><p>I did not end up using this leak for final submission.</p><h3 id="Implementation-Note"><a href="#Implementation-Note" class="headerlink" title="Implementation Note"></a>Implementation Note</h3><p>Building a complex data pipeline in Jupyter Notebook with the Time Series API can be a big pain. I’ll share some of my efforts.</p><ul><li>Maintain the source code on GitHub and paste the BASE64-encoded code into the jupyter notebook<ul><li>see: <a href="https://github.com/lopuhin/kaggle-imet-2019">https://github.com/lopuhin/kaggle-imet-2019</a></li></ul></li><li>The inference notebook is also maintained on GitHub and automatically uploaded as the Kaggle Kernel through GitHub Actions</li><li>Avoid the use of pandas and instead use a dictionary of numpy arrays to manage state updates</li><li>Use the same feature generation function for training data and inference<ul><li>Both training and test are treated as streaming data, and features were generated using for-loop.</li><li>This is the most important point to get a stable and bug-free data pipeline</li><li>see: <a href="https://www.kaggle.com/c/riiid-test-answer-prediction/discussion/196942">https://www.kaggle.com/c/riiid-test-answer-prediction/discussion/196942</a></li></ul></li><li>Debug code locally using the API emulator<ul><li>Test the robustness of my inference pipeline by “dropout” some of the data returned by the emulator (a kind of “Chaos Engineering”)</li></ul></li><li>Catch exceptions in various functions and convert them to appropriate “default” values</li></ul><iframe src="https://nbviewer.jupyter.org/github/Bazingaliu/MLB-Player-Digital-Engagement-Forecasting/blob/main/4.%E5%85%A8%E6%B5%81%E7%A8%8Binference.ipynb" width="570" height="2000"></iframe> ]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录一次kaggle比赛，这次比赛的场景主要通过MLB球员的历史表现数据、社交媒体数据以及市场规模等团队因素来预测在未来MLB 球员的数字内容互动趋势（社交媒体互动）。建立的模型将预测出MLB球员在未来的数字内容互动趋势指数（target1- target4）。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="kaggle" scheme="http://yuanquanquan.top/tags/kaggle/"/>
    
  </entry>
  
  <entry>
    <title>网络单纯形法</title>
    <link href="http://yuanquanquan.top/2021/20210716/"/>
    <id>http://yuanquanquan.top/2021/20210716/</id>
    <published>2021-07-16T11:55:41.000Z</published>
    <updated>2021-08-17T15:31:13.185Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在实际应用中。迄今为止求解线性规划问题著名的仍是<strong>单纯形法</strong>。通过专业的实现，它具有卓越的性能：≈1000变量和≈1000约束的问题可以在0.1到0.5秒内得到解决。那么，是否可以尝试将该算法应用于图论中的问题呢？</p><p>​    事实上，最重要的网络优化问题都可以用线性规划来表示，比如确定最短路、最大流、最小费用流等。然而，直接应用通常的单纯形算法是没有意义的，因为所产生的程序将是<strong>笨拙(unwiedy)</strong>和<strong>高度退化的(highly degenerate)</strong>。这两个问题通过使用单纯形法的适当图论特殊化来避免：<strong>网络单纯形法</strong>。</p></blockquote><span id="more"></span><p>在此之前，我们先从<strong>最短路</strong>的故事说起。</p><p>   我们知道所有解决最短路问题的方法的基础是下面这样一个简单的想法：假设已知对每个v存在一条费用为π(v)的从r到v的有向路，并且我们找到一条满足π(v) + C(vw) &lt; π(w)的弧vw。由于把vw附加到从r到v的有向路可以得到一条到w的有向路，因此存在一条到w的费用为π(v) + C(vw)的更便宜的有向路。基于此，定义<strong>可行势（feasible potential）</strong>的概念是自然的：</p><ul><li><p><strong>Def1.</strong>如果π(v)是到v的有向路的最小费用，那么π满足π(v) + C(vw) ≥ π(w)，称π是一个可行势。</p><p> 可行势对最短路的费用给出了下界，我们有如下命题：</p></li><li><p><strong>Prop1.</strong>令π是可行势且P是从s到v的有向路，那么c(P)≥π(v).</p><p> 事实上，我们通过<strong>Ford算法</strong>在终止时得到了一个可行势和若干有向路，对它们来说上述命题中的等号成立。即有下面的定理陈述这个事实：</p></li><li><p><strong>Thm1.</strong> min{c(P):P是从s到t的有向路} = max{π(t):π可行势}</p><p> 我们可以通过这个陈述看到它与线性规划对偶性之间的联系。定理陈述中的最大化显然是一个线性规划问题：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20210725040907249.png" alt=""><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20210725040923491.png" alt=""></p><p><strong>对偶最优值定理</strong>告诉我们(P)(D)中有一个最优值存在，则两个最优值都存在且相等。注意到任何r到s的有向路P为(D)提供了一个可行解，则(D)的目标函数值恰好是P的费用，因此，定理1意味着，当最短路存在时，(D)有一个最优解，它是一条简单有向路的特征向量。这个结果将等价于结论：</p><ul><li><strong>Prop2</strong>. (D)的可行解多面体的顶点是简单有向路的特征向量.</li></ul><p>​    因为我们已经可以用Ford算法解决线性规划问题(D)，那么这个算法和单纯形法之间的联系是什么呢？单纯形法保存了一个“基”弧（对应于(D)中的基变量）的集合T，(D)的一个可行解x及向量y∈R^{V}，它们满足</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20210725040954255.png" alt=""></p><p>在每次迭代中，通过用集合外的一条弧替代集合中的一条，得到一个新的这样的集合。基弧的集合T必须对应于(D)的等式约束矩阵A的列极大线性无关组（列基）。事实上，这个矩阵就是图G的<strong>关联矩阵(incidence matrix)</strong>，它的列基可以用很好的方法来刻画。</p><ul><li><p><strong>Prop3.</strong>G:有向、连通，$A=\left{a_{e}: e \in E\right}$.集合$\left{a_{e}: e \in E\right}$是$A$的列基，当且仅当T是G的一颗生成树的弧集（<strong>ex.</strong>如果T不包含任何圈的弧集，那么它对应的列是线性无关的）</p><p>所以在这样的观察下，我们可以知道单纯形法是从生成树到生成树，每一步都可以看作是一序列的Ford算法步骤，她是一个被若干个不改变树的步骤所跟随着的通常步骤，直到y“追赶”为树。</p></li></ul><p>​    <strong>最大流问题</strong>同样是一个线性规划问题，所以通过线性规划对偶可以给出最大流的一个好的刻画。那么，我们的一个自然的问题就是这种刻画与我们通过割所给出的刻画有什么联系。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20210725041025672.png" alt=""><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20210725041043901.png" alt=""></p><p>同样由对偶最优定理，我们可以给出经典的<strong>最大流-最小割定理</strong>的如下刻画：<img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20210725041946529.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20210725041954142.png" alt=""></p><p>现在故事来到了最小费用流问题（MCFP），它的一个标准陈述如下：<img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20210725041311274.png" alt=""></p><p>我们·可以自然的写出其对应的线性规划形式：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20210724005804511.png" alt=""></p><p>作为一个重要的特例，我们想让其中每个u(e)都是无穷的，这样的问题称为<strong>转运问题(transshipment problem)</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20210724010218929.png" alt=""></p><p>设x是任意的b-流，即(P)的任意可行解，则由<strong>对偶最优定理</strong>，我们有如下结论：（互补松紧性条件给出了我们想要的最优性刻画）</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20210724010253027.png" alt=""></p><p>另外，下面两个观察是重要的：</p><ol><li>给定G中的一条路P。 定义P(关于c)的费用为∑(c(e) :e是P的正向弧)-∑ (c(e) :e是P的反向弧)。这样定义的原因是：假设我们在G中沿一条x-可扩路P发送ε单位的流，即xe在P的正向弧上提高了ε，在P的反向弧上降低了ε。那么cTx增加了∑(εce :e是P的正向弧)-∑ (εce :e是P的反向弧) ，即增加了ε倍的P的费用。特别的，如果x是(P)的可行解，那么某个负费用的x-可扩圈将给出一个费用更低的解。</li></ol><ol start="2"><li>对满足0≤x≤u的向量x，如同处理最大流时一样定义一个辅助有向图Gx，则G中每条x-可扩路对应于Gx中具有相同费用的一条有向路，特别的，G中一个负费用的x-可扩圈对应于Gx中一个负费用有向圈。</li></ol><p>于是我们就可以用最短路方法来确定Gx是否包含负费用有向圈。这便引出了下面对(P)的最优性的刻画：</p><ul><li><strong>Thm3</strong>.(P)的可行解x是最优的当且仅当不存在具有负费用c的x-可扩圈。</li><li><strong>(Klein 1967)</strong>(G,u,b,c). A b-flow f is of minimum cost iff there is no f-augmenting cycle with negative total weight iff there exists a feasible potential for (Gf , c).</li></ul><p>这是一条最重要的<strong>最优性准则</strong>。以上基本讲清了线性规划与最小费用流问题的联系。下面在我们正式将单纯形法应用于此之前，我们首先陈述这部分内容所需要的一些基本想法：</p><ul><li>假设问题定义在连通有向图G上（否则，限制在G的每个连通分支上处理即可）</li><li>可先对转运问题这一特殊情况进行分析（即假设对每条弧e有u(e)=∞）</li><li>定义转运问题的树解（支撑树解）</li><li>网络单纯形法保持可行的树解并且寻找一种特殊的负费用圈。(如果每个C(T,e)都具有非负费用，那么由T确定的树解x满足最优值定理的条件)</li><li>增加辅助边来找初始的树和流</li><li>避免循环：从一颗强可行树开始并使用离开弧规则(选择h是C(T,e)中第一条满足 x(h)=θ的反向弧)</li><li>网络单纯形法在有限步后会终止。</li><li>一般的，网络单纯形法将从树解移动到树解，只使用通过增加一条弧到T上形成的圈。</li></ul><p>我们首选对转运问题来定义树解，转运问题的支撑树解(spanning tree solution)是一个向量x∈R^{E}满足条件：对某棵树T，<img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20210725041834923.png" alt=""></p><p>树T和T的一条弧h=pq确定了将顶点氛围两部分R(T,h)和V\R(T,h)的一个划分如下：R(T,h)是在T中从r到v的简单路没有用到h的那些顶点v的集合。显然如图，r∈R(T,h)，h是T中唯一的一个端点在R(T,h)中，另一个端点不在R(T,h)中的弧。所以在与T相关的任何树解x中，流入R(T,h)的净流量一定是完全由h携带的。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20210725015500600.png" alt=""></p><p>这个观察将给我们下面的结果：</p><ul><li><p><strong>Prop4</strong>.一棵树T唯一地确定了它的树解.</p></li><li><p><strong>Prop5</strong>.(G:连通) 一个可行解是树解，当且仅当不存在每条弧都具有正流的圈。</p></li></ul><p>我们已经指出网络单纯形法是保持可行的树解并且寻找一种特殊的负费用圈，现在就给出这样的圈：<img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20210725015539193.png" alt=""></p><p>那么这种特殊类型的圈有什么优点呢？</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20210725015603770.png" alt=""></p><p><strong>Prop6</strong>.如果树T确定了可行树解x且对每个e不属于T，C(T,e)都具有非负费用。那么x是最优的。</p><p>有了上面的陈述，我们已经可以叙述我们心目中算法的初步形式：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20210725040144633.png" alt=""></p><p>这里立刻出现的一个问题是：<strong>如何找到初始的树和流。</strong>我们直接针对一般的最小费用流问题给出答案。</p><p>下面的命题演示了我们是如何从找到的圈中替换原来树上的一条弧从而实现“换基”操作的。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20210725040244874.png" alt=""></p><ul><li><strong>Def2</strong>.如果一棵树T确定了一个满足T中至少有一条弧携带0流的流x，那么我们说x是退化的。</li></ul><p>这直接引发了一个重要的理论问题：</p><p><strong>Q</strong>. 在一系列退化的迭代(改变树而不改变流的迭代只可能出现在流是退化的情况下)后，该算法会不会返回同一棵树？（循环，导致算法不能终止/另一方面，如果循环不发生，由于不同的树的数目是有限的，那么算法一定在有限步内终止。）</p><p>(注：循环是可能发生的[Cunningham]，但Cook提到“尽管据我们所知，迄今为止它从未在实际问题的解决中发生)</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20210725040310879.png" alt=""></p><p>令h=pq是T中的一条弧，我们说h在T中是远离(away from)r的，如果p∈R(T,h)；否则h在T中是朝向(toward)r的。上面由一棵树和一条弧导出的划分的图中弧h是远离r的。</p><ul><li><strong>Def3</strong>.一棵树T称为强可行的(strongly feasible)，如果它确定了一个可行流x，使得对T的每条满足xh=0的弧h，h在T中是远离r的。</li></ul><p>注意到如果流不是退化的，那么树平凡的满足这个条件，还注意到我们用来初始化算法的树是强可行的。现在假设我们从一棵强可行的树开始算法，并在算法的每一步，我们按如下规则选择弧h：</p><ul><li><strong>离开弧规则：</strong>选择h是C(T,e)中第一条满足x(h)=θ的反向弧。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20210725041729373.png" alt=""></p><ul><li><strong>Thm4.</strong> 如从一棵强可行树开始并使用离开弧规则的网络单纯形法在有限步后会终止。</li></ul><p>下面我们将转运问题的上述讨论直接扩展到解决一般的最小费用流问题的网络单纯形法，它也可以看作是对线性规划的有界变量单纯形法的一个解释。</p><ol><li><p>定义树解是一个向量x∈R^{E}，s.t.对某棵树T以及E\T的划分(L,U)我们有</p><p>fx(v)=b(v)，对所有v∈V；</p><p>x(e)=0，对所有e∈L；</p><p>x(e)=u(e)，对所有e∈U.</p></li><li><p>添加一条弧形成的圈C(T,L,U,e)满足以下性质：</p><p>C(T,L,U,e)的每条弧都是T∪{e}的元素；</p><p>如果e∈L，那么e是C(T,L,U,e)的正向弧，否则是反向弧；</p><p>C(T,L,U,e)的起点s是T中从v和w到r的简单路上的第一个公共顶点。</p></li><li><p>我们可以将之前得到的最优性定理拓展如下：</p></li></ol><ul><li><strong>Prop8</strong>.如果树(T,L,U)确定了可行树解x并且对每个e∉T,C(T,L,U,e)都有非负的费用，那么x是最优的。</li></ul><p>好，现在我们可以叙述本算法了。<img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/640-20210725040336007.png" alt=""></p><p>参考文献： Bernhard Korte and Jens Vygen《Combinatorial Optimization Theory and Algorithms(6th,2018)》</p><p>​         Cook等《Combinatorial Optimization》</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在实际应用中。迄今为止求解线性规划问题著名的仍是&lt;strong&gt;单纯形法&lt;/strong&gt;。通过专业的实现，它具有卓越的性能：≈1000变量和≈1000约束的问题可以在0.1到0.5秒内得到解决。那么，是否可以尝试将该算法应用于图论中的问题呢？&lt;/p&gt;
&lt;p&gt;​    事实上，最重要的网络优化问题都可以用线性规划来表示，比如确定最短路、最大流、最小费用流等。然而，直接应用通常的单纯形算法是没有意义的，因为所产生的程序将是&lt;strong&gt;笨拙(unwiedy)&lt;/strong&gt;和&lt;strong&gt;高度退化的(highly degenerate)&lt;/strong&gt;。这两个问题通过使用单纯形法的适当图论特殊化来避免：&lt;strong&gt;网络单纯形法&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="组合优化" scheme="http://yuanquanquan.top/tags/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>FFT的CUDA实现</title>
    <link href="http://yuanquanquan.top/2021/20210605/"/>
    <id>http://yuanquanquan.top/2021/20210605/</id>
    <published>2021-06-05T03:10:10.000Z</published>
    <updated>2021-06-05T06:15:35.196Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一维FFT算法在Maxwell架构上，归为访存密集算法。<br>即，在足够优化的情况下，可在一次memory copy的耗时内完成计算。</p><p>本文实现的FFT算法达到与官方库cuFFT一致的速度，通过整合kernel，可实现比调用CUFFT更快的算法整体执行速度。在处理65536*4以上大点数一维FFT+IFFT计算时（一个大核心共享内存放不下完整的一维FFT数据），组合算法可以实现比CUFFT少2个kernel调用的时间（减少两次显存数据交换），主要说明4096点FFT算法设计的思路及实现。大点数仅说明方法和测试结果。</p></blockquote><span id="more"></span><h2 id="算法原理及设计思路"><a href="#算法原理及设计思路" class="headerlink" title="算法原理及设计思路"></a>算法原理及设计思路</h2><p>本节说明快速傅里叶变换（Fast Fourier Transform）的原理和数值计算过程，重介绍能发挥GPU架构优势的算法类型。</p><h3 id="常规FFT实现（Cooley-Tukey）"><a href="#常规FFT实现（Cooley-Tukey）" class="headerlink" title="常规FFT实现（Cooley-Tukey）"></a>常规FFT实现（Cooley-Tukey）</h3><h4 id="公式推导与计算结构"><a href="#公式推导与计算结构" class="headerlink" title="公式推导与计算结构"></a>公式推导与计算结构</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image-20210605141428000.png" alt=""></h4><p>旋转因子W具有对称、周期、可约的特点：<br>$$<br>\begin{array}{c}<br>W_{N}^{k+\frac{N}{2}}=-W_{N}^{k} \<br>W_{N}^{2 k r}=e^{-j \frac{2 \pi}{N} 2 k r}=e^{-j \frac{2 \pi}{N / 2} k r}=W_{N / 2}^{k r} \<br>W_{N}^{2}=e^{-j \frac{2 \pi}{N} 2}=e^{-j \frac{2 \pi}{N / 2}}=W_{N / 2}^{1}<br>\end{array}<br>$$<br>Cooley和Tukey利用旋转因子的特性，将DFT进行奇偶分解：<br>$$<br>\begin{aligned}<br>X(k) &amp;=D F T[x(n)]=\sum_{n=0}^{N-1} x(n) W_{N}^{n k}=\sum_{r=0}^{N / 2-1} x(2 r) W_{N}^{2 r k}+\sum_{r=0}^{N / 2-1} x(2 r+1) W_{N}^{(2 r+1) k} \<br>&amp;=\sum_{r=0}^{N / 2-1} x_{1}(r) W_{N}^{2 r k}+W_{N}^{k} \sum_{r=0}^{N / 2-1} x_{2}(r) W_{N}^{2 r k}=\sum_{r=0}^{N / 2-1} x_{1}(r) W_{N / 2}^{r k}+W_{N}^{k} \sum_{r=0}^{N / 2-1} x_{2}(r) W_{N / 2}^{r k} \<br>&amp;=X_{1}(k)+W_{N}^{k} X_{2}(k)<br>\end{aligned}<br>$$<br>式中，$X_1(k)$ 和$X_2(k)$ 分别是$X_1(r)$和$X_2(r)$的N/2点DFT。</p><p>分解之后只得到N/2点的序列，而$X(k)$有N点，还要计算另一半项数的结果，利用旋转因子的周期性：<br>$$<br>X_{1}\left(\frac{N}{2}+k\right)=\sum_{r=0}^{N / 2-1} x_{1}(r) W_{N / 2}^{r(N / 2+k)}=\sum_{r=0}^{N / 2-1} x_{1}(r) W_{N / 2}^{r k}=X_{1}(k)<br>$$</p><p>前半部分：<br>$$<br>X(k)=X_{1}(k)+W_{N}^{k} X_{2}(k) \quad, \quad k=0,1, \ldots, \frac{N}{2}-1<br>$$<br>后半部分：<br>$$<br>X\left(\frac{N}{2}+k\right)=X_{1}\left(\frac{N}{2}+k\right)+W_{N}^{(k+N / 2)} X_{2}\left(\frac{N}{2}+k\right)=X_{1}(k)-W_{N}^{k} X_{2}(k) \quad, \quad k=0,1, \ldots, \frac{N}{2}-1<br>$$<br>因此，只要求出(0,N/2)区间内所有$X_1(k)$ 和$X_2(k)$ 值，即可求出(0,N-1)区间内所有$X(k)$值，<strong>计算量“减半”</strong>。</p><p>FFT算法有很多结构，但通常可归为两类，时域抽取法FFT（Decimation-In-Time FFT，简称DIT-FFT）和频域抽取法FFT（Decimation-In-Frequency FFT，简称DIF-FFT）。Cooley-Tukey方法的8点基2 FFT计算流程图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1bbip3hfrba1d9h11uu13da1hmq2n-20210605141027100.png" alt=""><br>图1. 8点基2 DIT-FFT计算流程图</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1bbip3o5v1lb91ml77n6pnsc6734-20210605141030680.png" alt=""><br>图2. 8点基2 DIF-FFT计算流程图</p><p>从图1和图2可以清晰地看出Cooley-Tukey方法的特点：</p><ul><li>从输入输出来看，DIT-FFT需要先把顺序数据倒序（Bit-reverse），再进行计算，可以得到顺序的计算结果。DIF-FFT直接用顺序数据计算，但是得到的结果是倒序的，如果需要顺序结果，还要进行处理。</li><li>从计算结构来看，DIT-FFT和DIF-FFT具有相反的计算结构，DIT-FFT的计算跨度（stride）是2L ，即1,2,4…2L-1 ，DIF-FFT的计算跨度相反。</li><li>从计算过程来看，Cooley-Tukey方法具有原址（In-place）计算的特点，一个蝶形单元的计算结果还是放到原来的位置，不需要分配暂存空间。</li></ul><p>DFT与基-2 Cooley-Tukey DIT-FFT的程序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void DFTImag(Complex *Input, Complex *Output, int Amount)</span><br><span class="line">&#123;</span><br><span class="line">    int k, n;</span><br><span class="line">    Complex tmp;</span><br><span class="line">    float SumRe, SumIm, ReFactor, ImFactor, TAOPTK;</span><br><span class="line">    float TAOP = 2 * my_Pi / Amount;</span><br><span class="line">    for (k = 0; k &lt; Amount; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        SumRe = 0; SumIm = 0;</span><br><span class="line">        TAOPTK = TAOP*k;</span><br><span class="line">        for (n = 0; n &lt; Amount; n++)</span><br><span class="line">        &#123;</span><br><span class="line">            ReFactor = cos(TAOPTK * n);</span><br><span class="line">            ImFactor = -sin(TAOPTK * n);</span><br><span class="line">            tmp = Input[n];</span><br><span class="line">            SumRe += tmp.x * ReFactor - tmp.y * ImFactor;   </span><br><span class="line">            SumIm += tmp.x * ImFactor + tmp.y * ReFactor;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.x = SumRe; tmp.y = SumIm;</span><br><span class="line">        Output[k] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void CTFFT_R2(Complex *array, Complex *array_out, unsigned int Power)</span><br><span class="line">&#123;</span><br><span class="line">    //---------------------init------------------</span><br><span class="line">    int len = pow((double)2, (int)Power);</span><br><span class="line">    bit_reverse(array, array_out, Power);            //倒序，数据放到array_out</span><br><span class="line">    //--------------------calcu------------------</span><br><span class="line">    for (int m = 2; m &lt;= len; m &lt;&lt;= 1)               //第一层计算单元：2  第二层：4   ...  第L层：2^L </span><br><span class="line">    &#123;</span><br><span class="line">        int mh = m &gt;&gt; 1;                             //单元计算跨度 1 2 4 </span><br><span class="line">        for (int i = 0; i &lt; mh; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Complex wi = exp_calcu(-i*(my_Pi / mh)); //本来(2*pi/m) &gt;&gt; pi/(mh)  </span><br><span class="line">            for (int j = i; j &lt; len; j += m)         //j  第一层0 2 4 6   第二层0 4 (8&gt;=len 跳出)</span><br><span class="line">            &#123;                                                </span><br><span class="line">                Complex u = array_out[j];</span><br><span class="line">                Complex t = complx_mul(wi, array_out[j + mh]);</span><br><span class="line">                array_out[j] = complx_add(u, t);</span><br><span class="line">                array_out[j + mh] = complx_sub(u, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本机CPU端计算4096点结果：<br>DFT的时间在2000ms左右，而FFT是4ms （Debug模式）。<br>DFT的时间在800ms左右，而FFT在1ms以内 （Release模式）。</p><p><strong>考虑到GPU的硬件架构，并行化Cooley-Tukey FFT算法存在以下问题：</strong></p><h4 id="倒序计算"><a href="#倒序计算" class="headerlink" title="倒序计算"></a><strong>倒序计算</strong></h4><p>​    数据倒序是对序列进行奇偶抽取的结果，倒序（bit reverse）是按位进行的，把数据的MSB和LSB反向，一个简单例子是0010 0000 =&gt; 0000 0100。下面分别是8bit倒序的较快算法，本文实现的根据数据位宽倒序的算法和CUDA MATH API中的32bit数据倒序程序调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned char reverse_8bit(unsigned char x)</span><br><span class="line">&#123;</span><br><span class="line">    x = (((x &amp; 0xaa) &gt;&gt; 1) | ((x &amp; 0x55) &lt;&lt; 1));  // 交换每两位</span><br><span class="line">    x = (((x &amp; 0xcc) &gt;&gt; 2) | ((x &amp; 0x33) &lt;&lt; 2));  // 交换每四位中的前两位和后两位</span><br><span class="line">    return((x &gt;&gt; 4) | (x &lt;&lt; 4));                  // 交换前后两个4bit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">unsigned int </span><br><span class="line">index_rv(unsigned int index, unsigned int Power)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int tmp = 0;</span><br><span class="line">    unsigned int bit_value = 0;</span><br><span class="line">    //power*6的计算量</span><br><span class="line">    for (int i = 0; i &lt; Power; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bit_value = index &amp; 1;</span><br><span class="line">        tmp += (bit_value &lt;&lt; ((Power - 1) - i));</span><br><span class="line">        index = index &gt;&gt; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以看出，通常情况下要对数据进行几十次操作才能得出倒序结果。测试中使用了CUDA的库函数进行倒序，并没有比reverse_8bit快。另一个问题是，FFT kernel占用较多硬件资源，一个大核心只能保证2到3个block占用。<br>大量倒序计算在一些情况下会使访存密度降低（<strong>这里的意思是，在做到足够优化的情况下，算法是访存密集的，如果计算量再增加，就是计算密集的了，相同数据量的算法执行时间会增加</strong>），测试结果如下，左边表格是全带宽占用结果，红色箭头处带宽占用不满：<br><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1bbiphbb91p9g1qskdoj77q1nki3h.png" alt=""><br>图3. 倒序与否kernel带宽占用测试对比</p><p>​    本文想到的解决办法是，使用查找表，通过纹理缓冲从显存中读取倒序索引（不占用共享内存），24KB的L1 cache基本满足小点数查找表需求，大点数会由于片上存不下，需要多次访问显存。</p><p>但倒序的计算还不是影响算法速度的关键因素。</p><h4 id="倒序存储"><a href="#倒序存储" class="headerlink" title="倒序存储"></a><strong>倒序存储</strong></h4><p>《Maxwell硬件架构与编程方法》中详细说明了GPU存储结构和使用注意事项，从算法局部性考虑，FFT算法的输入数据需要从显存顺序读到片上，在共享内存中进行倒序。而共享内存分为32个32bit的存储体（bank），在这一级倒序读取或存储都会导致存储体冲突（bank conflict）。根据倒序特点和单精度浮点的复数数据结构（两个float），实际地共享内存带宽占用仅有1/16。实测结果与理论分析一致：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1bbiqa74thds13skf671bo11jsj3u.png" alt=""><br>图4. 无冲突共享内存访问测试</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1bbiqaft7pq7fub1t4cg51nhv4b.png" alt=""><br>图5. 倒序冲突共享内存访问测试</p><p>​    注意，图4和图5中的数据量不同，表格第二列是传输数据量，在无冲突访存时，加载数据量=存储数据量=实际数据量。在有冲突时，数据需要排队，而每次传输数据都是32<em>32bit，所以浪费了很多带宽。图9中，加载数据量=实际数据量，倒序存储量=16</em>实际数据量，即有效带宽占用仅为全带宽的1/16。</p><p>​    本文还做了一个无冲突共享内存访问基准测试。Maxwell架构下，数据从显存读入片上，在保证完整占用显存带宽的情况下，可以在片上进行12次无冲突的数据交换，即24次存储或读取。而一次数据倒序存储就使用了16/24的时间，那么留给计算的时间就远远不够了。<br>所以，要高效地利用GPU计算和存储资源，就应尽量避免倒序。</p><h4 id="非向量化的数据抽取方式"><a href="#非向量化的数据抽取方式" class="headerlink" title="非向量化的数据抽取方式"></a><strong>非向量化的数据抽取方式</strong></h4><p>​    使用CUDA并行编程，数据是按1个warp，32个线程为基本单位读取的，再加上GPU存储器特点，并行化的算法数据存取结构尽可能实现连续无间隔地访存。先不考虑倒序，以32点DIT-FFT为例：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1bbiqfa8ulvg1psnas1dp51mut4o-20210605135223962.png" alt=""><br>图6. 32点DIT-FFT 数据抽取流程示意</p><p>​    因为是浮点复数，占用64bit，相当于有16个64bit的bank。假设用16个线程来计算，那么第一级数据的第一次读取是0-15号线程读取数据0 , 2 , … , 30。其中0,2,4,6,8,10,12,14与16,18,20,22,24,26,28,30存在bank conflict，第二次读取同理。即第一次读取有一半的bank存在冲突，共享内存带宽利用率只有一半，第一次存储同理。第二级数据可以也类似，访问索引0,4,8,12,1,5,9,13的数据被合并到一起访问，与16,20,24,28,17,21,25,29冲突……直到最后一级（32点基-2运算共5级，图中值标了前4级，最后一级类似图4的stage3）才能分别连续访问0-15与16-31，利用完整带宽。前4级的数据交换共8次，实际消耗了16次无冲突数据交换的时间，浪费了1/2的带宽。</p><p>采用基-4结构的话，只有前两级有存储冲突，但每级带宽利用率是1/4，与基-2是等效的。基-8，基-16的计算结构同理，好处是后续计算级数更少。</p><p><strong>理论和基准测试结果表明，采用传统的FFT计算结构不利于在GPU架构上高效地进行计算。</strong></p><h3 id="向量化的DFT分解方法（Stockham-Autosort-Framework）"><a href="#向量化的DFT分解方法（Stockham-Autosort-Framework）" class="headerlink" title="向量化的DFT分解方法（Stockham Autosort Framework）"></a>向量化的DFT分解方法（Stockham Autosort Framework）</h3><h4 id="计算分解与结构"><a href="#计算分解与结构" class="headerlink" title="计算分解与结构"></a><strong>计算分解与结构</strong></h4><p>​    离散傅里叶变换可以非常多形式的分解，Cooley-Tukey FFT很好的减少了算法的空间占用（原址计算），但也存在数据倒序的问题。本小节说明Stockham结构的FFT实现，Stockham 方法以空间占用为代价避免了Cooley-Tukey过程的倒序计算。它的自动倒序结构背后的思想是把数据倒序和蝶形计算结合起来。</p><p>​    上一小节提到过DFT的矩阵形式, 可以简记为 $F(N)=W^{k n} f(k)$ 和 $f(k)=\frac{1}{N} W^{-k n} F(N)$ 。从矩阵分解的角度看, Cooley-Tukey FFT做了以下处理：倒序步骤用矩阵表示是一个置换矩阵 $P_{n}^{T} ;$ 包含旋转因子大矩阵 $W^{k n}$ 被分解为许多级<br>Tukey FFT可用矩阵表示为 $X(N)=F_{n} x(k)=A_{t} \cdots A_{1} P_{n}^{T} x(k)$ 。即数据经倒序和t级基-2运算，最终得到与原始 DFT计算方法相同的傅里叶变换结果。<br>​    用同样的方式说明Stockham的方法。与Cooley-Tukey显式的置换 $F_{n}=A_{t} \cdots A_{1} P_{n}^{T}$ 不同，Stockham通过置换矩陈 $\Gamma_{0} \cdots \Gamma_{t-1}$ 使得 $F_{n}=A_{t} \Gamma_{t-1} \cdots A_{2} \Gamma_{1} A_{1} \Gamma_{0}$, 即 $X(N)=F_{n} x(k)=A_{t} \Gamma_{t-1} \cdots A_{2} \Gamma_{1} A_{1} \Gamma_{0} x(k)$</p><p>对比两者的计算过程：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1bbirag192o5dihvum10748sh5i.png" alt=""></p><p>Cooley-Tukey 方法首先把输入序列x完整地倒序，再进行各级蝶形计算。Stockham 方法把倒序结构和蝶形计算结合起来，在进行蝶形计算之前将序列x进行部分倒序，经过多级倒序和计算之后，得到与和Cooley-Tukey 方法相同的计算结果。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1bbirbbse2h31t7a10e2lpamhd5v.png" alt=""><br>图7. 8点基-2 Stockham FFT计算流程图（DIT）<br><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1bbirbgnt12t71c3g15ka1oi31ul16c.png" alt=""><br>图8. 8点基-2 Stockham FFT计算流程图（DIF）</p><p>图7和图8画出了DIT 和DIF两种Stockham FFT的计算流程，可以总结出以下特点：</p><ul><li>输入输出都是顺序的，没有显式的倒序步骤。</li><li>（级间有倒序处理）计算是非原址的（Out-place），蝶形单元的计算结果可能会覆盖还没计算的数据，这就要求分配和序列长度相等的空间用来存储。</li><li>Stockham DIT-FFT的数据读取索引是不变的，蝶形单元的数据存储跨度（stride）根据所在级数（stage）由1，2，一直到2L-1；DIF-FFT的数据存储索引是不变的，蝶形单元的数据读取跨度（stride）根据所在级数（stage）由1，2，一直到2L-1。这里，DIF的计算结构基本上与DIT相反，但计算结果一致。</li></ul><h4 id="算法实现与数据抽取"><a href="#算法实现与数据抽取" class="headerlink" title="算法实现与数据抽取"></a><strong>算法实现与数据抽取</strong></h4><p>把《Computational Frameworks for the Fast Fourier Transform》书中1.7节的Stockham 基-2算法（书P57，PDF的第75页）用C语言实现如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1bbire059msc1o931bl61sth14k76p.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void stockham_fft_R2(Complex* x, Complex* y, int len, int power)</span><br><span class="line">&#123;</span><br><span class="line">    Complex wi, tau;</span><br><span class="line">    int L, L_d2, stride, stride_m2;</span><br><span class="line">    for (int q = 1; q &lt;= power; q++)</span><br><span class="line">    &#123;</span><br><span class="line">                                             //L*r=len</span><br><span class="line">        L         = pow((double)2, q);       //L      : 2 4 8 ... 计算组大小</span><br><span class="line">        stride    = len / L;                 //stride ：...4 2 1 计算组内的跨度</span><br><span class="line">        L_d2      = L / 2;</span><br><span class="line">        stride_m2 = len / L_d2;</span><br><span class="line">        memcpy(y, x, len * sizeof(Complex));</span><br><span class="line">        for (int j = 0; j &lt; L_d2; j++)       //j只有L的一半（R-2蝶形计算 两个一组）</span><br><span class="line">        &#123;</span><br><span class="line">            wi = exp_calcu(-j*(2 * my_Pi / L));</span><br><span class="line">            for (int k = 0; k &lt; stride; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                tau = complx_mul(wi, y[j*stride_m2 + k + stride]);</span><br><span class="line">                x[j*stride + k] = complx_add(y[j*stride_m2 + k], tau);</span><br><span class="line">                x[(j + L_d2)*stride + k] = complx_sub(y[j*stride_m2 + k], tau);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以32点Stockham 基-2 DIT-FFT计算过程的数据抽取为例。由图9可知：前4级都可实现向量化数据读取，向量化长度分别为16、8、4、2，最后一级跨度为2，不是连续的访问；所有级的数据存储都是长度为16的向量化访问。数据读取的向量化长度是和计算点数有关的，比如256点的计算，向量化长度就会是128、64、32、16、8、4、2，以此类推。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1bbiriqhu151m1f042juaeu1d2676.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1bbirj163rvm1o3rv0lj681k0i7j.png" alt=""><br>图9. 32点Stockham 基-2 DIT-FFT算法的数据抽取示意（共5级）</p><p>结合GPU硬件，共享内存有16个64bit的bank，基-2计算在向量化访问长度为8、4、2、1（为表述方便，把最后一级也加进来，后同）的计算级，带宽利用率都是1/2。如果用基-4作为基本蝶形单元的话，256点计算级数为4级，访存的向量化长度是64、16、4、1，最后两级的带宽利用率为1/4，与基-2计算的4级1/2带宽利用率等效，但计算级数与基-2相比减少一半。</p><p>相比Cooley-Tukey方法Stockham FFT在GPU上实现，可以避免倒序计算和倒序存储两个重要问题。而且CUDA的线程以32个为最小单位同时执行，是向量化的处理机制，Stockham FFT中各级数据的向量化访问，非常适合用GPU来实现。虽然也有存储冲突问题，但在当前架构下基-4计算的(8-2)/24的冲突是可以接受的，剩下的时间可以完成FFT计算。GPU拥有寄存器、共享内存、片外显存的存储层次，Stockham计算的非原址问题并没有影响。在两级计算过程中，线程有足够的寄存器资源把共享内存中的数据全部读出，并行计算，再放回共享内存。</p><p>所以本文在GPU上的FFT算法实现，采用Stockham方法。下一节将会叙述Stockham FFT的CUDA实现。</p><hr><h2 id="4096点STFFT基本实现"><a href="#4096点STFFT基本实现" class="headerlink" title="4096点STFFT基本实现"></a>4096点STFFT基本实现</h2><h3 id="计算框架与工程方法"><a href="#计算框架与工程方法" class="headerlink" title="计算框架与工程方法"></a><strong>计算框架与工程方法</strong></h3><p>《Maxwell硬件架构与编程方法》中介绍过Maxwell架构下，每个大核心（SMM）内部有128个小核心（Core）、65536个32bit的寄存器文件（Register File）和96KB的共享内存空间（Shared Memory）。在软件层面，每个线程（thread）最多使用256个寄存器，每个线程块（blcok）最多分配1024个线程，最多占用65536个寄存器和49152bytes的共享内存。</p><p>49152bytes共享内存可存储12288个单精度浮点数据（FP32，4bytes），6144个复数（两个FP32）。由于FFT有多级数据交换，为了保证算法的运行时间，数据要放到片上计算，所以考虑到存储能力，理论上一次可以计算4096点。故从共享内存看，每个block需要32768bytes空间，一个大核心可以保证3个block的占用。</p><p>寄存器方面，为了4096点计算同时进行，需要8192个32bit寄存器用于数据存储，数值计算过程也会占用寄存器资源，后续还会说到寄存器占用情况和优化方法。实际上寄存器还有盈余，所以8192点的计算也可以勉强在片上一次性完成计算。</p><p>由上述架构特点和前一节的理论分析，采用如下计算框架：</p><ul><li>基-4作为基本蝶形计算单元，6级基-4完成4096点的Stockham FFT计算。</li><li>每个block分配4096*8bytes = 32768bytes的共享内存空间用于级间数据交换。</li><li>每个block分配256个线程，为同时计算4096点数据，每个线程一次读取16点数据进行处理。</li></ul><p>《Computational Frameworks for the Fast Fourier Transform》书中2.4.4节有Stockham 的基-4算法（书P105，PDF的第123页）：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1bbirv979a311sr1qpnnkn33180.png" alt=""></p><p>//201710回忆<br>//L*=L/4，应该是一个R4在L的组内抽取跨度<br>//r=n/L，是大组数<br>//W是按组内算的，所以中循环j</p><p>用C语言实现的代码较长，本文简介方法。</p><p>在C语言验证工程中，首先用递增数给序列赋值，再新建一个txt文件，调用stockham_fft_R4子程序完成计算后，<br>把结果放到txt文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> for (int i = 0; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        array[i].x = i;</span><br><span class="line">        array[i].y = i;</span><br><span class="line">    &#125;</span><br><span class="line">    char txtdataFileName[1024];</span><br><span class="line">    FILE * TxtWriter1;</span><br><span class="line">    sprintf(txtdataFileName, &quot;StockhamFFTdata.txt&quot;);</span><br><span class="line">    TxtWriter1 = fopen(txtdataFileName, &quot;wb&quot;);</span><br><span class="line">    stockham_fft_R4(array, FFTarray, len, power4, -1);</span><br><span class="line">    for (int i = 0; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(TxtWriter1, &quot;%f \r\n&quot;, array[i].x);</span><br><span class="line">        fprintf(TxtWriter1, &quot;%f \r\n&quot;, array[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">//---------------------------------------------------------------------------</span><br><span class="line">    for (int i = 0; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        array[i].x = i;</span><br><span class="line">        array[i].y = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sprintf(txtdataFileName, &quot;StockhamFFTindex.txt&quot;);</span><br><span class="line">    TxtWriter1 = fopen(txtdataFileName, &quot;wb&quot;);</span><br><span class="line">    stockham_fft_R4_index(array, FFTarray, len, power4, -1, TxtWriter1);</span><br></pre></td></tr></table></figure><p>在MATLAB中用同样的方法调用库函数fft()得到结果，把C语言工程的结果导入MATLAB，对比两个序列的相关系数、标准差和序列的插值，进行计算结果验证。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">clear all;</span><br><span class="line">n=<span class="number">0</span>:<span class="number">4095</span>;</span><br><span class="line">x=n+n*<span class="built_in">i</span>;</span><br><span class="line">Y=fft(x,<span class="number">4096</span>);</span><br><span class="line">Y=Y.&#x27;;       <span class="comment">%转置用了 共轭转置  应该用.&#x27;</span></span><br><span class="line">data_index=[<span class="string">&#x27;E:/StockhamFFTdata.txt&#x27;</span>];</span><br><span class="line">FFT4096 =(importdata(data_index));</span><br><span class="line">FFT4096_c=FFT4096(<span class="number">1</span>:<span class="number">2</span>:<span class="number">8192</span>)+<span class="built_in">j</span>*FFT4096(<span class="number">2</span>:<span class="number">2</span>:<span class="number">8192</span>);</span><br><span class="line">corrcoef(<span class="built_in">real</span>(FFT4096_c),<span class="built_in">real</span>(Y))</span><br><span class="line">corrcoef(<span class="built_in">imag</span>(FFT4096_c),<span class="built_in">imag</span>(Y))</span><br><span class="line">std(FFT4096_c)</span><br><span class="line">std(Y)</span><br><span class="line">err=Y-FFT4096_c;</span><br><span class="line"><span class="built_in">max</span>(err)</span><br></pre></td></tr></table></figure><p>本文在子程序stockham_fft_R4()的基础上设计了一个把各级FFT计算中的数据抽取索引，旋转因子计算索引打印到txt文档中的子程序stockham_fft_R4_index()。这样可以直观快速地查看数值计算过程，本文的后续实现也大量使用这种方法。</p><h3 id="CUDA实现"><a href="#CUDA实现" class="headerlink" title="CUDA实现"></a><strong>CUDA实现</strong></h3><h4 id="C语言验证"><a href="#C语言验证" class="headerlink" title="C语言验证"></a>C语言验证</h4><p>GPU端分配一个256线程的block进行计算，每个线程每次负责16个数据的计算，占用32768bytes的共享内存空间。每一级计算的数据抽取方式都不同。为尽快尝试和验证算法，本文首先在CPU端用的C语言模拟GPU的多线程并行情况，得到正确结果后再移植到CUDA C工程中。</p><p>输入序列首地址data_in，相同大小的暂存空间首地址data_out和计算方向direction（正向FFT计算，-1）。首先声明自动变量，index用于保存访存下标索引，wi_c和wi保存旋转因子的浮点和复数数据，16个Complex变量用于保存每个线程读取的16个数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StockhamR4_FFT_4096</span><span class="params">(Complex *data_in, Complex *data_tmp, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//---------------------init-------------------------</span></span><br><span class="line">    <span class="keyword">int</span>  index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> wi_c = <span class="number">0</span>;</span><br><span class="line">    Complex wi;</span><br><span class="line">    Complex r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16;</span><br></pre></td></tr></table></figure><p>下面是4096点FFT的第1层计算代码，一共6级计算，基本保持这样的形式。</p><p>通过256次for循环模拟256个线程的并行计算，变量tid代表线程号。</p><p>从序列data_in中抽取数据，由于非原址的结构，计算完成后为避免覆盖其他位置的数据，将结果存到data_tmp中，下一次再从data_tmp取数，计算后存到data_in……以此往复，直到计算完成。</p><p>寄存器r1,r2,r3,r4中保存的是一个基-4蝶形单元的数据，在第一级，4096点按基-4抽取，跨度4096/4=1024。所以同一个tid的r1,r2,r3,r4地址偏移按1024递增。第一组的4个数据抽取，在并行情况下256线程实际抽取了4096点数据的4个1024数据段中的前256个数据。所以之后的r5,r6,r7,r8在读取数据时，索引要加上256，以此类推。</p><p>读取数据后，每个线程计算4组基-4单元。这里调用了基础模块StockhamR4_block()，传入4个数据和1个旋转因子的地址，传入计算旋转因子需要的两个常数wi_c和index（根据线程不同，index不同；根据计算层级不同，wi_c同），图19中第一层旋转因子的基本常数wi_c是 -2π/4 ，而索引index都为0。</p><p>计算层级基本保持这一形式，由于数据存储方式不变，之后的示例仅截取for循环的前半部分进行说明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////Level in 4////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> tid = <span class="number">0</span>; tid &lt; <span class="number">256</span>; tid++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//本层 in out index 相同</span></span><br><span class="line">    r1  = data_in[tid + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">256</span> * <span class="number">0</span>];</span><br><span class="line">    r2  = data_in[tid + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">256</span> * <span class="number">0</span>];</span><br><span class="line">    r3  = data_in[tid + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">256</span> * <span class="number">0</span>];</span><br><span class="line">    r4  = data_in[tid + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">256</span> * <span class="number">0</span>];</span><br><span class="line">    r5  = data_in[tid + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">256</span> * <span class="number">1</span>];</span><br><span class="line">    r6  = data_in[tid + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">256</span> * <span class="number">1</span>];</span><br><span class="line">    r7  = data_in[tid + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">256</span> * <span class="number">1</span>];</span><br><span class="line">    r8  = data_in[tid + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">256</span> * <span class="number">1</span>];</span><br><span class="line">    r9  = data_in[tid + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">256</span> * <span class="number">2</span>];</span><br><span class="line">    r10 = data_in[tid + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">256</span> * <span class="number">2</span>];</span><br><span class="line">    r11 = data_in[tid + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">256</span> * <span class="number">2</span>];</span><br><span class="line">    r12 = data_in[tid + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">256</span> * <span class="number">2</span>];</span><br><span class="line">    r13 = data_in[tid + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">256</span> * <span class="number">3</span>];</span><br><span class="line">    r14 = data_in[tid + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">256</span> * <span class="number">3</span>];</span><br><span class="line">    r15 = data_in[tid + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">256</span> * <span class="number">3</span>];</span><br><span class="line">    r16 = data_in[tid + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">256</span> * <span class="number">3</span>];</span><br><span class="line">    wi_c = <span class="number">2</span> * my_Pi / <span class="number">4</span> * direction;</span><br><span class="line">    StockhamR4_block(&amp;r1,  &amp;r2,  &amp;r3,  &amp;r4,  &amp;wi, wi_c, <span class="number">0</span>);</span><br><span class="line">    StockhamR4_block(&amp;r5,  &amp;r6,  &amp;r7,  &amp;r8,  &amp;wi, wi_c, <span class="number">0</span>);</span><br><span class="line">    StockhamR4_block(&amp;r9,  &amp;r10, &amp;r11, &amp;r12, &amp;wi, wi_c, <span class="number">0</span>);</span><br><span class="line">    StockhamR4_block(&amp;r13, &amp;r14, &amp;r15, &amp;r16, &amp;wi, wi_c, <span class="number">0</span>);</span><br><span class="line">    data_tmp[tid + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">256</span> * <span class="number">0</span>] = r1;</span><br><span class="line">    data_tmp[tid + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">256</span> * <span class="number">0</span>] = r2;</span><br><span class="line">    data_tmp[tid + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">256</span> * <span class="number">0</span>] = r3;</span><br><span class="line">    data_tmp[tid + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">256</span> * <span class="number">0</span>] = r4;</span><br><span class="line">    data_tmp[tid + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">256</span> * <span class="number">1</span>] = r5;</span><br><span class="line">    data_tmp[tid + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">256</span> * <span class="number">1</span>] = r6;</span><br><span class="line">    data_tmp[tid + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">256</span> * <span class="number">1</span>] = r7;</span><br><span class="line">    data_tmp[tid + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">256</span> * <span class="number">1</span>] = r8;</span><br><span class="line">    data_tmp[tid + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">256</span> * <span class="number">2</span>] = r9;</span><br><span class="line">    data_tmp[tid + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">256</span> * <span class="number">2</span>] = r10;</span><br><span class="line">    data_tmp[tid + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">256</span> * <span class="number">2</span>] = r11;</span><br><span class="line">    data_tmp[tid + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">256</span> * <span class="number">2</span>] = r12;</span><br><span class="line">    data_tmp[tid + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">256</span> * <span class="number">3</span>] = r13;</span><br><span class="line">    data_tmp[tid + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">256</span> * <span class="number">3</span>] = r14;</span><br><span class="line">    data_tmp[tid + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">256</span> * <span class="number">3</span>] = r15;</span><br><span class="line">    data_tmp[tid + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">256</span> * <span class="number">3</span>] = r16;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按理论分析，第二层级以1024点为计算单元，还是基-4抽取，1024除以4，跨度是256。同理，第三层级计算单元为256点，内部跨度64；第四层级计算单元为64点，内部跨度16；第五层级计算单元为16点，内部跨度4；第六层级计算单元为4点，内部跨度1。</p><p>本文的设计是256线程并行，所以下面第二层级的数据抽取恰好是256*4个变量存一个1024计算单元，变量1-4、5-8、9-12、13-16分别是第1、2、3、4个1024计算单元内的基-4一组蝶形运算，对应旋转因子计算索引0、1、2、3。层级的旋转因子常数是-2π/16。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">r1  = data_tmp[tid + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">256</span> * <span class="number">0</span>];</span><br><span class="line">r2  = data_tmp[tid + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">256</span> * <span class="number">1</span>];</span><br><span class="line">r3  = data_tmp[tid + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">256</span> * <span class="number">2</span>];</span><br><span class="line">r4  = data_tmp[tid + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">256</span> * <span class="number">3</span>];</span><br><span class="line">r5  = data_tmp[tid + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">256</span> * <span class="number">0</span>];</span><br><span class="line">r6  = data_tmp[tid + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">256</span> * <span class="number">1</span>];</span><br><span class="line">r7  = data_tmp[tid + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">256</span> * <span class="number">2</span>];</span><br><span class="line">r8  = data_tmp[tid + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">256</span> * <span class="number">3</span>];</span><br><span class="line">r9  = data_tmp[tid + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">256</span> * <span class="number">0</span>];</span><br><span class="line">r10 = data_tmp[tid + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">256</span> * <span class="number">1</span>];</span><br><span class="line">r11 = data_tmp[tid + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">256</span> * <span class="number">2</span>];</span><br><span class="line">r12 = data_tmp[tid + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">256</span> * <span class="number">3</span>];</span><br><span class="line">r13 = data_tmp[tid + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">256</span> * <span class="number">0</span>];</span><br><span class="line">r14 = data_tmp[tid + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">256</span> * <span class="number">1</span>];</span><br><span class="line">r15 = data_tmp[tid + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">256</span> * <span class="number">2</span>];</span><br><span class="line">r16 = data_tmp[tid + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">256</span> * <span class="number">3</span>];</span><br><span class="line">wi_c = <span class="number">2</span> * my_Pi / <span class="number">16</span> * direction;</span><br><span class="line">StockhamR4_block(&amp;r1,  &amp;r2,  &amp;r3,  &amp;r4,  &amp;wi, wi_c, <span class="number">0</span>);</span><br><span class="line">StockhamR4_block(&amp;r5,  &amp;r6,  &amp;r7,  &amp;r8,  &amp;wi, wi_c, <span class="number">1</span>);</span><br><span class="line">StockhamR4_block(&amp;r9,  &amp;r10, &amp;r11, &amp;r12, &amp;wi, wi_c, <span class="number">2</span>);</span><br><span class="line">StockhamR4_block(&amp;r13, &amp;r14, &amp;r15, &amp;r16, &amp;wi, wi_c, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>第三层计算单元为256点，内部跨度为64点。并行的线程数是256，如果还是一次读取连续的256点，每个线程只能得到单元内的一个数据，不能计算，所以需要根据线程号来划分各自的计算区域。256点（计算单元长度）除以4（基-4计算变量个数）得到64，所以连续的64个线程负责一个256单元的计算。由于一共有16个变量，所以64个线程计算了4组256单元。整体情况是256个线程前4次读取了1024点数据，4组连续的64线程分别负责4块256单元的计算，后面3组4变量读取按照这种形式分别进行了1024点的计算。</p><p>如下面程序所示，与上两层计算不同，第三层首先计算了数据抽取索引index。线程号tid的范围0-255，tid&amp;(256 - 64)可以得到0、64、128、192四个数，即以64为单位将线程分为4组。每组线程负责256点的计算，所以 (tid&amp;(256 - 64)) <em> 4得到0、256、512、768。然后加上tid%64得到线程的组内序号。在读取数据时，以索引index为基地址，进行偏移即可，第三层级计算跨度为64，可以从图21看到读取方式符合这一形式。<br>第三层有16个256计算单元，所以基-4计算索引根据64线程组和4变量组得到：index = tid/64 + 4</em>(0 or 1 or 2 or 3)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//64threads 一组</span></span><br><span class="line">index = (tid&amp;(<span class="number">256</span> - <span class="number">64</span>)) * <span class="number">4</span> + tid % <span class="number">64</span>;</span><br><span class="line">r1 = data_in[index + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">64</span> * <span class="number">0</span>];</span><br><span class="line">r2 = data_in[index + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">64</span> * <span class="number">1</span>];</span><br><span class="line">r3 = data_in[index + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">64</span> * <span class="number">2</span>];</span><br><span class="line">r4 = data_in[index + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">64</span> * <span class="number">3</span>];</span><br><span class="line">r5 = data_in[index + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">64</span> * <span class="number">0</span>];</span><br><span class="line">r6 = data_in[index + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">64</span> * <span class="number">1</span>];</span><br><span class="line">r7 = data_in[index + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">64</span> * <span class="number">2</span>];</span><br><span class="line">r8 = data_in[index + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">64</span> * <span class="number">3</span>];</span><br><span class="line">r9 = data_in[index + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">64</span> * <span class="number">0</span>];</span><br><span class="line">r10 = data_in[index + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">64</span> * <span class="number">1</span>];</span><br><span class="line">r11 = data_in[index + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">64</span> * <span class="number">2</span>];</span><br><span class="line">r12 = data_in[index + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">64</span> * <span class="number">3</span>];</span><br><span class="line">r13 = data_in[index + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">64</span> * <span class="number">0</span>];</span><br><span class="line">r14 = data_in[index + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">64</span> * <span class="number">1</span>];</span><br><span class="line">r15 = data_in[index + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">64</span> * <span class="number">2</span>];</span><br><span class="line">r16 = data_in[index + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">64</span> * <span class="number">3</span>];</span><br><span class="line">wi_c  = <span class="number">2</span> * my_Pi / <span class="number">64</span> * direction;</span><br><span class="line">index = tid / <span class="number">64</span>;</span><br><span class="line">StockhamR4_block(&amp;r1,  &amp;r2,  &amp;r3,  &amp;r4,  &amp;wi, wi_c, index + <span class="number">4</span>*<span class="number">0</span>);</span><br><span class="line">StockhamR4_block(&amp;r5,  &amp;r6,  &amp;r7,  &amp;r8,  &amp;wi, wi_c, index + <span class="number">4</span>*<span class="number">1</span>);</span><br><span class="line">StockhamR4_block(&amp;r9,  &amp;r10, &amp;r11, &amp;r12, &amp;wi, wi_c, index + <span class="number">4</span>*<span class="number">2</span>);</span><br><span class="line">StockhamR4_block(&amp;r13, &amp;r14, &amp;r15, &amp;r16, &amp;wi, wi_c, index + <span class="number">4</span>*<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>根据之前的分析和第三层级的规律，容易得到之后层级的计算结构。要注意的是，共享内存有32个32bit的bank，到第四层级计算单元长度是64，基-4的计算跨度是16（16个64bit数据），恰好还能满足全带宽访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">index = (tid&amp;(<span class="number">256</span> - <span class="number">16</span>)) * <span class="number">4</span> + tid % <span class="number">16</span>;</span><br><span class="line">r1  = data_tmp[index + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">16</span> * <span class="number">0</span>];</span><br><span class="line">r2  = data_tmp[index + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">16</span> * <span class="number">1</span>];</span><br><span class="line">r3  = data_tmp[index + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">16</span> * <span class="number">2</span>];</span><br><span class="line">r4  = data_tmp[index + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">16</span> * <span class="number">3</span>];</span><br><span class="line">r5  = data_tmp[index + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">16</span> * <span class="number">0</span>];</span><br><span class="line">r6  = data_tmp[index + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">16</span> * <span class="number">1</span>];</span><br><span class="line">r7  = data_tmp[index + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">16</span> * <span class="number">2</span>];</span><br><span class="line">r8  = data_tmp[index + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">16</span> * <span class="number">3</span>];</span><br><span class="line">r9  = data_tmp[index + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">16</span> * <span class="number">0</span>];</span><br><span class="line">r10 = data_tmp[index + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">16</span> * <span class="number">1</span>];</span><br><span class="line">r11 = data_tmp[index + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">16</span> * <span class="number">2</span>];</span><br><span class="line">r12 = data_tmp[index + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">16</span> * <span class="number">3</span>];</span><br><span class="line">r13 = data_tmp[index + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">16</span> * <span class="number">0</span>];</span><br><span class="line">r14 = data_tmp[index + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">16</span> * <span class="number">1</span>];</span><br><span class="line">r15 = data_tmp[index + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">16</span> * <span class="number">2</span>];</span><br><span class="line">r16 = data_tmp[index + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">16</span> * <span class="number">3</span>];</span><br><span class="line">wi_c  = <span class="number">2</span> * my_Pi / <span class="number">256</span> * direction;</span><br><span class="line">index = tid / <span class="number">16</span>;</span><br><span class="line">StockhamR4_block(&amp;r1,  &amp;r2,  &amp;r3,  &amp;r4,  &amp;wi, wi_c, index + <span class="number">16</span>*<span class="number">0</span>);</span><br><span class="line">StockhamR4_block(&amp;r5,  &amp;r6,  &amp;r7,  &amp;r8,  &amp;wi, wi_c, index + <span class="number">16</span>*<span class="number">1</span>);</span><br><span class="line">StockhamR4_block(&amp;r9,  &amp;r10, &amp;r11, &amp;r12, &amp;wi, wi_c, index + <span class="number">16</span>*<span class="number">2</span>);</span><br><span class="line">StockhamR4_block(&amp;r13, &amp;r14, &amp;r15, &amp;r16, &amp;wi, wi_c, index + <span class="number">16</span>*<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>第五、六层的16点计算单元、内部跨度4和4点计算单元、内部跨度1都只能占用1/4的带宽（3/4 bank conflict）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////Level 1024////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> tid = <span class="number">0</span>; tid &lt; <span class="number">256</span>; tid++)</span><br><span class="line">&#123;</span><br><span class="line">    index = (tid&amp;(<span class="number">256</span> - <span class="number">4</span>)) * <span class="number">4</span> + tid % <span class="number">4</span>;</span><br><span class="line">    r1  = data_in[index + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">4</span> * <span class="number">0</span>];</span><br><span class="line">    r2  = data_in[index + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">4</span> * <span class="number">1</span>];</span><br><span class="line">    r3  = data_in[index + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">4</span> * <span class="number">2</span>];</span><br><span class="line">    r4  = data_in[index + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">4</span> * <span class="number">3</span>];</span><br><span class="line">    r5  = data_in[index + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">4</span> * <span class="number">0</span>];</span><br><span class="line">    r6  = data_in[index + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">4</span> * <span class="number">1</span>];</span><br><span class="line">    r7  = data_in[index + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">4</span> * <span class="number">2</span>];</span><br><span class="line">    r8  = data_in[index + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">4</span> * <span class="number">3</span>];</span><br><span class="line">    r9  = data_in[index + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">4</span> * <span class="number">0</span>];</span><br><span class="line">    r10 = data_in[index + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">4</span> * <span class="number">1</span>];</span><br><span class="line">    r11 = data_in[index + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">4</span> * <span class="number">2</span>];</span><br><span class="line">    r12 = data_in[index + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">4</span> * <span class="number">3</span>];</span><br><span class="line">    r13 = data_in[index + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">4</span> * <span class="number">0</span>];</span><br><span class="line">    r14 = data_in[index + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">4</span> * <span class="number">1</span>];</span><br><span class="line">    r15 = data_in[index + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">4</span> * <span class="number">2</span>];</span><br><span class="line">    r16 = data_in[index + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">4</span> * <span class="number">3</span>];</span><br><span class="line">    wi_c  = <span class="number">2</span> * my_Pi / <span class="number">1024</span> * direction;</span><br><span class="line">    index = tid / <span class="number">4</span>;</span><br><span class="line">    StockhamR4_block(&amp;r1,  &amp;r2,  &amp;r3,  &amp;r4,  &amp;wi, wi_c, index + <span class="number">64</span> * <span class="number">0</span>);</span><br><span class="line">    StockhamR4_block(&amp;r5,  &amp;r6,  &amp;r7,  &amp;r8,  &amp;wi, wi_c, index + <span class="number">64</span> * <span class="number">1</span>);</span><br><span class="line">    StockhamR4_block(&amp;r9,  &amp;r10, &amp;r11, &amp;r12, &amp;wi, wi_c, index + <span class="number">64</span> * <span class="number">2</span>);</span><br><span class="line">    StockhamR4_block(&amp;r13, &amp;r14, &amp;r15, &amp;r16, &amp;wi, wi_c, index + <span class="number">64</span> * <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>还要注意，第六层的计算结构与前面几层不同，一个线程负责连续4点数据的计算，所以读取索引是tid<em>4+1024</em>(0 or 1 or 2 or 3)+(0 or 1 or 2 or 3)。其他部分还是延续规律。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">r1  = data_tmp[tid * <span class="number">4</span> + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">0</span>];</span><br><span class="line">r2  = data_tmp[tid * <span class="number">4</span> + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">1</span>];</span><br><span class="line">r3  = data_tmp[tid * <span class="number">4</span> + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">2</span>];</span><br><span class="line">r4  = data_tmp[tid * <span class="number">4</span> + <span class="number">1024</span> * <span class="number">0</span> + <span class="number">3</span>];</span><br><span class="line">r5  = data_tmp[tid * <span class="number">4</span> + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">0</span>];</span><br><span class="line">r6  = data_tmp[tid * <span class="number">4</span> + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">1</span>];</span><br><span class="line">r7  = data_tmp[tid * <span class="number">4</span> + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">2</span>];</span><br><span class="line">r8  = data_tmp[tid * <span class="number">4</span> + <span class="number">1024</span> * <span class="number">1</span> + <span class="number">3</span>];</span><br><span class="line">r9  = data_tmp[tid * <span class="number">4</span> + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">0</span>];</span><br><span class="line">r10 = data_tmp[tid * <span class="number">4</span> + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">r11 = data_tmp[tid * <span class="number">4</span> + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">2</span>];</span><br><span class="line">r12 = data_tmp[tid * <span class="number">4</span> + <span class="number">1024</span> * <span class="number">2</span> + <span class="number">3</span>];</span><br><span class="line">r13 = data_tmp[tid * <span class="number">4</span> + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">0</span>];</span><br><span class="line">r14 = data_tmp[tid * <span class="number">4</span> + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">r15 = data_tmp[tid * <span class="number">4</span> + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">2</span>];</span><br><span class="line">r16 = data_tmp[tid * <span class="number">4</span> + <span class="number">1024</span> * <span class="number">3</span> + <span class="number">3</span>];</span><br><span class="line">wi_c  = <span class="number">2</span> * my_Pi / <span class="number">4096</span> * direction;</span><br><span class="line">index = tid;</span><br><span class="line">StockhamR4_block(&amp;r1,  &amp;r2,  &amp;r3,  &amp;r4,  &amp;wi, wi_c, index + <span class="number">256</span>*<span class="number">0</span>);</span><br><span class="line">StockhamR4_block(&amp;r5,  &amp;r6,  &amp;r7,  &amp;r8,  &amp;wi, wi_c, index + <span class="number">256</span>*<span class="number">1</span>);</span><br><span class="line">StockhamR4_block(&amp;r9,  &amp;r10, &amp;r11, &amp;r12, &amp;wi, wi_c, index + <span class="number">256</span>*<span class="number">2</span>);</span><br><span class="line">StockhamR4_block(&amp;r13, &amp;r14, &amp;r15, &amp;r16, &amp;wi, wi_c, index + <span class="number">256</span>*<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h4 id="CUDA-C实现"><a href="#CUDA-C实现" class="headerlink" title="CUDA C实现"></a>CUDA C实现</h4><p>根据C语言验证结果，把程序移植到GPU端，用CUDA实现。考虑到复用，将4096点的计算封装为一个inline模块，在编译时，模块会“嵌入” 到被调用的地方，而不是跳转调用。函数及参数声明如下，传递的是寄存器地址和共享内存首地址data_shared：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __device__ <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Stockham_4096_block</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Complex *r1,  Complex *r2,  Complex *r3,  Complex *r4,</span></span></span><br><span class="line"><span class="params"><span class="function">    Complex *r5,  Complex *r6,  Complex *r7,  Complex *r8,</span></span></span><br><span class="line"><span class="params"><span class="function">    Complex *r9,  Complex *r10, Complex *r11, Complex *r12,</span></span></span><br><span class="line"><span class="params"><span class="function">    Complex *r13, Complex *r14, Complex *r15, Complex *r16,</span></span></span><br><span class="line"><span class="params"><span class="function">    Complex *data_shared</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>总结第2、3、4、5层的数据抽取和计算规律，可以把这几层用一个for循环实现，如图26所示。要注意的是，数据的读取和存储都在共享内存上操作，所以在计算完成后需要调用线程同步API __syncthreads();（第30行），等所有线程都计算完成后，才一起把数据放回共享内存，以免覆盖了其他线程的计算数据。为保证for循环下次读取数据的正确性，在数据放回后后也需要进行线程同步。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////Level 16 64 256 1024///////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">64</span>;i=i*<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> inexd_tmp = <span class="number">256</span>/i;</span><br><span class="line">    index = (tid&amp;(<span class="number">256</span> - inexd_tmp))*<span class="number">4</span> + tid%inexd_tmp;</span><br><span class="line">    *r1  = data_shared[index + <span class="number">1024</span>*<span class="number">0</span> + inexd_tmp*<span class="number">0</span>];</span><br><span class="line">    *r2  = data_shared[index + <span class="number">1024</span>*<span class="number">0</span> + inexd_tmp*<span class="number">1</span>];</span><br><span class="line">    *r3  = data_shared[index + <span class="number">1024</span>*<span class="number">0</span> + inexd_tmp*<span class="number">2</span>];</span><br><span class="line">    *r4  = data_shared[index + <span class="number">1024</span>*<span class="number">0</span> + inexd_tmp*<span class="number">3</span>];</span><br><span class="line">    *r5  = data_shared[index + <span class="number">1024</span>*<span class="number">1</span> + inexd_tmp*<span class="number">0</span>];</span><br><span class="line">    *r6  = data_shared[index + <span class="number">1024</span>*<span class="number">1</span> + inexd_tmp*<span class="number">1</span>];</span><br><span class="line">    *r7  = data_shared[index + <span class="number">1024</span>*<span class="number">1</span> + inexd_tmp*<span class="number">2</span>];</span><br><span class="line">    *r8  = data_shared[index + <span class="number">1024</span>*<span class="number">1</span> + inexd_tmp*<span class="number">3</span>];</span><br><span class="line">    *r9  = data_shared[index + <span class="number">1024</span>*<span class="number">2</span> + inexd_tmp*<span class="number">0</span>];</span><br><span class="line">    *r10 = data_shared[index + <span class="number">1024</span>*<span class="number">2</span> + inexd_tmp*<span class="number">1</span>];</span><br><span class="line">    *r11 = data_shared[index + <span class="number">1024</span>*<span class="number">2</span> + inexd_tmp*<span class="number">2</span>];</span><br><span class="line">    *r12 = data_shared[index + <span class="number">1024</span>*<span class="number">2</span> + inexd_tmp*<span class="number">3</span>];</span><br><span class="line">    *r13 = data_shared[index + <span class="number">1024</span>*<span class="number">3</span> + inexd_tmp*<span class="number">0</span>];</span><br><span class="line">    *r14 = data_shared[index + <span class="number">1024</span>*<span class="number">3</span> + inexd_tmp*<span class="number">1</span>];</span><br><span class="line">    *r15 = data_shared[index + <span class="number">1024</span>*<span class="number">3</span> + inexd_tmp*<span class="number">2</span>];</span><br><span class="line">    *r16 = data_shared[index + <span class="number">1024</span>*<span class="number">3</span> + inexd_tmp*<span class="number">3</span>];</span><br><span class="line">    wi_c = <span class="number">-2</span>*FFT_Pi/(<span class="number">16</span>*i);</span><br><span class="line">    index = tid / inexd_tmp;</span><br><span class="line">    StockhamR4_block(r1,  r2,  r3,  r4,  &amp;wi, wi_c, index + i*<span class="number">0</span>);</span><br><span class="line">    StockhamR4_block(r5,  r6,  r7,  r8,  &amp;wi, wi_c, index + i*<span class="number">1</span>);</span><br><span class="line">    StockhamR4_block(r9,  r10, r11, r12, &amp;wi, wi_c, index + i*<span class="number">2</span>);</span><br><span class="line">    StockhamR4_block(r13, r14, r15, r16, &amp;wi, wi_c, index + i*<span class="number">3</span>);</span><br><span class="line">    __syncthreads();</span><br><span class="line">    data_shared[tid + <span class="number">1024</span>*<span class="number">0</span> + <span class="number">256</span>*<span class="number">0</span>] = *r1;</span><br><span class="line">    data_shared[tid + <span class="number">1024</span>*<span class="number">1</span> + <span class="number">256</span>*<span class="number">0</span>] = *r2;</span><br><span class="line">    data_shared[tid + <span class="number">1024</span>*<span class="number">2</span> + <span class="number">256</span>*<span class="number">0</span>] = *r3;</span><br><span class="line">    data_shared[tid + <span class="number">1024</span>*<span class="number">3</span> + <span class="number">256</span>*<span class="number">0</span>] = *r4;</span><br><span class="line">    data_shared[tid + <span class="number">1024</span>*<span class="number">0</span> + <span class="number">256</span>*<span class="number">1</span>] = *r5;</span><br><span class="line">    data_shared[tid + <span class="number">1024</span>*<span class="number">1</span> + <span class="number">256</span>*<span class="number">1</span>] = *r6;</span><br><span class="line">    data_shared[tid + <span class="number">1024</span>*<span class="number">2</span> + <span class="number">256</span>*<span class="number">1</span>] = *r7;</span><br><span class="line">    data_shared[tid + <span class="number">1024</span>*<span class="number">3</span> + <span class="number">256</span>*<span class="number">1</span>] = *r8;</span><br><span class="line">    data_shared[tid + <span class="number">1024</span>*<span class="number">0</span> + <span class="number">256</span>*<span class="number">2</span>] = *r9;</span><br><span class="line">    data_shared[tid + <span class="number">1024</span>*<span class="number">1</span> + <span class="number">256</span>*<span class="number">2</span>] = *r10;</span><br><span class="line">    data_shared[tid + <span class="number">1024</span>*<span class="number">2</span> + <span class="number">256</span>*<span class="number">2</span>] = *r11;</span><br><span class="line">    data_shared[tid + <span class="number">1024</span>*<span class="number">3</span> + <span class="number">256</span>*<span class="number">2</span>] = *r12;</span><br><span class="line">    data_shared[tid + <span class="number">1024</span>*<span class="number">0</span> + <span class="number">256</span>*<span class="number">3</span>] = *r13;</span><br><span class="line">    data_shared[tid + <span class="number">1024</span>*<span class="number">1</span> + <span class="number">256</span>*<span class="number">3</span>] = *r14;</span><br><span class="line">    data_shared[tid + <span class="number">1024</span>*<span class="number">2</span> + <span class="number">256</span>*<span class="number">3</span>] = *r15;</span><br><span class="line">    data_shared[tid + <span class="number">1024</span>*<span class="number">3</span> + <span class="number">256</span>*<span class="number">3</span>] = *r16;</span><br><span class="line">    __syncthreads();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，将计算模块进行<strong>for循环优化</strong>，可以<strong>减少寄存器资源占用</strong>。从目前的实际情况来看，即使不存在依赖，代码编译后寄存器的占用和代码长度成正相关。所以应尽可能把层级计算整合到for循环里，以减少占用。 只要单个线程的寄存器占用在80左右，在本文的情况下，就可达到每个大核心3个block的最大占用。</p><p>优化前寄存器占用在100个左右，只能达到2个block的占用，优化后寄存器占用降到46个，提升明显。</p><p>最后，本文把大量使用的Stockham基-4蝶形计算单元封装为inline模块，也就是将stockham_fft_R4()中的核心循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; L_d4; j++)</span><br><span class="line">&#123;</span><br><span class="line">    wi1 = exp_calcu(direction* j*(<span class="number">2</span> * my_Pi / L));</span><br><span class="line">    wi2 = complx_mul(wi1, wi1);</span><br><span class="line">    wi3 = complx_mul(wi1, wi2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; stride; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        alpha = y[j*stride_m4 + k];</span><br><span class="line">        beta = complx_mul(wi1, y[j*stride_m4 + <span class="number">1</span> * stride + k]);</span><br><span class="line">        gamma = complx_mul(wi2, y[j*stride_m4 + <span class="number">2</span> * stride + k]);</span><br><span class="line">        delta = complx_mul(wi3, y[j*stride_m4 + <span class="number">3</span> * stride + k]);</span><br><span class="line">        tau[<span class="number">0</span>] = complx_add(alpha, gamma);</span><br><span class="line">        tau[<span class="number">1</span>] = complx_sub(alpha, gamma);</span><br><span class="line">        tau[<span class="number">2</span>] = complx_add(beta, delta);</span><br><span class="line">        tau[<span class="number">3</span>] = complx_sub(beta, delta);</span><br><span class="line">        <span class="comment">//tau[3]*wi(0,1)</span></span><br><span class="line">        tmp = tau[<span class="number">3</span>].x;</span><br><span class="line">        tau[<span class="number">3</span>].x = -tau[<span class="number">3</span>].y;</span><br><span class="line">        tau[<span class="number">3</span>].y = tmp;</span><br><span class="line">        x[(j + L_d4 * <span class="number">0</span>)*stride + k] = complx_add(tau[<span class="number">0</span>], tau[<span class="number">2</span>]);</span><br><span class="line">        x[(j + L_d4 * <span class="number">1</span>)*stride + k] = complx_sub(tau[<span class="number">1</span>], tau[<span class="number">3</span>]);</span><br><span class="line">        x[(j + L_d4 * <span class="number">2</span>)*stride + k] = complx_sub(tau[<span class="number">0</span>], tau[<span class="number">2</span>]);</span><br><span class="line">        x[(j + L_d4 * <span class="number">3</span>)*stride + k] = complx_add(tau[<span class="number">1</span>], tau[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模块化为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __device__ <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">StockhamR4_block</span></span></span><br><span class="line"><span class="function"><span class="params">(Complex *a, Complex *b, Complex *c, Complex *d, Complex *wi, <span class="keyword">float</span> wi_c, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Complex tmp, alpha, beta, gamma, delta;</span><br><span class="line">    alpha = *a;                     *wi = exp_calcu(index * wi_c);  tmp = *wi;</span><br><span class="line">    beta  = ComplexMul(*wi, *b);    *wi = ComplexMul(*wi, *wi);</span><br><span class="line">    gamma = ComplexMul(*wi, *c);    *wi = ComplexMul(tmp, *wi);</span><br><span class="line">    delta = ComplexMul(*wi, *d);</span><br><span class="line">    tmp   = alpha;</span><br><span class="line">    alpha = ComplexAdd(alpha, gamma);</span><br><span class="line">    gamma = ComplexSub(tmp,   gamma);</span><br><span class="line">    tmp   = beta;</span><br><span class="line">    beta  = ComplexAdd(beta, delta);</span><br><span class="line">    delta = ComplexSub(tmp,  delta);</span><br><span class="line">    <span class="comment">//tau3*wi(0,1)</span></span><br><span class="line">    tmp.x   = delta.x;</span><br><span class="line">    delta.x = -delta.y;</span><br><span class="line">    delta.y = tmp.x;</span><br><span class="line">    *a = ComplexAdd(alpha,  beta);</span><br><span class="line">    *b = ComplexSub(gamma, delta);</span><br><span class="line">    *c = ComplexSub(alpha,  beta);</span><br><span class="line">    *d = ComplexAdd(gamma, delta);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基-4蝶形单元具有很好的计算特性，涉及的旋转因子复数乘法比基-8和基-16单元少很多，每个线程负责16个数据，也就是4个基-4单元的计算，实际测试结果表明，计算很好地掩盖了访问共享内存的延迟，本文实现的4096点FFT计算时间与cuFFT一致（这里是8192组4096点1维FFT计算时间测试）。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1bbiue2qu1u58fd69dt1thb1ma88d-20210605135115483.png" alt=""></p><p>cuFFT结果 ： 3.614ms<br>本文实现结果 ： 3.600ms</p><p>本文运行环境是WIN7 x64 + CUDA 7.5。</p><hr><h2 id="大点数FFT的计算方法"><a href="#大点数FFT的计算方法" class="headerlink" title="大点数FFT的计算方法"></a>大点数FFT的计算方法</h2><p>根据GPU硬件和FFT多级数据交换的特点，为了保证算法的运行时间，不能把FFT的数据交换放到显存里，尽量通过片上的共享内存进行。由于存储资源限制，理论上一次可以计算4096点（详见前述）。所以在实现大点数FFT时，首先想到的是把序列分解为多个4096点DFT，再用Stockham方法实现DFT的快速计算。</p><p>当序列长度n为复合数时，可以分解为一些因子的乘积，即混合基算法的基本原理。比如，128点的序列，用基-2算法需要7级计算，用基-2/4混合基的话需要3级基-4和1级基-2计算，减少了数据交换次数。在此，本文已经高效地实现了4096点FFT计算，所以可以将大点数序列分解成n=n0*4096的形式计算。</p><p>下面先说明混合基算法原理：</p><p>一维离散傅里叶变换被描述为: $\quad X_{k}=\sum_{j=0}^{n-1} x_{j} \omega_{n}^{j k}, 0 \leq k \leq n-1$<br>其中 $\omega_{n}=e^{-2 \pi i / n}, i=\sqrt{-1}, \mathrm{n}$ 是 $\mathrm{FFT}$ 的序列长度，且 $\mathrm{n}$ 具有因子 $n_{0}$ 和 $n_{1}\left(n=n_{0} \times n_{1}\right)$.</p><p>$\mathrm{j}$ 和 $\mathrm{k}$ 可以表示为:$j=j_{0} \times n_{1}+j_{1}, k=k_{1} \times n_{0}+k_{0}$<br>$x$ 和 $X$ 可用二维数组来描述:<br>$x_{j}=x\left(j_{0}, j_{1}\right), 0 \leq j_{0} \leq n_{0}-1,0 \leq j_{1} \leq n_{1}-1$<br>$X_{k}=X\left(k_{1}, k_{0}\right), 0 \leq k_{1} \leq n_{1}-1,0 \leq k_{0} \leq n_{0}-$<br>将上述式子带入离散傅里叶变换公式: $\quad x\left(k_{1}, k_{0}\right)=\sum_{j=0}^{n-1} \sum_{j_{0}=0}^{n_{0}-1} x\left(j_{0}, j_{1}\right) \omega_{n_{0}}^{j k_{0}} \omega_{n}^{j k_{0}} \omega_{n_{1}}^{j k_{1}}$<br>式(4-1)包含两步多重 FFT 计算。<br>第一步先计算 $n_{1}$ 次 $n_{0}$ 点 $\mathrm{FFT}$, 并将结果乘以一组旋转因子 $\omega_{n}^{j k_{0}}: \quad X_{1}\left(k_{0}, j_{1}\right)=\omega_{n}^{j / 1 / 0} \sum_{j_{0}=0}^{n_{0}-1} x\left(j_{0}, j_{1}\right) \omega_{n_{0}}^{j / 6_{0}}$<br>第二步计算 $n_{0}$ 次 $n_{1}$ 点 FFT: $\quad X_{2}\left(k_{0}, k_{1}\right)=\sum_{j=0}^{n-1} X_{1}\left(k_{0}, j_{1}\right) \omega_{n_{1}}^{j / 1 / 1}$<br>最终得到:</p><p>$$<br>X_{k}=X\left(k_{1}, k_{0}\right)=X_{2}\left(k_{0}, k_{1}\right)<br>$$</p><h3 id="以16384点DIF-FFT为例分析计算结构"><a href="#以16384点DIF-FFT为例分析计算结构" class="headerlink" title="以16384点DIF-FFT为例分析计算结构"></a>以16384点DIF-FFT为例分析计算结构</h3><p>16384=4*4096，n=16384，n0=4，n1=4096；j0=(0,3)，j1=(0,4095)；k0=(0,3)，k1=(0,4095)。<br>先按基-4抽取（每隔4096点抽一个数据）做4096组4点DIF-FFT，按所在序列乘以对应的，即的。<br>再计算4组4096点FFT得到结果。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1bnfad4n95fa7c7cokkirn0m.png" alt=""></p><p>从数值计算的角度分析运算过程：</p><p>4096组4点FFT计算时，要注意，数据抽取是在16384点数据中以4096为跨度进行的（基-4抽取）。<br>由于是DIF-FFT计算结构，这里的基-4计算要按DIF的方式进行。<br>DIF-FFT的数据是顺序进，倒序出，所以在12行乘以旋转因子的时候是乘以倒序的旋转因子。<br>为了得到顺序的4块4096序列，计算结果的需要按照倒序放回（17行）。</p><p>由于在基-4计算中序列按MOD4抽取，所以在进行4组4096点FFT计算后，<br>要把4块数据进行合并才能得到数据的16384点FFT计算结果（25-29行）。</p><p>计算可以分为3个部分：4096组4点FFT计算，4组4096FFT计算和数据的抽取合并。用CUDA C实现的话，考虑到片上存储能力，每部分计算都要做成一个核函数（kernel），耗时是小点数的3倍，和官方库cuFFT两倍左右的耗时有较大的差距。</p><p>3个部分中包含大量计算的是中间的4组4096点FFT处理，最后一部分仅改变了数据位置。问题的关键在于，用DIF分解方式可以2步得到FFT计算结果，但这个结果的是分散在n0个数据块中的。如果要降低算法时间，一个可行的办法是结合第2和第3步，将第2步的数据跨越式地存存储。但用GPU实现时，跨越式地把数据存到显存中，会大大降低带宽利用率。要解决这个问题，就要构造出可以在与显存进行数据交换时可以连续访存的算法结构。经测试，使用单精度复数作为数据类型时，还需要保证数据的首地址对齐（128bytes的倍数）。<br>128bytes/8bytes = 16，即一个warp线程与显存数据交换的最小数量时16个单精度复数，那么底线就是32个线程（一个warp）中前16个线程和后16个线程访问的显存位置可以不一样，但在16个线程中，它们访问的数据必须是连续的，且首地址对齐128bytes。为达到这一要求，在FFT框架下即每次至少要计算16个数据块（因为，在DIF计算完成后，16个线程的数据是从不同数据块的对应位置抽取的），而当前GPU架构每次可以计算4096点数据，所以需要把大点数序列划分为以256为计算单元的多个数据块。比如16384点，就要划分为64组256点FFT，每次抽取16组到片上计算。</p><p>受到这些约束，16384点FFT计算的实际分解方式是：</p><p>16384=64*256，n=16384，n0=64，n1=256；j0=(0,63)，j1=(0,255)；k0=(0,63)，k1=(0,255)。<br>先按基-64抽取（每隔256点抽一个数据）做256组64点DIF-FFT，按所在序列乘以对应的，即的。<br>再计算64组256点FFT得到结果（在GPU上实现，有更细的划分）。</p><p>以上是理论说明。</p><h3 id="65536-4以上大点数的处理方法"><a href="#65536-4以上大点数的处理方法" class="headerlink" title="65536*4以上大点数的处理方法"></a>65536*4以上大点数的处理方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本节作为附加介绍</span><br></pre></td></tr></table></figure><p>为了实现更快速度，在FFT+点乘+IFFT。这样的频域算法计算中。<br>结合Cooley-Tukey和Stockham结构，中间结果不要求完全“顺序”：</p><p>顺序输入 &gt;&gt; Cooley-Tukey &gt;&gt; 倒序输出<br>65536*4/4096=64，即256K点数据可以分为64组4096点FFT计算。<br>先用DIF Cooley-Tukey 拆分4096点数据（见上一节理论和CTFFT计算结构示意图）</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1bbip3o5v1lb91ml77n6pnsc6734.png" alt=""></p><p>可以看出DIF第一级计算以后，8点分治为两个4点计算（即后续的计算两个4点之间没有依赖）</p><p>按照4096点Stockham结构，计算64组数据，即可得到FFT计算结果。<br>注意，此时的数据是按64块倒序存放的（注意描述，按分块倒序，块内数据是“顺序”的）<br>因为，已经得到结果，为了节省时间，不再用一个kernel得到顺序结果。</p><p>点乘。完成频域计算。</p><p>进行64组4096点IFFT</p><p>利用DIT Cooley-Tukey结构处理64块4096点数据<br>（在stage0不用倒序，因为数据已经按块倒序了）</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1bbip3hfrba1d9h11uu13da1hmq2n.png" alt=""></p><p>所以计算步奏如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、DIF Cooley-Tukey 拆分数据（顺序输入，按块倒序输出）</span><br><span class="line">2、计算64组4096点Stockham FFT</span><br><span class="line">3、频域点乘</span><br><span class="line">4、计算64组4096点IFFT</span><br><span class="line">5、DIT Cooley-Tukey 合并数据（按块倒序输入，顺序输出）</span><br></pre></td></tr></table></figure><p>利用Cooley-Tukey FFT的计算结构，拆分大点数计算。<br>利用Stockham FFT 向量化的计算结构，进行大部分计算。<br>计算步骤2、3、4可以合并为一个kernel。</p><p><strong>整体时间为4个访存密集kernel时间</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">而调用cuFFT的话，从这个数据长度开始 FFT，IFFT都需要3个访存密集kernel时间</span><br><span class="line">再加上点乘调用，共需要7个kernel时间。</span><br></pre></td></tr></table></figure><p><strong>所以实际工程中，可以加速2倍左右。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这一方法在本文框架中，可以处理65536*4到65536*256的计算规模：</span><br><span class="line">65536*4=4096*16</span><br><span class="line">65536*256=4096*4096</span><br></pre></td></tr></table></figure><hr><h4 id="时间测试"><a href="#时间测试" class="headerlink" title="时间测试"></a>时间测试</h4><p>16384点<br><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1bnfbvd6hq7t1kq527mluj1dsf13.png" alt=""></p><p>cuFFT结果 ： 3.642 + 3.665 = 7.307ms<br>本文实现结果 ： 4.215 + 3.740 = 7.955ms （稍慢，实际整合频域算法的话，快1/3的时间）</p><p>…</p><p>65536*4点<br><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1bnfcb2h79vm1c4h1ldp1ojuhqu1g.png" alt=""></p><p>cuFFT结果 ： 3.65*6 + 3.65 = 25.55ms （3FFT 3IFFT 1频域计算）<br>本文实现结果 ： 3.85 + 6.54 + 3.85 = 14.24ms （注意，234步骤已整合到第二个kernel）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">补充一点，在这一维数据长度，调用cuFFT，库自己拆分为三个kernel进行计算，非用户操纵。</span><br></pre></td></tr></table></figure><p>补充公式</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image-20210605141333528.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一维FFT算法在Maxwell架构上，归为访存密集算法。&lt;br&gt;即，在足够优化的情况下，可在一次memory copy的耗时内完成计算。&lt;/p&gt;
&lt;p&gt;本文实现的FFT算法达到与官方库cuFFT一致的速度，通过整合kernel，可实现比调用CUFFT更快的算法整体执行速度。在处理65536*4以上大点数一维FFT+IFFT计算时（一个大核心共享内存放不下完整的一维FFT数据），组合算法可以实现比CUFFT少2个kernel调用的时间（减少两次显存数据交换），主要说明4096点FFT算法设计的思路及实现。大点数仅说明方法和测试结果。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://yuanquanquan.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="学习笔记" scheme="http://yuanquanquan.top/categories/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CUDA" scheme="http://yuanquanquan.top/tags/CUDA/"/>
    
  </entry>
  
  <entry>
    <title>一维卷积的SASS实现</title>
    <link href="http://yuanquanquan.top/2021/20210604/"/>
    <id>http://yuanquanquan.top/2021/20210604/</id>
    <published>2021-06-03T20:51:23.000Z</published>
    <updated>2021-06-04T16:19:49.391Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本项目使用MaxAs提供的汇编器编写GPU一维卷积算法</p><p>有16点和1024点卷积核两种实现，SASS代码在目录下，两个VS2013工程在文件夹中</p><p>实验环境：WIN7 + VS2013 + CUDA 6.5 + MaxAs (SASS代码已注入cubin，运行不需要MaxAs)</p><hr><p>16点卷积和1024点卷积恰好可划分在访存密集和计算密集这两个类型中，是比较好的练手项目。</p><p>1024点卷积在Maxwell架构下达到硬件75%的峰值算力，还在找未达到90%以上的原因。</p></blockquote><span id="more"></span><h2 id="1、一维卷积计算过程"><a href="#1、一维卷积计算过程" class="headerlink" title="1、一维卷积计算过程"></a>1、一维卷积计算过程</h2><p>线性卷积: $y(n)=x(n) * h(n)$</p><p>设x(n)长度为N1，h(n)长度为N2 ， 则y(n)长为 N=N1+N2-1<br>为方便表示，在序列x(n)后添N2-1个0 ，使x(n)的长度变为 N</p><p>卷积公式 ： $y(n)=\sum_{i=0}^{N-1} x(i) \times h(n-i), \quad 0 \leq n \leq N-1$</p><p>可用矩阵表示为：</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1avo8jtg41p6e5egvii1vt9uec1t.png" alt=""></p><p>一个简单的计算过程示意：</p><p>x(n)=[4,3,2,1]<br>h(x)=[3,2,1]<br>y(n)=x(n)*h(n)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x  |        4  3  2  1        | </span><br><span class="line">   |                          | </span><br><span class="line">   y0 |  1  2  3                 | = 4*3              = 12</span><br><span class="line">   y1 |     1  2  3              | = 4*2 + 3*3        = 17</span><br><span class="line">   y2 |        1  2  3           | = 4*1 + 3*2 + 2*3  = 16</span><br><span class="line">   y3 |           1  2  3        | = 3*1 + 2*2 + 1*3  = 10</span><br><span class="line">   y4 |              1  2  3     | = 2*1 + 1*2        = 4</span><br><span class="line">   y5 |                 1  2  3  | = 1*1              = 1</span><br></pre></td></tr></table></figure><p>为保证局部性：</p><p>在实现时，卷积核H的数据先放到片上<br>（H点数较小时直接放到寄存器，点数稍大可放在共享内存，过大时分批从片外内存读取）</p><p>实际的原始数据X，点数较大，分块（blocking）处理。</p><p>Y的计算不按照上例中的一次性计算$y^2=4 <em>1+3</em>2+2*3=16$ 。<br>而是 多次乘加 得到结果 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Y初始化为0</span><br><span class="line">regX = shareadX[0];      //共享内存读取x</span><br><span class="line">Y0  += regX*H1;</span><br><span class="line">Y1  += regX*H2;</span><br><span class="line">Y2  += regX*H3;</span><br><span class="line">regX = shareadX[1];      </span><br><span class="line">Y1  += regX*H1;   </span><br><span class="line">Y2  += regX*H2;</span><br><span class="line">Y3  += regX*H3;</span><br><span class="line">...</span><br><span class="line">//计算完成后把Y 在共享内存reshape 然后放回片外</span><br></pre></td></tr></table></figure><p>上例每次读一个X。实现时，X批量读入，计算掩盖访存延迟。</p><h2 id="2、两个实现：16点卷积与1024点卷积"><a href="#2、两个实现：16点卷积与1024点卷积" class="headerlink" title="2、两个实现：16点卷积与1024点卷积"></a>2、两个实现：16点卷积与1024点卷积</h2><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><table><thead><tr><th style="text-align:center">算法</th><th style="text-align:center">卷积</th></tr></thead><tbody><tr><td style="text-align:center">数据量</td><td style="text-align:center">N*2 (输入X / 输出Y / H较小不计入)</td></tr><tr><td style="text-align:center">计算量</td><td style="text-align:center">N*N2*2 (乘加按两个指令计算)</td></tr><tr><td style="text-align:center"><strong>硬件</strong></td><td style="text-align:center">GTX970</td></tr><tr><td style="text-align:center">峰值计算能力</td><td style="text-align:center">1.25GHz <em> 1664cores </em> 2 = 4160 GFLOPS（实测达到）</td></tr><tr><td style="text-align:center">访存带宽：</td><td style="text-align:center">224GB/S （实测连续访存140GB/s ，即35G/s的FP32数据）</td></tr></tbody></table><p>算法计算强度 $=\frac{\text { 计算量 }}{\text { 数据量 }}=\frac{2 <em> N </em> N 2}{2 N}=N 2$</p><p>(即一维卷积计算算法强度与卷积核长度直接相关： 16点卷积计算强度为16， 1024点卷积计算强度为1024)</p><p>硬件计算强度 $=\frac{\text { 浮点计算能力 }}{\text { 浮点带宽 }}=\frac{4160 \mathrm{GFLOPS}}{35 \mathrm{GFloatData}}=118.8$</p><p>所以16点卷积计算 ：受限于带宽 （16 &lt; 116.8 访存密集）<br>1024点卷积计算 ： 受限于核心计算能力（1024 &gt; 116.8 计算密集）</p><p>所有算法都可以从这一角度，划分为上述两个类型之一。<br>计算密集的算法，可以针对硬件架构进行优化。</p><h3 id="16点卷积"><a href="#16点卷积" class="headerlink" title="16点卷积"></a>16点卷积</h3><p>一维卷积核H：16 float （直接拷贝到寄存器）<br>输入数据量X：1024000 float<br>输出数据量Y：1024000 + 16 float （最后16个Y为了方便，没有进行计算）<br>线程结构 : 32个thread一个blcok，每个thread计算16点Y，一共需要2000个block。<br>片上存储 ： 分配544 float * 4 bytes = 2176 bytes 大小的共享内存空间用于存储。</p><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a><strong>存储结构</strong></h4><p><strong>Shared存储</strong><br><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1avomqh2tgdqqvvct61ubn3u583.png" alt=""></p><p>每个block负责32*16=512点Y计算<br>32个threads 对显存合并访问 读取X<br>每个thread进行4次LDG.128访问 + 一次LDG访问（32bit，末尾的32个X，只用到1/2的数据）<br><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1be05en8318a1vtp1fqd1jetng5m.png" alt=""></p><p><strong>Shared访存</strong><br>整体来看，一个线程需要访问8次共享内存（128bit形式）<br>eg：<br>第一次，所有线程访问第一行，第二次第二行，第三次第三行，第四次第四行<br>第五次时，需要向左移一列访问，接下来再访问三行</p><p>（注：图看不清的话，可以点击放大）<br><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1avolnfikeh316dp1crrcciqgt7m.png" alt=""></p><p>以thread 0为例 ，蓝色框是其访存范围，红色线条是访存顺序。<br>黑框是 thread 1 的访存范围，前后两个线程共享16个 float 数据<br><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1avon1gnd1c38v0j1clh15kt78d8g.png" alt=""></p><p>这样的LD/ST方法，利用了完整的共享内存带宽。</p><hr><h4 id="算法结构"><a href="#算法结构" class="headerlink" title="算法结构"></a><strong>算法结构</strong></h4><p>计算示意（结合 1、一维卷积计算过程 理解）</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1avonaiq71mp1i8p11od4qnfka8t.png" alt=""></p><p>完全避免寄存器冲突的办法</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1avonpv7ieokp3dis41r66f289a.png" alt=""></p><h3 id="1024点卷积"><a href="#1024点卷积" class="headerlink" title="1024点卷积"></a>1024点卷积</h3><p>计算的核心循环与16点卷积一致，32点X与16点H参与计算。<br>区别在于下一次循环还要使用32个当前计算X中的的后16个；下一次计算使用的H是新的16个。</p><p>理论分析：由于一个小循环算完16点Y，数据都在片上，所以再套上大循环，对X、Y做双缓冲不会有速度提升<br>实际处理：H加双缓冲无效，寄存器双缓冲预取共享内存中的X，计算掩盖延迟。</p><p>一维卷积核H：1024 float<br>输入数据量X：2097152 float<br>输出数据量Y：2097152+1024 float （最后1024个Y为了方便，没有进行计算）<br>线程结构：128个thread一个blcok，每个thread计算16点Y，一共需要1024个block。</p><h4 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a><strong>存储结构</strong></h4><p>X数据存储与16点类似，一个block存128线程<em>(4float</em>6次加载)=3072个单精度浮点。<br>还需要1024<em>4byes存放H。<br>共分配4096</em>4bytes的共享内存空间<br><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1avoqm9741tr17n6b7jd4f1eufbb.png" alt=""></p><h4 id="计算结构"><a href="#计算结构" class="headerlink" title="计算结构"></a><strong>计算结构</strong></h4><p>block内计算示意<br><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1avop9ch21fqrovk1nrsk9k1821a4.png" alt=""></p><p>block间计算示意<br><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1avopgujc51q1fhf1nhf1j7iu8sau.png" alt=""></p><blockquote><p>注:Y存回片外时通过共享内存reshape，有bank conflict，只用到了共享内存1/4的完整带宽。<br>但实测对kernel执行时间基本没有影响（占比太小）。</p></blockquote><p>SASS代码：<br><a href="https://github.com/Velaciela/1D-convolution-with-SASS/blob/master/conv1024_nobuffer.sass">conv1024_nobuffer.sass</a></p><hr><h2 id="3、实验结果"><a href="#3、实验结果" class="headerlink" title="3、实验结果"></a>3、实验结果</h2><h3 id="16点卷积-1"><a href="#16点卷积-1" class="headerlink" title="16点卷积"></a>16点卷积</h3><p>每个线程使用60个寄存器（优化后），恰好达到1个SM上32个Block的占用上限。</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1avoeeebb182op4fusfj8s1r053u.png" alt=""></p><p>实测，只要一个SM上达到6个Block的占用，就可占满带宽。<br>6占用kernel执行时间和32个占用的时间一致。<br>占用多了，带宽跟不上，还是需要等待。</p><p>数据量(32*16*2000)*2 = 2*1024000FP32 = 2*1024000*4bytes/1024/1024 = 7.8125MB</p><p>下图可知，kernel平均计算时间为56us<br><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1avof1ebn1grl7jo7am9qmso54o.png" alt=""></p><p>带宽占用： 7.8125MB / 0.056ms = 139.51GB/s<br>与理论分析一致</p><hr><h3 id="1024点卷积-1"><a href="#1024点卷积-1" class="headerlink" title="1024点卷积"></a>1024点卷积</h3><p>Visual Profiler （nvvp）分析：</p><p>带宽未占满<br><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1avofvn3l1ngb1l8a10r2ulobpl5v.png" alt=""></p><p>计算指令占比接近90%<br><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1avofsmlrdqc1bq7415114d11o65i-20210604233547601.png" alt=""></p><p>SM占用6<br><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1avog5jnc1g2tapc1iej1f7negm6p-20210604233513105.png" alt=""><br>实测占用 6、4、2个block的情况，kernel执行时间一致。<br>由于计算能力限制，占用多了也算不过来。</p><p>kernel执行时间1.4ms<br><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1avog45dp1nhm14qc15ho14m9e86c.png" alt=""></p><table><thead><tr><th style="text-align:center">结果</th><th style="text-align:center">达到硬件峰值计算能力的74% （未达到90%）</th></tr></thead><tbody><tr><td style="text-align:center">数据量</td><td style="text-align:center">输入X+输出Y = 2<em>2097152 float = 2</em>2097152*4bytes/1024/1024 = 16MB</td></tr><tr><td style="text-align:center">kernel时间</td><td style="text-align:center">1.4ms</td></tr><tr><td style="text-align:center">带宽占用</td><td style="text-align:center">16MB / 1.4ms = 11.42GB/s</td></tr><tr><td style="text-align:center">kernel算力</td><td style="text-align:center">2097152_X输入<em>1024_H卷核</em>2_乘加 / 1.4ms = 4.295 GigaFloatOp / 0.0014s = 3067.86 GFLOPS</td></tr><tr><td style="text-align:center">硬件算力</td><td style="text-align:center">1.25GHz <em> 1664cores </em> 2 = 4160 GFLOPS</td></tr></tbody></table><hr><p><strong>数据生成及结果验证</strong></p><p>原始数据X、卷积核H和结果Y的长度分别为N、M、P。<br>卷积核与原始数据用伪随机数填充。<br>CPU计算的卷积结果放在数据块T中。<br>GPU计算的卷积结果拷贝到数据块Y中。</p><p>打印前1024个T与Y的误差<br>Y与T差的绝对值大于1则打印出来（计算精度所在位置随数据大小变化）</p><p><img src="https://cdn.jsdelivr.net/gh/Bazingaliu/clouding@master/image_1avoclkfcqsai1f1uu71sua123u3h.png" alt=""></p><h2 id="4、小结"><a href="#4、小结" class="headerlink" title="4、小结"></a>4、小结</h2><p>常用的优化方法：<br>调整算法结构（匹配硬件特性），kernel间整合（减少访存），kernel优化（数值计算过程与汇编）</p><p>16点卷积和1024点卷积恰好可划分在访存密集和计算密集这两个类型中。<br>是比较好的练手项目。</p><p>访存密集型的算法不需要用汇编优化，保证基本的合并访存即可。<br>但一些算法结构复杂，需要仔细分析，利用好片上和片外内存的带宽。</p><p>1024点卷积kernel应该达到90%+的峰值算力，未找到受限原因。<br>理论上1024点卷积不需要嵌套循环，不用对X做双缓冲预取，因为当前计算的Y与下一大组X没有数据依赖关系。</p><p>按现在的理解，在SM上block占用低于一个阈值的情况下，双缓冲可以带来一定的计算能力提升。<br>在占用足够的情况下，线程级并行、线程间的切换，其实和双缓冲是等效的。<br>（2017补充）</p><p>实际工程中常用FFT在频域进行快速卷积。</p><h2 id="5、后续"><a href="#5、后续" class="headerlink" title="5、后续"></a>5、后续</h2><p>二维卷积<br>FFT</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本项目使用MaxAs提供的汇编器编写GPU一维卷积算法&lt;/p&gt;
&lt;p&gt;有16点和1024点卷积核两种实现，SASS代码在目录下，两个VS2013工程在文件夹中&lt;/p&gt;
&lt;p&gt;实验环境：WIN7 + VS2013 + CUDA 6.5 + MaxAs (SASS代码已注入cubin，运行不需要MaxAs)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;16点卷积和1024点卷积恰好可划分在访存密集和计算密集这两个类型中，是比较好的练手项目。&lt;/p&gt;
&lt;p&gt;1024点卷积在Maxwell架构下达到硬件75%的峰值算力，还在找未达到90%以上的原因。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://yuanquanquan.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="学习笔记" scheme="http://yuanquanquan.top/categories/%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CUDA" scheme="http://yuanquanquan.top/tags/CUDA/"/>
    
  </entry>
  
</feed>
