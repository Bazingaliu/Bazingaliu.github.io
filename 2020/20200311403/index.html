<!DOCTYPE html>
<html lang="zh-CN">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="【Object Detection】-Faster R-CNN" />
    <meta name="hexo-theme-A4" content="v1.9.8" />
    <link rel="alternate icon" type="image/webp" href="/img/20250602032635.jpg">
    <title>Yann | 我愿做你光华中淡淡的一笔</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery-bundle.min.css">


   
        
<link rel="stylesheet" href="/css/custom.css">

    

<meta name="generator" content="Hexo 5.4.2"></head>
    
    

    
    



    

    
    




    
    <style>
        :root {
            --waline-theme-color: #323e74; 
            --waline-color: #323e74; 
            --waline-border-color: #323e74; 
            --waline-white: #323e74; 
            --waline-bgcolor-light: #f2fafc;  
        }
        body {
            color: #323e74;
            background: #eaeae8;
        }
        .post-md code {
            background: #e7f7f3;
            color: #7f688d; 
        }
        .post-md pre, .post-md .highlight {
            background: #e7f7f3;
            color: #7f688d; 
        }
        pre .string, pre .value, pre .inheritance, pre .header, pre .ruby .symbol, pre .xml .cdata {
            color: #323e74;
        }
        pre .number, pre .preprocessor, pre .built_in, pre .literal, pre .params, pre .constant {
            color: #323e74;
        }
        .year-font-color {
            color: #323e74 !important;
        }
        .wl-card span.wl-nick {
            color: #323e74; 
        }
        .wl-card .wl-badge {
            border: 1px solid #323e74;
            color: #323e74; 
        }
        .wl-btn {
            border: 1px solid #323e74; 
            color:  #323e74;  
        }
        .wl-btn.primary {
            color: #f2fafc; 
        }
        .wl-header label {
            color: #323e74;
        }
        a {
            color: #7f688d;
        }

        .post-md a {
            color: #7f688d;
        }

        .nav li a {
            color: #7f688d;
        }

        .archive-main a:link {
            color: #7f688d;
        }
        .archive-main a:visited {
            color: #767c7c; 
        }

        .archive li span {
            color: #323e74;
        }

        .post-main-title {
            color: #323e74;
        }

        .post-md h1,
        .post-md h2,
        .post-md h3,
        .post-md h4,
        .post-md h5,
        .post-md h6 {
            color: #323e74;
        }

        [data-waline] p {
            color: #323e74;
        }
        [data-waline] a {
            color: #323e74;
        } 
        .wl-sort li.active {
            color: #323e74;
        }

        .wl-card .wl-meta>span {
            background: #f2fafc;
        }

        .paper {
            background: #eaeae8;
        }

        .index-main {
            background: #f2fafc;
        }

        .paper-main {
            background: #f2fafc;
        }

        .wl-panel {
            background: #f2fafc;
        }

        .archive li:nth-child(odd) {
            background: #f2fafc;
            ;
        }

        .archive li:nth-child(even) {
            background: #f2fafc;
        }

        .post-md table tr:nth-child(odd) td {
            background: #f2fafc;
        }

        .post-md table tr:nth-child(even) td {
            background: #f2fafc;
        }

    
        .progress-wrap::after {
            color: #323e74; /* 箭头的颜色 */
        }
        .progress-wrap svg.progress-circle path {
	        stroke: #323e74; /* 边框的颜色 */
        }
        .progress-wrap::before {
	        background-image: linear-gradient(298deg, #7f688d, #7f688d); /* 鼠标滑过的箭头颜色 */
         }

        .return-to-last-progress-wrap::after {
            color: #323e74; /* 箭头的颜色 */
        }
        .return-to-last-progress-wrap svg.progress-circle path {
	        stroke: #323e74; /* 边框的颜色 */
        }
        .return-to-last-progress-wrap::before {
	        background-image: linear-gradient(298deg, #7f688d, #7f688d); /* 鼠标滑过的箭头颜色 */
         }

         .left-toc-container::-webkit-scrollbar-thumb {
            background-color: #323e74; /* 设置滚动条拖动块的颜色 */
        }

        .bs-docs-sidebar .nav>.active>a,
        .bs-docs-sidebar .nav>li>a:hover,
        .bs-docs-sidebar .nav>li>a:focus {
            color: #7f688d;
            border-left-color: #7f688d;
        }
        .bs-docs-sidebar .nav>li>a {
            color:  #323e74;
        }
    </style>

    
    <style>
        body {
            background-image: url(/img/3.jpg);
            background-attachment: fixed;  /* 背景固定，不随页面滚动 */
            background-repeat: no-repeat;  /* 防止背景图片重复 */
            background-size: cover;       /* 背景自适应大小，覆盖整个背景 */
            background-position: center;   /* 背景居中显示 */
        }
        .paper {
            background-image: url(/img/3.jpg);
            background-attachment: fixed;  /* 背景固定，不随页面滚动 */
            background-repeat: no-repeat;  /* 防止背景图片重复 */
            background-size: cover;       /* 背景自适应大小，覆盖整个背景 */
            background-position: center;   /* 背景居中显示 */
        }  
    </style>


    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        <script>
            const options = {
                bottom: '40px', // default: '32px'
                right: 'unset', // default: '32px'
                left: '42px', // default: 'unset'
                time: '0.3s', // default: '0.3s'
                mixColor: '#fff', // default: '#fff'
                backgroundColor: ' #eaeae8  ',  // default: '#fff'
                buttonColorDark: '#100f2c',  // default: '#100f2c'
                buttonColorLight: '#fff', // default: '#fff'
                saveInCookies: true, // default: true,
                label: '🌓', // default: ''
                autoMatchOsTheme: true // default: true
            }
            const darkmode = new Darkmode(options);
            darkmode.showWidget();
        </script>
        
        
            
                <div class="left-toc-container">
                    <nav id="toc" class="bs-docs-sidebar"></nav>
                </div>
            
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <style>
            .header-img {
                width: 56px;
                height: auto;
                object-fit: cover; /* 保持图片比例 */
                transition: transform 0.3s ease-in-out; 
                border-radius: 0; 
            }
            
        </style>
        <img 
            alt="^-^" 
            cache-control="max-age=86400" 
            class="header-img" 
            src="/img/20250602032635.jpg" 
        />
        <div class="header-content">
            <a class="logo" href="/">Yann</a> 
            <span class="description">人工智能、计算机、机器学习、linux、程序员</span> 
        </div>
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/about/">关于</a></li>
            
        
            
                <li><a href="/tags/">标签</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">
    

    
        
            
                <div class="post-main-title" style="text-align: center;">
                    【Object Detection】-Faster R-CNN
                </div>
            
        
      
    

    

        
            <div class="post-head-meta-center">
        
                
                    <span>最近更新：2020-06-14</span> 
                
                
                    
                        &nbsp; | &nbsp;
                    
                     <span>字数总计：2.1k</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span>阅读估时：8分钟</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span id="busuanzi_container_page_pv">
                        阅读量：<span id="busuanzi_value_page_pv"></span>次
                    </span>
                
            </div>
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Conv-layer"><span class="post-toc-text">Conv layer</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#anchor"><span class="post-toc-text">anchor</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#RPN"><span class="post-toc-text">RPN</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#softmax-%E5%88%86%E7%B1%BB"><span class="post-toc-text">softmax 分类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#bounding-box-predict"><span class="post-toc-text">bounding box predict</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#bounding-box-regression"><span class="post-toc-text">bounding box regression</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ROI-proposal"><span class="post-toc-text">ROI proposal</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ROI-pooling"><span class="post-toc-text">ROI pooling</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Classification-%EF%BC%8Cbounding-box-predict"><span class="post-toc-text">Classification ，bounding box predict</span></a></li></ol>
            
        
        <div class=".article-gallery"><blockquote>
<p><strong><em>写在前面</em></strong>：之前两个月没有看过cv方向的东西…..所以打算开个系列来写目标检测，图像分割的爆款算法，算是回顾一遍吧，当然一些太经典鼻祖级的模型就懒得看了……于是这个系列就决定叫复健计划了….目标检测的第一篇就从Faster R-CNN开始吧，Faster R-CNN 是目标检测中的一个很经典的two stage算法，许多其他的目标检测算法都会运用到Faster R-CNN的部分结构或思想。而且了解Faster R-CNN对理解其他R-CNN系列网络都有一定的帮助，包括Mask R-CNN，Stereo R-CNN 等等。</p>
</blockquote>
<span id="more"></span>  
<p><a target="_blank" rel="noopener" href="https://i.loli.net/2020/05/03/WpzKakMxdHJZ4w2.png" class="gallery-item" style="box-shadow: none;"> <img src="https://i.loli.net/2020/05/03/WpzKakMxdHJZ4w2.png" alt=""></a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Faster R-CNN由R-CNN，Fast R-NN改进演变而来，相对于前两者，Faster R-CNN具有训练速度快，消耗内存减少，精度与检测速度都有大幅提升的优点。</p>
<p>先来一张Faster R-CNN的网络基本结构图<a target="_blank" rel="noopener" href="https://i.loli.net/2020/05/03/AVMlhnPjQmbqNiZ.png" class="gallery-item" style="box-shadow: none;"> <img src="https://i.loli.net/2020/05/03/AVMlhnPjQmbqNiZ.png" alt=""></a></p>
<p>个人认为网络主要分为五个部分：</p>
<ul>
<li>提取feature map（特征图）的<strong>Conv layer</strong>。该部分使用VGG-net作为预处理网络，运用多个conv，relu，pooling层提取图像特征图，为后面的网络提供图像信息。</li>
<li><strong>anchor</strong>的生成，Faster R-CNN对图像生成一系列的anchor，作为目标检测的先验框，用于多尺度预测，并在后面使用bounding box regression对其位置进行修正。</li>
<li><strong>RPN</strong>（Region Proposal Network），在feature map上的每个点生成anchor，然后将其映射回原图，对原图中的anchor进行修正、筛选，提取该区域的图像(region proposal)，也就是所谓的ROI，送进ROI pooing层。</li>
<li><strong>ROI pooing</strong>，对featuer map中的ROI划分为Pool_h*Poo_w(ROI pooling后特征图的高和宽)）个网格，对每一个网格进行maxpooling。</li>
<li>使用<strong>full connection</strong>，<strong>softmax</strong>对ROI进行分类与bounding box回归，确定bounding box的位置。</li>
</ul>
<p>下面从这五个部分进行说明。先上一个网上总结的Faster R-CNN的结构图。<a target="_blank" rel="noopener" href="https://i.loli.net/2020/05/03/tTaqJoe8GMj3n6O.png" class="gallery-item" style="box-shadow: none;"> <img src="https://i.loli.net/2020/05/03/tTaqJoe8GMj3n6O.png" alt=""></a></p>
<h2 id="Conv-layer"><a href="#Conv-layer" class="headerlink" title="Conv layer"></a>Conv layer</h2><p>Conv layers包含3种层，分别是conv层，pooling层，relu层。<strong>conv</strong>层的卷积核大小都是3 * 3 , 步长都为1，并且都做了扩边处理，也就是经过conv层后图像的大小没有改变，只是深度改变。<strong>pooling</strong> 层的kernel_size=2,步长也为2，也就是说每经过一次pooling层后，图像尺寸减小一半。</p>
<p>Faster RCNN在将图片传入网络之前，会将图片缩放为<strong>M * N</strong>(VGG 为 800 * 600），从原图到feature map一共经过4次pooling，也就是feature map的大小为（int(M/16)，int(N/16)）。</p>
<h2 id="anchor"><a href="#anchor" class="headerlink" title="anchor"></a>anchor</h2><p>anchor其实是在图像上的一个个先验框，用来对后面检测框的修正以及region proposal。这里说一下anchor的生成过程。</p>
<p>先来看看作者的图<a target="_blank" rel="noopener" href="https://i.loli.net/2020/05/03/b5MvdDNU43rHf8e.png" class="gallery-item" style="box-shadow: none;"> <img src="https://i.loli.net/2020/05/03/b5MvdDNU43rHf8e.png" alt=""></a></p>
<p>可以看到，anchor的长宽比有[0.5, 1, 2]三种比例，每种anchor有[8, 16, 32]三个尺度比例，所以anchors一共有3 * 3 = 9个anchor。</p>
<p>生成anchor的主要分为一下步骤：</p>
<ul>
<li>首先设置一个16 <em> 16的窗口（因为feature map尺寸为原图的1/16，所以一个feature map上的点对应原图上16 </em> 16 的区域），计算的到[x_ctr, y_ctr, w, h]，也就是anchor的中心点坐标以及长宽4个量。</li>
<li>然后计算anchor的面积size = w <em> h，将size分别除[0.5, 1, 2]3种比例，再分别对3个新的sizes开根号作为新的anchor的3个w，再将w </em> [0.5, 1, 2]得到h，这样就得到3个anchor的长宽。</li>
<li>将3个anchor长宽分别再乘3个尺度比例，这样就得到9个anchor，再将anchor的表示转换为左上角和右下角的坐标[x_l, y_l, x_r, y_r]。</li>
</ul>
<p>此时每个feature map上的点都有9个anchor，也就是一共有（800/16）<em>（600/16） </em> 9=17100个anchor。再将这些anchor通过原图与feature map的映射关系，将其anchor映射回原图。<a target="_blank" rel="noopener" href="https://i.loli.net/2020/05/03/DzSuMRHPLgarVsZ.png" class="gallery-item" style="box-shadow: none;"> <img src="https://i.loli.net/2020/05/03/DzSuMRHPLgarVsZ.png" alt=""></a></p>
<h2 id="RPN"><a href="#RPN" class="headerlink" title="RPN"></a>RPN</h2><p>RPN的主要结构如图<a target="_blank" rel="noopener" href="https://i.loli.net/2020/05/03/8A6ejLOcau3KhfX.png" class="gallery-item" style="box-shadow: none;"> <img src="https://i.loli.net/2020/05/03/8A6ejLOcau3KhfX.png" alt=""></a></p>
<p>首先将feature map在经过一次conv卷积（这里设得到的网络层为conv5_3)，然后分开两条线进行：</p>
<ul>
<li>先将conv5_3使用1 <em> 1 </em> 18的卷积核对anchor进行softmax分类，将anchor分为postivte和negative（rpn_cls_prob)，二分类。（18 = 2（positiv and negative）* 9（9个anchor）。</li>
<li>用于预测bounding box的坐标偏移值。</li>
<li>在Proposal层综合im_info（主要用来计算proposal的坐标以及限制proposal的大小以免超出图像边框）、rpn_box_pred 和rpn_cls_prob选择和提取ROI。</li>
</ul>
<h3 id="softmax-分类"><a href="#softmax-分类" class="headerlink" title="softmax 分类"></a>softmax 分类</h3><p>conv5_3经过1 <em> 1 </em> 18 卷积后，维度变为[W, H, 18]。softmax就是要将每个点的9个anchor进行二分类（positive和negative）。softmax前后各有一次reshape，其实只是为了让分类更方便而已，这是训练的一些trick。</p>
<h3 id="bounding-box-predict"><a href="#bounding-box-predict" class="headerlink" title="bounding box predict"></a>bounding box predict</h3><p>conv5_3经过1 <em> 1 </em> 36 卷积变为[W, H, 36]，第三个维度为每个anchor的2个坐标的偏移量，用于后面的bounding box regression。</p>
<h3 id="bounding-box-regression"><a href="#bounding-box-regression" class="headerlink" title="bounding box regression"></a>bounding box regression</h3><p>在训练时需要对anchor进行转换才能贴合GT_bbox。怎样转换呢，最简单的做法就是平移加缩放。</p>
<p>下面是转换的关系式：<br>$$<br>\begin{aligned}<br>&amp;t_{x}=\left(x-x_{\mathrm{a}}\right) / w_{\mathrm{a}}, \quad t_{\mathrm{y}}=\left(y-y_{\mathrm{a}}\right) / h_{\mathrm{a}}\<br>&amp;t_{\mathrm{w}}=\log \left(w / w_{\mathrm{a}}\right), \quad t_{\mathrm{h}}=\log \left(h / h_{\mathrm{a}}\right)\<br>&amp;\begin{aligned}<br>t_{\mathrm{x}}^{<em>} &amp;=\left(x^{</em>}-x_{\mathrm{a}}\right) / w_{\mathrm{a}}, \quad t_{\mathrm{y}}^{<em>}=\left(y^{</em>}-y_{\mathrm{a}}\right) / h_{\mathrm{a}} \<br>t_{\mathrm{w}}^{<em>} &amp;=\log \left(w^{</em>} / w_{\mathrm{a}}\right), \quad t_{\mathrm{h}}^{<em>}=\log \left(h^{</em>} / h_{\mathrm{a}}\right)<br>\end{aligned}<br>\end{aligned}<br>$$<br>损失函数为：<br>$$<br>\begin{aligned}<br>L\left(\left{p_{i}\right},\left{t_{i}\right}\right) &amp;=\frac{1}{N_{c l s}} \sum_{i} L_{c l s}\left(p_{i}, p_{i}^{<em>}\right) \<br>&amp;+\lambda \frac{1}{N_{r e g}} \sum_{i} p_{i}^{</em>} L_{r e g}\left(t_{i}, t_{i}^{*}\right)<br>\end{aligned}<br>$$</p>
<h2 id="ROI-proposal"><a href="#ROI-proposal" class="headerlink" title="ROI proposal"></a>ROI proposal</h2><p>ROI prosposal负责综合所有的关于anchor的变换和对softmax的分类positive anchor，在feature map上计算出精确的ROI，将其送入后面的ROI Pooling层。</p>
<p>主要步骤为：</p>
<ul>
<li>对softmax后的anchor按score进行排序，提取前N个score的anchor。</li>
<li>对这些anchor进行修正。</li>
<li>修正大于图像边缘的anchor。</li>
<li>对w或h小于设定阈值的anchor剔除。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://q719r0aui.bkt.clouddn.com/fast%20r-cnn%288%29.webp" class="gallery-item" style="box-shadow: none;"> <img src="http://q719r0aui.bkt.clouddn.com/fast%20r-cnn%288%29.webp" alt=""></a></p>
<p>​         <em>最后传入的ROI类似这样</em></p>
<p>至此，RPN的任务到此完成。</p>
<h2 id="ROI-pooling"><a href="#ROI-pooling" class="headerlink" title="ROI pooling"></a>ROI pooling</h2><p>Faster RCNN最后的Classification和bounding box 的预测需要用到全连接层，所以在将图片传入全连接层时需要将其变为固定大小。但是一般输入的ROI大小都不固定，如果利用采样的方法进行变换为所需要的大小，会对图像的结构产生影响。</p>
<p><a target="_blank" rel="noopener" href="https://i.loli.net/2020/05/03/kDHwuP7YQKpcoTl.jpg" class="gallery-item" style="box-shadow: none;"> <img src="https://i.loli.net/2020/05/03/kDHwuP7YQKpcoTl.jpg" alt=""></a></p>
<p>为了解决这个问题，Faster RCNN提出了ROI pooling的方法。</p>
<p>具体方法为：</p>
<ul>
<li><p>将ROI划分为pool_h和pool_w个网格。</p>
</li>
<li><p>每个网格的起始和结束坐标计算方法为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int hstart = static_cast&lt;int&gt;(floor(ph * bin_size_h));        int wstart = static_cast&lt;int&gt;(floor(pw * bin_size_w));        int hend = static_cast&lt;int&gt;(ceil((ph + 1) * bin_size_h));        int wend = static_cast&lt;int&gt;(ceil((pw + 1) * bin_size_w));         //其中pw，ph是每个网格的坐标值</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算完之后的每个网格可能会有重叠</p>
</li>
<li><p>将每个网格进行max pooling操作，这样就得到固定大小的图了。</p>
<p><strong>假设输出为2 * 2 大小</strong></p>
</li>
</ul>
<p><a href="C:%5CUsers%5CLenovo%5CDesktop%5Cyolov1%5Cfast%20r-cnn(11" class="gallery-item" style="box-shadow: none;"> <img src="C:%5CUsers%5CLenovo%5CDesktop%5Cyolov1%5Cfast%20r-cnn(11" alt=""></a>.jpg)</p>
<p><a target="_blank" rel="noopener" href="https://i.loli.net/2020/05/03/droM81DilEjPFgN.png" class="gallery-item" style="box-shadow: none;"> <img src="https://i.loli.net/2020/05/03/droM81DilEjPFgN.png" alt=""></a></p>
<h2 id="Classification-，bounding-box-predict"><a href="#Classification-，bounding-box-predict" class="headerlink" title="Classification ，bounding box predict"></a>Classification ，bounding box predict</h2><p>这个没什么好说的了，就是使用全连接层和softmax层进行分类和预测bounding box坐标值。</p>
<p><a target="_blank" rel="noopener" href="https://i.loli.net/2020/05/03/lnpwKxfgDUSdHhO.png" class="gallery-item" style="box-shadow: none;"> <img src="https://i.loli.net/2020/05/03/lnpwKxfgDUSdHhO.png" alt=""></a></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>创新</th>
<th>缺点</th>
<th>改进</th>
</tr>
</thead>
<tbody>
<tr>
<td>R-CNN (Region-based Convolutional Neural Networks)</td>
<td>1、SS提取RP； 2、CNN提取特征； 3、SVM分类； 4、BB盒回归。</td>
<td>1、 训练步骤繁琐（微调网络+训练SVM+训练bbox）； 2、 训练、测试均速度慢 ； 3、 训练占空间</td>
<td>1、 从DPM HSC的34.3%直接提升到了66%（mAP）； 2、 引入RP+CNN</td>
</tr>
<tr>
<td>Fast R-CNN (Fast Region-based Convolutional Neural Networks)</td>
<td>1、SS提取RP； 2、CNN提取特征； 3、softmax分类； 4、多任务损失函数边框回归。</td>
<td>1、 依旧用SS提取RP(耗时2-3s，特征提取耗时0.32s)； 2、 无法满足实时应用，没有真正实现端到端训练测试； 3、 利用了GPU，但是区域建议方法是在CPU上实现的。</td>
<td>1、 由66.9%提升到70%； 2、 每张图像耗时约为3s。</td>
</tr>
<tr>
<td>Faster R-CNN (Fast Region-based Convolutional Neural Networks)</td>
<td>1、RPN提取RP； 2、CNN提取特征； 3、softmax分类； 4、多任务损失函数边框回归</td>
<td>1、 还是无法达到实时检测目标； 2、 获取region proposal，再对每个proposal分类计算量还是比较大。</td>
<td>1、 提高了检测精度和速度； 2、 真正实现端到端的目标检测框架； 3、 生成建议框仅需约10ms。</td>
</tr>
</tbody>
</table>
</div>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2020-03-11</span>
            
                <span>该篇文章被 Yann</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/Object-Detection/'>
                            Object Detection
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E7%AC%94%E8%AE%B0/'>
                            笔记
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    
        
            
    
            <div class="post-footer-pre-next">
                
                    <span>上一篇：<a href='/2020/20200312/'>【Object Detection】-YOLOV1</a></span>
                

                
                    <span class="post-footer-pre-next-last-span-right">下一篇：<a href="/2020/20200310/">开新坑-硬件学习</a>
                    </span>
                
            </div>
    
        
    

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2025 China 

            
                

            
        </span>
       
    
</div>



<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>🌊看过大海的人不会忘记海的广阔🌊</span>
            
                <span class="footer-last-span-right"><i>本站由<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo</a>驱动｜使用<a target="_blank" rel="noopener" href="https://github.com/HiNinoJay/hexo-theme-A4">Hexo-theme-A4</a>主题</i></span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery/lightgallery.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-thumbnail.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-fullscreen.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-autoplay.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-zoom.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-rotate.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-paper.umd.min.js"></script>




<script type="text/javascript">
     
    if (typeof lightGallery !== "undefined") {
        var options1 = {
            selector: '.gallery-item',
            plugins: [lgThumbnail, lgFullscreen, lgAutoplay, lgZoom, lgRotate, lgPager], // 启用插件
            thumbnail: true,          // 显示缩略图
            zoom: true,               // 启用缩放功
            rotate: true,             // 启用旋转功能能
            autoplay: true,        // 启用自动播放功能
            fullScreen: true,      // 启用全屏功能
            pager: false, //页码,
            zoomFromOrigin: true,   // 从原始位置缩放
            actualSize: true,       // 启用查看实际大小的功能
            enableZoomAfter: 300,    // 延迟缩放，确保图片加载完成后可缩放
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1); // 修复选择器
    }
    
</script>


    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> 

                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>
<script src="/js/emojiHandler.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    wrapEmojis('.paper');
  });
</script>