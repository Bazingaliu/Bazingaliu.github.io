<!DOCTYPE html>
<html lang="zh-CN">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="浙大PAT考试数据结构与算法模板整理" />
    <meta name="hexo-theme-A4" content="v1.9.8" />
    <link rel="alternate icon" type="image/webp" href="/img/20250602032635.jpg">
    <title>Yann | 我愿做你光华中淡淡的一笔</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery-bundle.min.css">


   
        
<link rel="stylesheet" href="/css/custom.css">

    

<meta name="generator" content="Hexo 5.4.2"></head>
    
    

    
    



    
        <style>
            .paper-main{
                max-width:  1200px;
            }
        </style>

    
    




    
    <style>
        :root {
            --waline-theme-color: #323e74; 
            --waline-color: #323e74; 
            --waline-border-color: #323e74; 
            --waline-white: #323e74; 
            --waline-bgcolor-light: #f2fafc;  
        }
        body {
            color: #323e74;
            background: #eaeae8;
        }
        .post-md code {
            background: #e7f7f3;
            color: #7f688d; 
        }
        .post-md pre, .post-md .highlight {
            background: #e7f7f3;
            color: #7f688d; 
        }
        pre .string, pre .value, pre .inheritance, pre .header, pre .ruby .symbol, pre .xml .cdata {
            color: #323e74;
        }
        pre .number, pre .preprocessor, pre .built_in, pre .literal, pre .params, pre .constant {
            color: #323e74;
        }
        .year-font-color {
            color: #323e74 !important;
        }
        .wl-card span.wl-nick {
            color: #323e74; 
        }
        .wl-card .wl-badge {
            border: 1px solid #323e74;
            color: #323e74; 
        }
        .wl-btn {
            border: 1px solid #323e74; 
            color:  #323e74;  
        }
        .wl-btn.primary {
            color: #f2fafc; 
        }
        .wl-header label {
            color: #323e74;
        }
        a {
            color: #7f688d;
        }

        .post-md a {
            color: #7f688d;
        }

        .nav li a {
            color: #7f688d;
        }

        .archive-main a:link {
            color: #7f688d;
        }
        .archive-main a:visited {
            color: #767c7c; 
        }

        .archive li span {
            color: #323e74;
        }

        .post-main-title {
            color: #323e74;
        }

        .post-md h1,
        .post-md h2,
        .post-md h3,
        .post-md h4,
        .post-md h5,
        .post-md h6 {
            color: #323e74;
        }

        [data-waline] p {
            color: #323e74;
        }
        [data-waline] a {
            color: #323e74;
        } 
        .wl-sort li.active {
            color: #323e74;
        }

        .wl-card .wl-meta>span {
            background: #f2fafc;
        }

        .paper {
            background: #eaeae8;
        }

        .index-main {
            background: #f2fafc;
        }

        .paper-main {
            background: #f2fafc;
        }

        .wl-panel {
            background: #f2fafc;
        }

        .archive li:nth-child(odd) {
            background: #f2fafc;
            ;
        }

        .archive li:nth-child(even) {
            background: #f2fafc;
        }

        .post-md table tr:nth-child(odd) td {
            background: #f2fafc;
        }

        .post-md table tr:nth-child(even) td {
            background: #f2fafc;
        }

    
        .progress-wrap::after {
            color: #323e74; /* 箭头的颜色 */
        }
        .progress-wrap svg.progress-circle path {
	        stroke: #323e74; /* 边框的颜色 */
        }
        .progress-wrap::before {
	        background-image: linear-gradient(298deg, #7f688d, #7f688d); /* 鼠标滑过的箭头颜色 */
         }

        .return-to-last-progress-wrap::after {
            color: #323e74; /* 箭头的颜色 */
        }
        .return-to-last-progress-wrap svg.progress-circle path {
	        stroke: #323e74; /* 边框的颜色 */
        }
        .return-to-last-progress-wrap::before {
	        background-image: linear-gradient(298deg, #7f688d, #7f688d); /* 鼠标滑过的箭头颜色 */
         }

         .left-toc-container::-webkit-scrollbar-thumb {
            background-color: #323e74; /* 设置滚动条拖动块的颜色 */
        }

        .bs-docs-sidebar .nav>.active>a,
        .bs-docs-sidebar .nav>li>a:hover,
        .bs-docs-sidebar .nav>li>a:focus {
            color: #7f688d;
            border-left-color: #7f688d;
        }
        .bs-docs-sidebar .nav>li>a {
            color:  #323e74;
        }
    </style>

    
    <style>
        body {
            background-image: url(/img/3.jpg);
            background-attachment: fixed;  /* 背景固定，不随页面滚动 */
            background-repeat: no-repeat;  /* 防止背景图片重复 */
            background-size: cover;       /* 背景自适应大小，覆盖整个背景 */
            background-position: center;   /* 背景居中显示 */
        }
        .paper {
            background-image: url(/img/3.jpg);
            background-attachment: fixed;  /* 背景固定，不随页面滚动 */
            background-repeat: no-repeat;  /* 防止背景图片重复 */
            background-size: cover;       /* 背景自适应大小，覆盖整个背景 */
            background-position: center;   /* 背景居中显示 */
        }  
    </style>


    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        <script>
            const options = {
                bottom: '40px', // default: '32px'
                right: 'unset', // default: '32px'
                left: '42px', // default: 'unset'
                time: '0.3s', // default: '0.3s'
                mixColor: '#fff', // default: '#fff'
                backgroundColor: ' #eaeae8  ',  // default: '#fff'
                buttonColorDark: '#100f2c',  // default: '#100f2c'
                buttonColorLight: '#fff', // default: '#fff'
                saveInCookies: true, // default: true,
                label: '🌓', // default: ''
                autoMatchOsTheme: true // default: true
            }
            const darkmode = new Darkmode(options);
            darkmode.showWidget();
        </script>
        
        
            
                <div class="left-toc-container">
                    <nav id="toc" class="bs-docs-sidebar"></nav>
                </div>
            
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <style>
            .header-img {
                width: 56px;
                height: auto;
                object-fit: cover; /* 保持图片比例 */
                transition: transform 0.3s ease-in-out; 
                border-radius: 0; 
            }
            
        </style>
        <img 
            alt="^-^" 
            cache-control="max-age=86400" 
            class="header-img" 
            src="/img/20250602032635.jpg" 
        />
        <div class="header-content">
            <a class="logo" href="/">Yann</a> 
            <span class="description">人工智能、计算机、机器学习、linux、程序员</span> 
        </div>
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/about/">关于</a></li>
            
        
            
                <li><a href="/tags/">标签</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">
    

    
        
            
                <div class="post-main-title" style="text-align: center;">
                    浙大PAT考试数据结构与算法模板整理
                </div>
            
        
      
    

    

        
            <div class="post-head-meta-center">
        
                
                    <span>最近更新：2022-02-26</span> 
                
                
                    
                        &nbsp; | &nbsp;
                    
                     <span>字数总计：15.9k</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span>阅读估时：80分钟</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span id="busuanzi_container_page_pv">
                        阅读量：<span id="busuanzi_value_page_pv"></span>次
                    </span>
                
            </div>
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="post-toc-text">字符串</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="post-toc-text">字符串类型转换</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#01-to-string"><span class="post-toc-text">01 to_string()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#02-stoi-%E5%92%8Catoi"><span class="post-toc-text">02 stoi()和atoi()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#03-string%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95c-str"><span class="post-toc-text">03 string类的方法c_str()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#04-string%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95find"><span class="post-toc-text">04 string类的方法find()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#05-string%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95substr"><span class="post-toc-text">05 string类的方法substr()</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#KMP"><span class="post-toc-text">KMP</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="post-toc-text">排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="post-toc-text">堆排序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="post-toc-text">快速排序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BA%BF%E6%80%A7%E7%AC%ACK%E5%A4%A7-%E5%BF%AB%E6%8E%92%E6%80%9D%E6%83%B3%E5%BA%94%E7%94%A8"><span class="post-toc-text">线性第K大(快排思想应用)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="post-toc-text">归并排序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%88%A4%E6%96%AD%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="post-toc-text">判断插入排序</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BA%8C%E5%88%86"><span class="post-toc-text">二分</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86"><span class="post-toc-text">整数二分</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="post-toc-text">链表</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="post-toc-text">单链表</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="post-toc-text">双链表</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="post-toc-text">栈和队列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="post-toc-text">单调栈</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="post-toc-text">单调队列</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%A0%91"><span class="post-toc-text">树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="post-toc-text">反转二叉树</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="post-toc-text">构建二叉搜索树</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%88%A4%E6%96%AD%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="post-toc-text">判断完全二叉树</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86"><span class="post-toc-text">二叉树遍历</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#01-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="post-toc-text">01 先序遍历</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#02-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="post-toc-text">02 中序遍历</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#03-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="post-toc-text">03 后序遍历</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="post-toc-text">重建二叉树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#01-%E5%85%88%E5%BA%8F-%E5%90%8E%E5%BA%8F-%E4%B8%8D%E5%94%AF%E4%B8%80"><span class="post-toc-text">01 先序+后序(不唯一)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#02-%E5%85%88%E5%BA%8F-%E4%B8%AD%E5%BA%8F-%E5%94%AF%E4%B8%80"><span class="post-toc-text">02 先序+中序(唯一)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#03-%E5%90%8E%E5%BA%8F-%E4%B8%AD%E5%BA%8F-%E5%94%AF%E4%B8%80"><span class="post-toc-text">03 后序+中序(唯一)</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0AVL%E6%A0%91%E6%8F%92%E5%85%A5"><span class="post-toc-text">手动实现AVL树插入</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%88%A4%E6%96%AD%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="post-toc-text">判断红黑树</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#DFS%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E6%98%AF%E5%90%A6%E4%B8%BA%E5%A0%86"><span class="post-toc-text">DFS判断一个先序遍历是否为堆</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="post-toc-text">最低公共祖先</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="post-toc-text">并查集</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#01-%E6%9C%B4%E7%B4%A0%E7%89%88%E6%9C%AC"><span class="post-toc-text">01 朴素版本</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#02-%E5%90%88%E5%B9%B6%E6%97%B6%E6%9B%B4%E6%96%B0%E9%A2%9D%E5%A4%96%E4%BF%A1%E6%81%AF"><span class="post-toc-text">02 合并时更新额外信息</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%9B%BE"><span class="post-toc-text">图</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98"><span class="post-toc-text">最短路径与扩展问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#01-%E6%9C%B4%E7%B4%A0dijkstra"><span class="post-toc-text">01 朴素dijkstra</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#02-%E5%A0%86%E4%BC%98%E5%8C%96%E7%89%88dijkstra"><span class="post-toc-text">02 堆优化版dijkstra</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#03-%E5%AF%B9%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%80%89%E6%8B%A9%E7%9A%84%E6%89%A9%E5%B1%95"><span class="post-toc-text">03 对最短路选择的扩展</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#04-%E5%AF%B9%E6%9C%80%E7%9F%AD%E8%B7%AF%E4%BF%A1%E6%81%AF%E7%9A%84%E6%89%A9%E5%B1%95"><span class="post-toc-text">04 对最短路信息的扩展</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%88%A4%E6%96%AD%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%9E%E8%B7%AF"><span class="post-toc-text">判断哈密顿回路</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84"><span class="post-toc-text">欧拉路径</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%A1%B6%E7%82%B9%E8%A6%86%E7%9B%96"><span class="post-toc-text">顶点覆盖</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9C%80%E5%A4%A7%E5%9B%A2"><span class="post-toc-text">最大团</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="post-toc-text">拓扑排序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9F%93%E8%89%B2%E9%97%AE%E9%A2%98"><span class="post-toc-text">染色问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#01-%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9F%93%E8%89%B2"><span class="post-toc-text">01 二分图染色</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#02-%E5%88%A4%E6%96%AD%E6%9F%93%E8%89%B2%E6%96%B9%E6%A1%88"><span class="post-toc-text">02 判断染色方案</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%95%B0%E5%AD%A6"><span class="post-toc-text">数学</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6"><span class="post-toc-text">高精度</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#01-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95"><span class="post-toc-text">01 高精度加法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#02-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95"><span class="post-toc-text">02 高精度减法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#03-%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95"><span class="post-toc-text">03 高精度乘法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#04-%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95"><span class="post-toc-text">04 高精度除法*</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E5%AD%90"><span class="post-toc-text">分解质因子</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%88%86%E6%95%B0%E8%BF%90%E7%AE%97-%E5%92%8C%E5%B7%AE%E7%A7%AF%E5%95%86"><span class="post-toc-text">分数运算(和差积商)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%B4%A0%E6%95%B0%E7%AD%9B"><span class="post-toc-text">素数筛</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#01-%E6%9C%B4%E7%B4%A0%E7%AD%9B%E6%B3%95"><span class="post-toc-text">01 朴素筛法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#02-%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95"><span class="post-toc-text">02 埃氏筛法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#03-%E7%BA%BF%E6%80%A7%E7%AD%9B"><span class="post-toc-text">03 线性筛</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="post-toc-text">快速幂</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="post-toc-text">动态规划</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="post-toc-text">背包问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#01%E8%83%8C%E5%8C%85"><span class="post-toc-text">01背包</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#02-%E7%A1%AC%E5%B8%81%E6%89%BE%E9%9B%B6"><span class="post-toc-text">02 硬币找零</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#03-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="post-toc-text">03 完全背包</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#04-%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3"><span class="post-toc-text">04 整数分解</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#05-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="post-toc-text">05 多重背包*</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C"><span class="post-toc-text">最大子序列和</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="post-toc-text">最长公共子序列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#01-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="post-toc-text">01 最长公共子序列</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#02-%E5%8F%98%E7%A7%8D-%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D%E5%A4%9A%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="post-toc-text">02 变种(一个字符匹配多个字符)</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B"><span class="post-toc-text">状态机模型</span></a></li></ol></li></ol>
            
        
        <div class=".article-gallery"><blockquote>
<p>之前把浙大PAT甲级题库刷完了，整理一下PAT的考点</p>
<p>题目来源于ACwing网站</p>
</blockquote>
<span id="more"></span>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h2><h3 id="字符串类型转换"><a href="#字符串类型转换" class="headerlink" title="字符串类型转换"></a>字符串类型转换</h3><h4 id="01-to-string"><a href="#01-to-string" class="headerlink" title="01 to_string()"></a>01 to_string()</h4><p>这个太常用了不多说了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">3.14</span>;</span><br><span class="line">string str1, str2;</span><br><span class="line">str1 = <span class="built_in">to_string</span>(a);</span><br><span class="line">str2 = <span class="built_in">to_string</span>(b);</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h4 id="02-stoi-和atoi"><a href="#02-stoi-和atoi" class="headerlink" title="02 stoi()和atoi()"></a>02 stoi()和atoi()</h4><p>C++11包含在#include。作用是将字符串转化为int型。区别是stoi的形参直接传入string类型即可，而atoi的形参是const char*</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;1234567&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span>* s2 = <span class="string">&quot;1234567&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="built_in">stoi</span>(s1);</span><br><span class="line"><span class="keyword">int</span> b = <span class="built_in">atoi</span>(s2);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>进化版：stol(),stoll(),stoul(),stoull(),atol(),atoll(),atoul(),atoull()</p>
<p>l为long int，ll为long long，ul为unsigned long int，ull为unsigned long long</p>
<h4 id="03-string类的方法c-str"><a href="#03-string类的方法c-str" class="headerlink" title="03 string类的方法c_str()"></a>03 string类的方法c_str()</h4><p>c_str()就是将C++的string转化为C的字符串数组，c_str()生成一个const char *指针，指向字符串的首地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p=s[<span class="number">10</span>];</span><br><span class="line">string a=“welcome”;</span><br><span class="line"><span class="built_in">strcpy</span>(p,a.<span class="built_in">c_str</span>());</span><br><span class="line">cout&lt;&lt;p;</span><br></pre></td></tr></table></figure>
<p>如果需要使用C语言printf的格式化输出string时可以使用，很方便，比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string name=<span class="string">&quot;PAT&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,name.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure>
<h4 id="04-string类的方法find"><a href="#04-string类的方法find" class="headerlink" title="04 string类的方法find()"></a>04 string类的方法find()</h4><p>在string中找到目标字符的位置，返回数组下标</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&quot;e&quot;</span>) &lt;&lt; endl;<span class="comment">//结果为1</span></span><br></pre></td></tr></table></figure>
<p>未找到会返回一个特殊的标志npos(一个很大的数字)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;a&quot;</span>) == s.npos)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;not found&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>从指定位置开始查找</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="comment">//从下标为5的数组位置开始查找(也就是忽略前面的)</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&quot;l&quot;</span>,<span class="number">5</span>) &lt;&lt; endl;<span class="comment">//结果为9</span></span><br></pre></td></tr></table></figure>
<h4 id="05-string类的方法substr"><a href="#05-string类的方法substr" class="headerlink" title="05 string类的方法substr()"></a>05 string类的方法substr()</h4><p>截取子串</p>
<p>单参数形式(给出截取开始的位置，末尾默认为原string末尾)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;12345abcd&quot;</span>)</span></span>;</span><br><span class="line">string a = s.<span class="built_in">substr</span>(<span class="number">5</span>);<span class="comment">//获得字符串s中从下标为5开始一直到末尾的字符串</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;<span class="comment">//结果为abcd</span></span><br></pre></td></tr></table></figure>
<p>双参数形式(给出截取开始的位置，并给出截取长度)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;12345abcd&quot;</span>)</span></span>;</span><br><span class="line">string a = s.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">5</span>);<span class="comment">//获得字符串s中从下标为0开始的长度为5的字符串</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;<span class="comment">//结果为12345</span></span><br></pre></td></tr></table></figure>
<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>给定一个模式串S，以及一个模板串P，所有字符串中只包含大小写英文字母以及阿拉伯数字。</p>
<p>模板串P在模式串S中多次作为子串出现。</p>
<p>求出模板串P在模式串S中所有出现的位置的起始下标。</p>
<p><strong>输入格式</strong></p>
<p>第一行输入整数N，表示字符串P的长度。</p>
<p>第二行输入字符串P。</p>
<p>第三行输入整数M，表示字符串S的长度。</p>
<p>第四行输入字符串S。</p>
<p><strong>输出格式</strong></p>
<p>共一行，输出所有出现位置的起始下标（下标从0开始计数），整数之间用空格隔开。</p>
<p><strong>数据范围</strong></p>
<p>1≤N≤10^5<br>1≤M≤10^6</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">aba</span><br><span class="line">5</span><br><span class="line">ababa</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2</span><br></pre></td></tr></table></figure>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>,M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> t[N],p[M];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">build</span><span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *ne=<span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">-1</span>;</span><br><span class="line">    ne[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;m<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;<span class="number">0</span>||p[i]==p[j])&#123;</span><br><span class="line">            i++,j++;</span><br><span class="line">            ne[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j=ne[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span> *t,<span class="keyword">char</span>* p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *ne=<span class="built_in">build</span>(p);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;m&amp;&amp;i&lt;n)</span><br><span class="line">            <span class="keyword">if</span>(j&lt;<span class="number">0</span>||t[i]==p[j])</span><br><span class="line">                i++,j++;</span><br><span class="line">            <span class="keyword">else</span> j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(j==m)&#123;    </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-j);</span><br><span class="line">            i--;</span><br><span class="line">            j=ne[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s%d%s&quot;</span>,&amp;m,p,&amp;n,t);</span><br><span class="line">    <span class="built_in">match</span>(t,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a><strong>排序</strong></h2><p>PAT常考的排名方式(同分布排名)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!i||a[i].grade!=a[i<span class="number">-1</span>].grade)</span><br><span class="line">      a[i].rank=i+<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">else</span> a[i].rank=a[i<span class="number">-1</span>].rank;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>输入一个长度为n的整数数列，从小到大输出前m小的数。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含整数n和m。</p>
<p>第二行包含n个整数，表示整数数列。</p>
<p><strong>输出格式</strong></p>
<p>共一行，包含m个整数，表示整数数列中前m小的数。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">4 5 1 3 2</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[maxn],size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=x;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*x&lt;=size&amp;&amp;h[<span class="number">2</span>*x]&lt;h[t]) t=<span class="number">2</span>*x;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*x+<span class="number">1</span>&lt;=size&amp;&amp;h[<span class="number">2</span>*x+<span class="number">1</span>]&lt;h[t]) t=<span class="number">2</span>*x+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(t!=x)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[t],h[x]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x/<span class="number">2</span>&amp;&amp;h[x]&lt;h[x/<span class="number">2</span>])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[x],h[x/<span class="number">2</span>]);</span><br><span class="line">        x/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    size=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        <span class="built_in">down</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,h[<span class="number">1</span>]);</span><br><span class="line">        h[<span class="number">1</span>]=h[size--];</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>这里默认为升序排序，降序只要对比较的符号进行调整就可以了</p>
<p>快速排序分为三个过程：</p>
<ol>
<li>将数列划分为两部分（不是直接分，要求保证相对大小关系）</li>
<li>递归到两个子序列中分别进行快速排序</li>
<li>不用合并，因为此时数列已经完全有序</li>
</ol>
<p>首先对于第一步来说我们需要先找到一个基准值（基准值用于将整个数组切分成小和大两部分）</p>
<p>然后使用两个指针和来进行操作，大概原理就是先将指向的位置，指向的位置，然后使用do while循环使i指针疯狂向前直到遇到第一个比基准值大的数字停下，接下来对j指针也同样操作使其停在第一个比基准值小的数值上，然后互换，的数字。一直操作到ij指针相遇，那么由于对一路上不符合条件的数字都进行了互换，所以i和j相遇的就是整个数组的切分点。</p>
<p>OK我们找到了切分点，接下来就是递归操作(l,j),(j+1,r)了</p>
<p><strong>注意事项：当切分点取a[l]时，递归取(l,j),(j+1,r)。当切分点取a[r]时，递归取(l,i-1),(i,r)。当切分点其余数字时，递归二者皆可(避免出现死循环)</strong></p>
<p>每个递归直到l&gt;=r停止，因为一个点是不需要再“划分”的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn],n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> x=a[l],i=l<span class="number">-1</span>,j=r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(a[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(a[j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(a[i],a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(l,j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">quick_sort</span>(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线性第K大-快排思想应用"><a href="#线性第K大-快排思想应用" class="headerlink" title="线性第K大(快排思想应用)"></a>线性第K大(快排思想应用)</h3><p>找第 k 大的数（K-th order statistic），最简单的方法是先排序，然后直接找到第 k 大的位置的元素。这样做的时间复杂度是O(nlogn)，对于这个问题来说很不划算。事实上，我们有时间复杂度 的解法。</p>
<p>考虑快速排序的划分过程，在快速排序的“划分”结束后，我们会将数组分成两部分，我们可以通过检查k是否落在左边的范围内来减少复杂度，在排序的途中解决这个问题，当然这时候快排就不会全部排完了，而是找到了k就中途退出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+10;</span><br><span class="line"></span><br><span class="line">int a[maxn];</span><br><span class="line"></span><br><span class="line">int quick_sort(int l,int r,int k)&#123;</span><br><span class="line">    if(l==r&amp;&amp;l==k) return a[k];</span><br><span class="line">    int x=a[l],i=l-1,j=r+1;</span><br><span class="line">    while(i&lt;j)&#123;</span><br><span class="line">        do i++; while(a[i]&lt;x);</span><br><span class="line">        do j--; while(a[j]&gt;x);</span><br><span class="line">        if(i&lt;j) swap(a[i],a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    if(l&lt;=k&amp;&amp;k&lt;=j) quick_sort(l,j,k);</span><br><span class="line">    else quick_sort(j+1,r,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">    for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    printf(&quot;%d\n&quot;,quick_sort(0,n-1,k-1));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是一种采用了 <strong>分治</strong> 思想的排序算法，其本质是一种 <strong>CDQ 分治</strong>。</p>
<p>归并排序分为三个过程：</p>
<ol>
<li>将数列随意划分为两部分（在均匀划分时时间复杂度为 O(nlogn)）</li>
<li>递归地分别对两个子序列进行归并排序</li>
<li>合并两个子序列</li>
</ol>
<p>不难发现，归并排序的核心是如何合并两个子序列，前两步都很好实现。</p>
<p>其实合并的时候也不难操作。注意到两个子序列在第二步中已经保证了都是有序的了，第三步中实际上是想要把两个 <strong>有序</strong> 的序列合并起来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn],t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(l,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">int</span> i=l,j=mid+<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j]) t[k++]=a[i++];</span><br><span class="line">        <span class="keyword">else</span> t[k++]=a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) t[k++]=a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) t[k++]=a[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l,j=<span class="number">0</span>;j&lt;k;i++,j++)</span><br><span class="line">        a[i]=t[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">merge_sort</span>(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断插入排序"><a href="#判断插入排序" class="headerlink" title="判断插入排序"></a>判断插入排序</h3><p>PAT出过两次的考点，判断一个排到一半的排序是否是插入排序还是别的排序（PAT会保证答案唯一）</p>
<p>一般可以使用这个方法，将数组分成两段，一段是排好序的（非降序），另一段是没有排好序的，我们找到没排序的那一段的起点，往下比对是否与原数组相同即可，不同就不是插入排序（因为插入排序是不会改变未排序的数组元素的顺序的）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;b[i];</span><br><span class="line"><span class="keyword">int</span> p=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(p&lt;=n&amp;&amp;b[p]&gt;=b[p<span class="number">-1</span>]) p++;</span><br><span class="line"><span class="keyword">int</span> k=p;</span><br><span class="line"><span class="keyword">while</span>(p&lt;=n&amp;&amp;a[p]==b[p]) p++;</span><br><span class="line"><span class="keyword">if</span>(p==n+<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Insertion Sort&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span>(k&gt;<span class="number">1</span>&amp;&amp;b[k]&lt;b[k<span class="number">-1</span>]) <span class="built_in">swap</span>(b[k],b[k<span class="number">-1</span>]),k--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a><strong>二分</strong></h2><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><p>二分搜索，也称折半搜索、二分查找，是用来在一个有序数组中查找某一元素的算法。</p>
<p>以在一个升序数组中查找一个数为例。</p>
<p>它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需要到右侧去找就好了；如果中间元素大于所查找的值，同理，右侧的只会更大而不会有所查找的元素，所以只需要到左侧去找。</p>
<p>在二分搜索过程中，每次都把查询的区间减半，因此对于一个长度为n的数组，至多会进行O(logn)次查找。</p>
<p>下面是第一种整数二分形式，<strong>用于找到&gt;=x的区间的第一个数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质</span><br><span class="line"></span><br><span class="line">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="line">int bsearch_1(int l, int r)</span><br><span class="line">&#123;</span><br><span class="line">    while (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = l + r &gt;&gt; 1;</span><br><span class="line">        if (check(mid)) r = mid;    // check()判断mid是否满足性质</span><br><span class="line">        else l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是第二种整数二分形式，<strong>用于找到&lt;=x的最后一个数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质</span><br><span class="line"></span><br><span class="line">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="line">int bsearch_2(int l, int r)</span><br><span class="line">&#123;</span><br><span class="line">    while (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = l + r + 1 &gt;&gt; 1;</span><br><span class="line">        if (check(mid)) l = mid;</span><br><span class="line">        else r = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a><strong>链表</strong></h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+10;</span><br><span class="line"></span><br><span class="line">int e[maxn],ne[maxn],head,idx;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    head=-1;</span><br><span class="line">    idx=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add_to_head(int x)&#123;</span><br><span class="line">    e[idx]=x;</span><br><span class="line">    ne[idx]=head;</span><br><span class="line">    head=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(int k,int x)&#123;</span><br><span class="line">    e[idx]=x;</span><br><span class="line">    ne[idx]=ne[k];</span><br><span class="line">    ne[k]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void remove(int k)&#123;</span><br><span class="line">    ne[k]=ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k,x;</span><br><span class="line">    char c;</span><br><span class="line">    init();</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        cin&gt;&gt;c;</span><br><span class="line">        if(c==&#x27;H&#x27;)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            add_to_head(x);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(c==&#x27;I&#x27;)&#123;</span><br><span class="line">            cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            add(k-1,x);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            if(!k) head=ne[head];</span><br><span class="line">            else remove(k-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=head;i!=-1;i=ne[i])&#123;</span><br><span class="line">        if(i!=head) cout &lt;&lt; &#x27; &#x27;;</span><br><span class="line">        cout &lt;&lt; e[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+10;</span><br><span class="line"></span><br><span class="line">int l[maxn],r[maxn],e[maxn],idx;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    r[0]=1;</span><br><span class="line">    l[1]=0;</span><br><span class="line">    idx=2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insertR(int k,int x)&#123;</span><br><span class="line">    e[idx]=x;</span><br><span class="line">    l[idx]=k;</span><br><span class="line">    r[idx]=r[k];</span><br><span class="line">    l[r[k]]=idx;</span><br><span class="line">    r[k]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insertL(int k,int x)&#123;</span><br><span class="line">    insertR(l[k],x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void addL(int x)&#123;</span><br><span class="line">    insertR(0,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void addR(int x)&#123;</span><br><span class="line">    insertL(1,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void remove(int k)&#123;</span><br><span class="line">    r[l[k]]=r[k];</span><br><span class="line">    l[r[k]]=l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k,x;</span><br><span class="line">    string s;</span><br><span class="line">    init();</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        if(s==&quot;L&quot;)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            addL(x);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(s==&quot;R&quot;)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            addR(x);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(s==&quot;D&quot;)&#123;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            remove(k+1);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(s==&quot;IL&quot;)&#123;</span><br><span class="line">            cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            insertL(k+1,x);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            insertR(k+1,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=r[0];i!=1;i=r[i])&#123;</span><br><span class="line">        if(i!=r[0]) cout &lt;&lt; &#x27; &#x27;;</span><br><span class="line">        cout &lt;&lt; e[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br></pre></td></tr></table></figure>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a><strong>栈和队列</strong></h2><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>给定一个长度为N的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出-1。</p>
<p>输入格式</p>
<p>第一行包含整数N，表示数列长度。</p>
<p>第二行包含N个整数，表示整数数列。</p>
<p>输出格式</p>
<p>共一行，包含N个整数，其中第i个数表示第i个数的左边第一个比它小的数，如果不存在则输出-1。</p>
<p>输入样例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 2 7 5</span><br></pre></td></tr></table></figure>
<p>输出样例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 3 -1 2 2</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+10;</span><br><span class="line"></span><br><span class="line">int s[maxn],t;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,x;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        while(t&amp;&amp;s[t-1]&gt;=x) t--;</span><br><span class="line">        if(t) printf(&quot;%d &quot;,s[t-1]);</span><br><span class="line">        else printf(&quot;-1 &quot;);</span><br><span class="line">        s[t++]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>给定一个大小为n≤10^6的数组。</p>
<p>有一个大小为k的滑动窗口，它从数组的最左边移动到最右边。</p>
<p>您只能在窗口中看到k个数字。</p>
<p>每次滑动窗口向右移动一个位置。</p>
<p>以下是一个例子：</p>
<p>该数组为[1 3 -1 -3 5 3 6 7]，k为3。</p>
<table>
<thead>
<tr>
<th style="text-align:left">窗口位置</th>
<th style="text-align:left">最小值</th>
<th style="text-align:left">最大值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">[1 3 -1] -3 5 3 6 7</td>
<td style="text-align:left">-1</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left">1 [3 -1 -3] 5 3 6 7</td>
<td style="text-align:left">-3</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left">1 3 [-1 -3 5] 3 6 7</td>
<td style="text-align:left">-3</td>
<td style="text-align:left">5</td>
</tr>
<tr>
<td style="text-align:left">1 3 -1 [-3 5 3] 6 7</td>
<td style="text-align:left">-3</td>
<td style="text-align:left">5</td>
</tr>
<tr>
<td style="text-align:left">1 3 -1 -3 [5 3 6] 7</td>
<td style="text-align:left">3</td>
<td style="text-align:left">6</td>
</tr>
<tr>
<td style="text-align:left">1 3 -1 -3 5 [3 6 7]</td>
<td style="text-align:left">3</td>
<td style="text-align:left">7</td>
</tr>
</tbody>
</table>
<p>您的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p>
<p>输入格式</p>
<p>输入包含两行。</p>
<p>第一行包含两个整数n和k，分别代表数组长度和滑动窗口的长度。</p>
<p>第二行有n个整数，代表数组的具体数值。</p>
<p>同行数据之间用空格隔开。</p>
<p>输出格式</p>
<p>输出包含两个。</p>
<p>第一行输出，从左至右，每个位置滑动窗口中的最小值。</p>
<p>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p>
<p>输入样例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></figure>
<p>输出样例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e6+10;</span><br><span class="line"></span><br><span class="line">int a[maxn],q[maxn],head,rear;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">    for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        if(rear&gt;head&amp;&amp;i-k+1&gt;q[head]) head++;</span><br><span class="line">        while(rear&gt;head&amp;&amp;a[q[rear-1]]&gt;=a[i]) rear--;</span><br><span class="line">        q[rear++]=i;</span><br><span class="line">        if(i-k+1&gt;=0) printf(&quot;%d &quot;,a[q[head]]);</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;&quot;);</span><br><span class="line">    head=rear=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        if(rear&gt;head&amp;&amp;i-k+1&gt;q[head]) head++;</span><br><span class="line">        while(rear&gt;head&amp;&amp;a[q[rear-1]]&lt;=a[i]) rear--;</span><br><span class="line">        q[rear++]=i;</span><br><span class="line">        if(i-k+1&gt;=0) printf(&quot;%d &quot;,a[q[head]]);</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a><strong>树</strong></h2><h3 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树"></a>反转二叉树</h3><p>很简单了不多解释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void dfs_reverse(int u)&#123;</span><br><span class="line">    if(u==-1) return;</span><br><span class="line">    dfs_reverse(l[u]);</span><br><span class="line">    dfs_reverse(r[u]);</span><br><span class="line">    swap(l[u],r[u]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建二叉搜索树"><a href="#构建二叉搜索树" class="headerlink" title="构建二叉搜索树"></a>构建二叉搜索树</h3><p>这里指的是从空树一个个插入结点构建二叉搜索树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1010;</span><br><span class="line"></span><br><span class="line">int l[maxn],r[maxn],e[maxn],idx;</span><br><span class="line"></span><br><span class="line">void insert(int&amp; u,int x)&#123;</span><br><span class="line">    if(!u)&#123;</span><br><span class="line">        u=++idx;</span><br><span class="line">        e[u]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(x&lt;=e[u]) insert(l[u],x);//注意题干中是小于还是小于等于</span><br><span class="line">    else insert(r[u],x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断完全二叉树"><a href="#判断完全二叉树" class="headerlink" title="判断完全二叉树"></a>判断完全二叉树</h3><p>用数组存储，看n个结点是否分布在1到n的位置，如果没有就不是完全二叉树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1010;</span><br><span class="line"></span><br><span class="line">int l[maxn],r[maxn],cnt[maxn];</span><br><span class="line">int maxk,maxid;</span><br><span class="line"></span><br><span class="line">void dfs(int u,int k)&#123;</span><br><span class="line">    if(u==-1) return;</span><br><span class="line">    if(k&gt;maxk)&#123;</span><br><span class="line">        maxk=k;</span><br><span class="line">        maxid=u;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(l[u],k*2);</span><br><span class="line">    dfs(r[u],k*2+1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    string x,y;</span><br><span class="line">    memset(l,-1,sizeof l);</span><br><span class="line">    memset(r,-1,sizeof r);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        if(x!=&quot;-&quot;) l[i]=stoi(x),cnt[l[i]]++;</span><br><span class="line">        if(y!=&quot;-&quot;) r[i]=stoi(y),cnt[r[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    int root=0;</span><br><span class="line">    while(cnt[root]) root++;</span><br><span class="line">    dfs(root,1);</span><br><span class="line">    if(maxk==n) printf(&quot;YES %d\n&quot;,maxid);</span><br><span class="line">    else printf(&quot;NO %d\n&quot;,root);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p>首先是固定的套路</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Node&#123;</span><br><span class="line">    int val;</span><br><span class="line">    Node* lchild,*rchild;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="01-先序遍历"><a href="#01-先序遍历" class="headerlink" title="01 先序遍历"></a>01 先序遍历</h4><p>(三种方法，难度从低到高，性能从劣到优)</p>
<p>第一种：使用递归的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void preorder1(Node *node)&#123;</span><br><span class="line">    if(node==NULL)</span><br><span class="line">        return;</span><br><span class="line">    printf(&quot;%d\n&quot;,node-&gt;val);</span><br><span class="line">    if(node-&gt;lchild!=NULL)</span><br><span class="line">        preorder1(node-&gt;lchild);</span><br><span class="line">    if(node-&gt;rchild!=NULL)</span><br><span class="line">        preorder1(node-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种：使用栈辅助递归降低复杂度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void preorder2(Node *node)&#123;</span><br><span class="line">    stack&lt;Node*&gt; sta;</span><br><span class="line">    if(node!=NULL)</span><br><span class="line">        sta.push(node);</span><br><span class="line">    while(!sta.empty())&#123;</span><br><span class="line">        Node* p=sta.top();sta.pop();</span><br><span class="line">        printf(&quot;%d\n&quot;,p-&gt;val);</span><br><span class="line">        if(node-&gt;rchild!=NULL)</span><br><span class="line">            sta.push(p-&gt;rchild);</span><br><span class="line">        if(node-&gt;lchild!=NULL)</span><br><span class="line">            preorder2(node-&gt;lchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三种：纯用栈遍历，沿左子树链下行，途中将右子树压栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void visitAlongLeftBranch(Node* node,stack&lt;Node*&gt;&amp; sta)&#123;</span><br><span class="line">    while(node!=NULL)&#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,node-&gt;val);</span><br><span class="line">        sta.push(node-&gt;rchild);</span><br><span class="line">        node=node-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void preorder3(Node* node)&#123;</span><br><span class="line">    stack&lt;Node*&gt; sta;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        visitAlongLeftBranch(node,sta);</span><br><span class="line">        if(sta.empty())</span><br><span class="line">            break;</span><br><span class="line">        node=sta.top();</span><br><span class="line">        sta.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="02-中序遍历"><a href="#02-中序遍历" class="headerlink" title="02 中序遍历"></a>02 中序遍历</h4><p>(两种方法，难度从低到高，性能从劣到优)</p>
<p>第一种：使用递归的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void inorder1(Node* node)&#123;</span><br><span class="line">    if(node==NULL)</span><br><span class="line">        return;</span><br><span class="line">    if(node-&gt;lchild!=NULL)</span><br><span class="line">        inorder1(node-&gt;lchild);</span><br><span class="line">    printf(&quot;%d\n&quot;,node-&gt;val);</span><br><span class="line">    if(node-&gt;rchild!=NULL)</span><br><span class="line">        inorder1(node-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种：纯用栈遍历，将左子树压栈，一直到最左边的叶子节点，从栈中弹出节点访问并进入右子树，反复该过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void goAlongLeftBranch(Node* node,stack&lt;Node*&gt;&amp; sta)&#123;</span><br><span class="line">    while(node!=NULL) &#123;</span><br><span class="line">        sta.push(node);</span><br><span class="line">        node=node-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void inorder2(Node* node)&#123;</span><br><span class="line">    stack&lt;Node*&gt; sta;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        goAlongLeftBranch(node,sta);</span><br><span class="line">        if(sta.empty())</span><br><span class="line">            break;</span><br><span class="line">        node=sta.top();</span><br><span class="line">        sta.pop();</span><br><span class="line">        printf(&quot;%d\n&quot;,node-&gt;val);</span><br><span class="line">        node=node-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="03-后序遍历"><a href="#03-后序遍历" class="headerlink" title="03 后序遍历"></a>03 后序遍历</h4><p>(后序的栈辅助比较复杂，不写了)</p>
<p>使用递归的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void postorder(Node *node)&#123;</span><br><span class="line">    if(node==NULL)</span><br><span class="line">        return;</span><br><span class="line">    printf(&quot;%d\n&quot;,node-&gt;val);</span><br><span class="line">    if(node-&gt;rchild!=NULL)</span><br><span class="line">        postorder1(node-&gt;rchild);</span><br><span class="line">    if(node-&gt;lchild!=NULL)</span><br><span class="line">        postorder1(node-&gt;lchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><h4 id="01-先序-后序-不唯一"><a href="#01-先序-后序-不唯一" class="headerlink" title="01 先序+后序(不唯一)"></a>01 先序+后序(不唯一)</h4><p>假设一个二叉树上所有结点的权值都互不相同。</p>
<p>我们可以通过后序遍历和中序遍历来确定唯一二叉树。</p>
<p>也可以通过前序遍历和中序遍历来确定唯一二叉树。</p>
<p>但是，如果只通过前序遍历和后序遍历，则有可能无法确定唯一二叉树。</p>
<p>现在，给定一组前序遍历和后序遍历，请你输出对应二叉树的中序遍历。</p>
<p>如果树不是唯一的，则输出任意一种可能树的中序遍历即可。</p>
<p>输入格式</p>
<p>第一行包含整数 N，表示结点数量。</p>
<p>第二行给出前序遍历序列。</p>
<p>第三行给出后序遍历序列。</p>
<p>一行中的数字都用空格隔开。</p>
<p>输出格式</p>
<p>首先第一行，如果树唯一，则输出 <code>Yes</code>，如果不唯一，则输出 <code>No</code>。</p>
<p>然后在第二行，输出树的中序遍历。</p>
<p>注意，如果树不唯一，则输出任意一种可能的情况均可。</p>
<p>数据范围</p>
<p>1≤N≤30</p>
<p>输入样例1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">1 2 3 4 6 7 5</span><br><span class="line">2 6 7 4 5 3 1</span><br></pre></td></tr></table></figure>
<p>输出样例1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">2 1 6 4 7 3 5</span><br></pre></td></tr></table></figure>
<p>输入样例2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 2 3 4</span><br><span class="line">2 4 3 1</span><br></pre></td></tr></table></figure>
<p>输出样例2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No</span><br><span class="line">2 1 3 4</span><br></pre></td></tr></table></figure>
<p>代码</p>
<p>直接暴力枚举左子树和右子树的长度即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=40;</span><br><span class="line"></span><br><span class="line">int pre[maxn],post[maxn];</span><br><span class="line"></span><br><span class="line">int dfs(int l1,int r1,int l2,int r2,string&amp; s)&#123;</span><br><span class="line">    if(l1&gt;r1) return 1;</span><br><span class="line">    if(pre[l1]!=post[r2]) return 0;</span><br><span class="line">    int cnt=0;</span><br><span class="line">    for(int i=l1;i&lt;=r1;i++)&#123;</span><br><span class="line">        string ls,rs;</span><br><span class="line">        int lcnt=dfs(l1+1,i,l2,l2+i-l1-1,ls);</span><br><span class="line">        int rcnt=dfs(i+1,r1,l2+i-l1-1+1,r2-1,rs);</span><br><span class="line">        if(lcnt&amp;&amp;rcnt)&#123;</span><br><span class="line">            s=ls+to_string(pre[l1])+&#x27; &#x27;+rs;</span><br><span class="line">            cnt+=lcnt*rcnt;</span><br><span class="line">            if(cnt&gt;1) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++) cin&gt;&gt;pre[i];</span><br><span class="line">    for(int i=0;i&lt;n;i++) cin&gt;&gt;post[i];</span><br><span class="line">    string s;</span><br><span class="line">    int cnt=dfs(0,n-1,0,n-1,s);</span><br><span class="line">    if(cnt&gt;1) puts(&quot;No&quot;);</span><br><span class="line">    else puts(&quot;Yes&quot;);</span><br><span class="line">    s.pop_back();</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="02-先序-中序-唯一"><a href="#02-先序-中序-唯一" class="headerlink" title="02 先序+中序(唯一)"></a>02 先序+中序(唯一)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int pre[maxn],in[maxn];</span><br><span class="line">unordered_map&lt;int,int&gt; pos,l,r;</span><br><span class="line"></span><br><span class="line">int build(int pl,int pr,int il,int ir)&#123;</span><br><span class="line">    int root=pre[pl],k=pos[root];</span><br><span class="line">    if(k&gt;il) l[root]=build(pl+1,pl+k-il,il,k-1);</span><br><span class="line">    if(k&lt;ir) r[root]=build(pl+k-il+1,pr,k+1,ir);</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++) cin&gt;&gt;pre[i];</span><br><span class="line">    for(int i=0;i&lt;n;i++) cin&gt;&gt;in[i],pos[in[i]]=i;</span><br><span class="line">    int root=build(0,n-1,0,n-1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="03-后序-中序-唯一"><a href="#03-后序-中序-唯一" class="headerlink" title="03 后序+中序(唯一)"></a>03 后序+中序(唯一)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;int,int&gt; l,r,pos;</span><br><span class="line">int post[maxn],in[maxn];</span><br><span class="line"></span><br><span class="line">int build(int il,int ir,int pl,int pr)&#123;</span><br><span class="line">    int root=post[pr];</span><br><span class="line">    int k=pos[root];</span><br><span class="line">    if(k&gt;il) l[root]=build(il,k-1,pl,pl+k-1-il);</span><br><span class="line">    if(k&lt;ir) r[root]=build(k+1,ir,pl+k-1-il+1,pr-1);</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++) cin&gt;&gt;in[i],pos[in[i]]=i;</span><br><span class="line">    for(int i=0;i&lt;n;i++) cin&gt;&gt;post[i];</span><br><span class="line">    int root=build(0,n-1,0,n-1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="手动实现AVL树插入"><a href="#手动实现AVL树插入" class="headerlink" title="手动实现AVL树插入"></a>手动实现AVL树插入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=50;</span><br><span class="line"></span><br><span class="line">int l[maxn],r[maxn],e[maxn],h[maxn],idx;</span><br><span class="line"></span><br><span class="line">void update(int u)&#123;</span><br><span class="line">    h[u]=max(h[l[u]],h[r[u]])+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void L(int&amp; u)&#123;</span><br><span class="line">    int p=r[u];</span><br><span class="line">    r[u]=l[p],l[p]=u;</span><br><span class="line">    update(u),update(p);</span><br><span class="line">    u=p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void R(int&amp; u)&#123;</span><br><span class="line">    int p=l[u];</span><br><span class="line">    l[u]=r[p],r[p]=u;</span><br><span class="line">    update(u),update(p);</span><br><span class="line">    u=p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int get_balance(int u)&#123;</span><br><span class="line">    return h[l[u]]-h[r[u]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insert(int&amp; u,int x)&#123;</span><br><span class="line">    if(!u) u=++idx,e[u]=x;</span><br><span class="line">    else if(x&lt;e[u])&#123;</span><br><span class="line">        insert(l[u],x);</span><br><span class="line">        if(get_balance(u)==2)&#123;</span><br><span class="line">            if(get_balance(l[u])==1)</span><br><span class="line">                R(u);</span><br><span class="line">            else L(l[u]),R(u); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        insert(r[u],x);</span><br><span class="line">        if(get_balance(u)==-2)&#123;</span><br><span class="line">            if(get_balance(r[u])==-1)</span><br><span class="line">                L(u);</span><br><span class="line">            else R(r[u]),L(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    update(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,x,root=0;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        insert(root,x);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断红黑树"><a href="#判断红黑树" class="headerlink" title="判断红黑树"></a>判断红黑树</h3><p>数据结构中有一类平衡的二叉搜索树，称为红黑树。</p>
<p>它具有以下 5 个属性：</p>
<ul>
<li>节点是红色或黑色。</li>
<li>根节点是黑色。</li>
<li>所有叶子都是黑色。（叶子是 NULL节点）</li>
<li>每个红色节点的两个子节点都是黑色。</li>
<li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li>
</ul>
<p>现在，对于每个给定的二叉搜索树，请你判断它是否是合法的红黑树。</p>
<p>注意</p>
<p>给定的前序遍历序列可能不合法，即无法构建出合法二叉搜索树。</p>
<p>输入格式</p>
<p>第一行包含整数 K，表示共有 K 组测试数据。</p>
<p>每组测试数据，第一行包含整数 N，表示二叉搜索树的节点数量。</p>
<p>第二行给出了这个二叉搜索树的前序遍历。</p>
<p>注意，虽然所有节点的权值都为正，但是我们使用负号表示红色节点。</p>
<p>各节点权值互不相同。</p>
<p>输入样例与题目中三个图例相对应。</p>
<p>输出格式</p>
<p>对于每组数据，如果是合法红黑树则输出一行 <code>Yes</code>，否则输出一行 <code>No</code>。</p>
<p>数据范围</p>
<p>1≤K≤30<br>1≤N≤30</p>
<p>输入样例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">9</span><br><span class="line">7 -2 1 5 -4 -11 8 14 -15</span><br><span class="line">9</span><br><span class="line">11 -2 1 -7 5 -4 8 14 -15</span><br><span class="line">8</span><br><span class="line">10 -7 5 -6 8 15 -11 17</span><br></pre></td></tr></table></figure>
<p>输出样例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=50;</span><br><span class="line"></span><br><span class="line">int pre[maxn],in[maxn];</span><br><span class="line">bool ans;</span><br><span class="line">unordered_map&lt;int,int&gt; pos;</span><br><span class="line"></span><br><span class="line">int build(int il,int ir,int pl,int pr,int&amp; sum)&#123;</span><br><span class="line">    int root=pre[pl];</span><br><span class="line">    int k=pos[abs(root)];</span><br><span class="line">    if(k&lt;il||k&gt;ir)&#123;</span><br><span class="line">        ans=false;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int l=0,r=0,ls=0,rs=0;</span><br><span class="line">    if(k&gt;il) l=build(il,k-1,pl+1,pl+1+k-1-il,ls);</span><br><span class="line">    if(k&lt;ir) r=build(k+1,ir,pl+1+k-1-il+1,pr,rs);</span><br><span class="line">    if(ls!=rs) ans=false;</span><br><span class="line">    sum=ls;</span><br><span class="line">    if(root&lt;0)&#123;</span><br><span class="line">        if(l&lt;0||r&lt;0) ans=false;</span><br><span class="line">    &#125;</span><br><span class="line">    else sum++;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        int n,sum=0;</span><br><span class="line">        pos.clear();</span><br><span class="line">        ans=true;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        for(int i=0;i&lt;n;i++) cin&gt;&gt;pre[i],in[i]=abs(pre[i]);</span><br><span class="line">        sort(in,in+n);</span><br><span class="line">        for(int i=0;i&lt;n;i++) pos[in[i]]=i;</span><br><span class="line">        int root=build(0,n-1,0,n-1,sum);</span><br><span class="line">        if(root&lt;0) ans=false;</span><br><span class="line">        if(ans) puts(&quot;Yes&quot;);</span><br><span class="line">        else puts(&quot;No&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DFS判断一个先序遍历是否为堆"><a href="#DFS判断一个先序遍历是否为堆" class="headerlink" title="DFS判断一个先序遍历是否为堆"></a>DFS判断一个先序遍历是否为堆</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1010;</span><br><span class="line"></span><br><span class="line">int h[maxn],n,gt,lt;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line"></span><br><span class="line">void dfs(int u)&#123;</span><br><span class="line">    v.push_back(h[u]);</span><br><span class="line">    if(u*2&gt;n)&#123;</span><br><span class="line">        cout &lt;&lt; v[0];</span><br><span class="line">        for(int i=1;i&lt;v.size();i++)&#123;</span><br><span class="line">            cout &lt;&lt; &#x27; &#x27; &lt;&lt; v[i];</span><br><span class="line">            if(v[i]&lt;=v[i-1]) gt=1;</span><br><span class="line">            else lt=1;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    if(u*2+1&lt;=n) dfs(u*2+1);</span><br><span class="line">    if(u*2&lt;=n) dfs(u*2);</span><br><span class="line">    v.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;h[i];</span><br><span class="line">    dfs(1);</span><br><span class="line">    if(lt&amp;&amp;gt) cout &lt;&lt; &quot;Not Heap&quot; &lt;&lt; endl;</span><br><span class="line">    else if(lt) cout &lt;&lt; &quot;Min Heap&quot; &lt;&lt; endl;</span><br><span class="line">    else if(gt) cout &lt;&lt; &quot;Max Heap&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最低公共祖先"><a href="#最低公共祖先" class="headerlink" title="最低公共祖先"></a>最低公共祖先</h3><p>树中两个结点 U 和 V 的最低公共祖先（LCA）是指同时具有 U 和 V 作为后代的最深结点。</p>
<p>给定二叉树中的任何两个结点，请你找到它们的 LCA。</p>
<p>输入格式</p>
<p>第一行包含两个整数 M 和 N，分别表示询问结点对数以及二叉树中的结点数量。</p>
<p>接下来两行，每行包含 N 个不同的整数，分别表示二叉树的中序和前序遍历。</p>
<p>保证二叉树可由给定遍历序列唯一确定。</p>
<p>接下来 M 行，每行包含两个整数 U 和 V，表示一组询问。</p>
<p>所有结点权值均在 <strong>int</strong> 范围内。</p>
<p>输出格式</p>
<p>对于每对给定的 U 和 V，输出一行结果。</p>
<p>如果 U 和 V 的 LCA 是 A，且 A 不是 U 或 V，则输出 <code>LCA of U and V is A.</code>。</p>
<p>如果 U 和 V 的 LCA 是 A，且 A 是 U 或 V 中的一个，则输出 <code>X is an ancestor of Y.</code>，其中 X 表示 A，Y 表示另一个结点。</p>
<p>如果 U 或 V 没有在二叉树中找到，则输出 <code>ERROR: U is not found.</code> 或 <code>ERROR: V is not found.</code> 或 <code>ERROR: U and V are not found.</code>。</p>
<p>数据范围</p>
<p>1≤M≤1000<br>1≤N≤10000</p>
<p>输入样例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">6 8</span><br><span class="line">7 2 3 4 6 5 1 8</span><br><span class="line">5 3 7 2 6 4 8 1</span><br><span class="line">2 6</span><br><span class="line">8 1</span><br><span class="line">7 9</span><br><span class="line">12 -3</span><br><span class="line">0 8</span><br><span class="line">99 99</span><br></pre></td></tr></table></figure>
<p>输出样例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LCA of 2 and 6 is 3.</span><br><span class="line">8 is an ancestor of 1.</span><br><span class="line">ERROR: 9 is not found.</span><br><span class="line">ERROR: 12 and -3 are not found.</span><br><span class="line">ERROR: 0 is not found.</span><br><span class="line">ERROR: 99 and 99 are not found.</span><br></pre></td></tr></table></figure>
<p>代码</p>
<p>PAT不会要求用倍增的LCA算法，基本上只要朴素的往上爬的算法就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e4+10;</span><br><span class="line"></span><br><span class="line">int f[maxn],pre[maxn],in[maxn],s[maxn],d[maxn];</span><br><span class="line">unordered_map&lt;int,int&gt; pos;</span><br><span class="line"></span><br><span class="line">int build(int il,int ir,int pl,int pr,int x)&#123;</span><br><span class="line">    int root=pre[pl],k=root;</span><br><span class="line">    d[root]=x;</span><br><span class="line">    if(k&gt;il) f[build(il,k-1,pl+1,pl+1+k-1-il,x+1)]=root;</span><br><span class="line">    if(k&lt;ir) f[build(k+1,ir,pl+1+k-1-il+1,pr,x+1)]=root;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,a,b;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        pos[s[i]]=i;</span><br><span class="line">        in[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;pre[i];</span><br><span class="line">        pre[i]=pos[pre[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    build(0,n-1,0,n-1,0);</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        if(!pos.count(a)&amp;&amp;!pos.count(b)) printf(&quot;ERROR: %d and %d are not found.\n&quot;,a,b);</span><br><span class="line">        else if(pos.count(a)&amp;&amp;pos.count(b))&#123;</span><br><span class="line">            int x=pos[a],y=pos[b];</span><br><span class="line">            while(x!=y)&#123;</span><br><span class="line">                if(d[x]&gt;d[y]) x=f[x];</span><br><span class="line">                else y=f[y];</span><br><span class="line">            &#125;</span><br><span class="line">            if(x==pos[a]) printf(&quot;%d is an ancestor of %d.\n&quot;,a,b);</span><br><span class="line">            else if(x==pos[b]) printf(&quot;%d is an ancestor of %d.\n&quot;,b,a);</span><br><span class="line">            else printf(&quot;LCA of %d and %d is %d.\n&quot;,a,b,s[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(!pos.count(a)) printf(&quot;ERROR: %d is not found.\n&quot;,a);</span><br><span class="line">        else printf(&quot;ERROR: %d is not found.\n&quot;,b);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h4 id="01-朴素版本"><a href="#01-朴素版本" class="headerlink" title="01 朴素版本"></a>01 朴素版本</h4><p>一共有n个数，编号是1~n，最开始每个数各自在一个集合中。</p>
<p>现在要进行m个操作，操作共有两种：</p>
<ol>
<li>“M a b”，将编号为a和b的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</li>
<li>“Q a b”，询问编号为a和b的两个数是否在同一个集合中</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+10;</span><br><span class="line"></span><br><span class="line">int p[maxn];</span><br><span class="line"></span><br><span class="line">int find(int x)&#123;</span><br><span class="line">    return p[x]=x==p[x]?x:find(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,a,b;</span><br><span class="line">    char op[2];</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        scanf(&quot;%s%d%d&quot;,op,&amp;a,&amp;b);</span><br><span class="line">        if(op[0]==&#x27;M&#x27;) p[find(a)]=find(b);</span><br><span class="line">        else</span><br><span class="line">            find(a)==find(b)?puts(&quot;Yes&quot;):puts(&quot;No&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="02-合并时更新额外信息"><a href="#02-合并时更新额外信息" class="headerlink" title="02 合并时更新额外信息"></a>02 合并时更新额外信息</h4><p>其实就是写一个merge函数，更新一些题目中要求的信息，比如说下面就是更新并查集中结点个数的merge函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void init()&#123;</span><br><span class="line">    for(int i=0;i&lt;maxn;i++)</span><br><span class="line">        f[i]=i,cnt[i]=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void merge(int x,int y)&#123;</span><br><span class="line">    int fx=find(x),fy=find(y);</span><br><span class="line">    if(fx!=fy)&#123;</span><br><span class="line">        f[fx]=fy;</span><br><span class="line">        cnt[fy]+=cnt[fx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a><strong>图</strong></h2><h3 id="最短路径与扩展问题"><a href="#最短路径与扩展问题" class="headerlink" title="最短路径与扩展问题"></a>最短路径与扩展问题</h3><h4 id="01-朴素dijkstra"><a href="#01-朴素dijkstra" class="headerlink" title="01 朴素dijkstra"></a>01 朴素dijkstra</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=510,inf=0x3f3f3f3f;</span><br><span class="line"></span><br><span class="line">int g[maxn][maxn],vis[maxn],d[maxn],m,n;</span><br><span class="line"></span><br><span class="line">void dijkstra()&#123;</span><br><span class="line">    d[1]=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        int t=-1;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)</span><br><span class="line">            if(!vis[j]&amp;&amp;(t==-1||d[t]&gt;d[j]))</span><br><span class="line">                t=j;</span><br><span class="line">        vis[t]=1;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)</span><br><span class="line">            d[j]=min(d[j],d[t]+g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    memset(g,0x3f,sizeof g);</span><br><span class="line">    memset(d,0x3f,sizeof d);</span><br><span class="line">    int a,b,c;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        g[a][b]=min(g[a][b],c);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    if(d[n]==inf) puts(&quot;-1&quot;);</span><br><span class="line">    else printf(&quot;%d\n&quot;,d[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="02-堆优化版dijkstra"><a href="#02-堆优化版dijkstra" class="headerlink" title="02 堆优化版dijkstra"></a>02 堆优化版dijkstra</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=3e5+10,inf=0x3f3f3f3f;</span><br><span class="line">typedef pair&lt;int,int&gt; P;</span><br><span class="line"></span><br><span class="line">int h[maxn],e[maxn],ne[maxn],w[maxn],d[maxn],vis[maxn],idx,n,m;</span><br><span class="line">priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt;&gt; que;</span><br><span class="line"></span><br><span class="line">void add(int a,int b,int c)&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dijkstra()&#123;</span><br><span class="line">    d[1]=0;</span><br><span class="line">    que.push(&#123;0,1&#125;);</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        P p=que.top();que.pop();</span><br><span class="line">        int u=p.second;</span><br><span class="line">        if(vis[u]) continue;</span><br><span class="line">        vis[u]=1;</span><br><span class="line">        for(int i=h[u];i!=-1;i=ne[i])&#123;</span><br><span class="line">            int v=e[i];</span><br><span class="line">            if(d[v]&gt;d[u]+w[i])&#123;</span><br><span class="line">                d[v]=d[u]+w[i];</span><br><span class="line">                que.push(&#123;d[v],v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a,b,c;</span><br><span class="line">    memset(h,-1,sizeof h);</span><br><span class="line">    memset(d,0x3f,sizeof d);</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        add(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    if(d[n]==inf) puts(&quot;-1&quot;);</span><br><span class="line">    else printf(&quot;%d\n&quot;,d[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="03-对最短路选择的扩展"><a href="#03-对最短路选择的扩展" class="headerlink" title="03 对最短路选择的扩展"></a>03 对最短路选择的扩展</h4><p>在满足最短路的条件下继续追加条件，比如说下面的dijkstra代码就追加了两个数组cnt和sum，cnt用于统计最短路的数量，sum用于统计路径上累计的一个量(比如说路上遇到的人数啊、路上所需要的花费啊等等，就是题目会给的除了路径长度之外用于最短路选择的变量，这时候只需要在dijkstra松弛操作d[j]==d[t]+g[t][j]时对另一个量进行更新即可)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1010;</span><br><span class="line"></span><br><span class="line">int g[maxn][maxn],d[maxn],vis[maxn],w[maxn],cnt[maxn],sum[maxn],st,ed,n,m;</span><br><span class="line"></span><br><span class="line">void dijkstra()&#123;</span><br><span class="line">    d[st]=0,sum[st]=w[st],cnt[st]=1;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        int t=-1;</span><br><span class="line">        for(int j=0;j&lt;n;j++)</span><br><span class="line">            if(!vis[j]&amp;&amp;(t==-1||d[t]&gt;d[j]))</span><br><span class="line">                t=j;</span><br><span class="line">        vis[t]=1;</span><br><span class="line">        for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">            if(d[j]&gt;d[t]+g[t][j])&#123;</span><br><span class="line">                d[j]=d[t]+g[t][j];</span><br><span class="line">                cnt[j]=cnt[t];</span><br><span class="line">                sum[j]=sum[t]+w[j];</span><br><span class="line">            &#125;</span><br><span class="line">            else if(d[j]==d[t]+g[t][j])&#123;</span><br><span class="line">                cnt[j]+=cnt[t];</span><br><span class="line">                sum[j]=max(sum[j],sum[t]+w[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a,b,c;</span><br><span class="line">    memset(g,0x3f,sizeof g);</span><br><span class="line">    memset(d,0x3f,sizeof d);</span><br><span class="line">    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;st,&amp;ed);</span><br><span class="line">    for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;w[i]);</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        g[a][b]=g[b][a]=min(g[a][b],c);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    printf(&quot;%d %d\n&quot;,cnt[ed],sum[ed]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="04-对最短路信息的扩展"><a href="#04-对最短路信息的扩展" class="headerlink" title="04 对最短路信息的扩展"></a>04 对最短路信息的扩展</h4><p>比如下面这题是要求在选择最短路的前提下选择花费最小的一条，同时要求输出最短路的路径，这个也不是太难，只需要每次最短路松弛操作的时候把路径记录到pre数组即可，最后将pre倒着输出就是路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=510;</span><br><span class="line"></span><br><span class="line">int g[maxn][maxn],val[maxn][maxn],d[maxn],cost[maxn],vis[maxn],pre[maxn],n,m,st,ed;</span><br><span class="line"></span><br><span class="line">void dijkstra()&#123;</span><br><span class="line">    d[st]=0,cost[st]=0,pre[st]=-1;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        int t=-1;</span><br><span class="line">        for(int j=0;j&lt;n;j++)</span><br><span class="line">            if(!vis[j]&amp;&amp;(t==-1||d[t]&gt;d[j]))</span><br><span class="line">                t=j;</span><br><span class="line">        vis[t]=1;</span><br><span class="line">        for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">            if(d[j]&gt;d[t]+g[t][j])&#123;</span><br><span class="line">                d[j]=d[t]+g[t][j];</span><br><span class="line">                cost[j]=cost[t]+val[t][j];</span><br><span class="line">                pre[j]=t;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(d[j]==d[t]+g[t][j]&amp;&amp;cost[j]&gt;cost[t]+val[t][j])&#123;</span><br><span class="line">                cost[j]=cost[t]+val[t][j];</span><br><span class="line">                pre[j]=t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    memset(g,0x3f,sizeof g);</span><br><span class="line">    memset(val,0x3f,sizeof val);</span><br><span class="line">    memset(cost,0x3f,sizeof cost);</span><br><span class="line">    memset(d,0x3f,sizeof d);</span><br><span class="line">    int a,b,x,y;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;st&gt;&gt;ed;</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        g[a][b]=g[b][a]=min(g[a][b],x);</span><br><span class="line">        val[a][b]=val[b][a]=min(val[a][b],y);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">    for(int i=ed;i!=-1;i=pre[i]) ans.push_back(i);</span><br><span class="line">    for(int i=ans.size()-1;i&gt;=0;i--)&#123;</span><br><span class="line">        if(i!=ans.size()-1) cout &lt;&lt; &#x27; &#x27;;</span><br><span class="line">        cout &lt;&lt; ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt; &#x27; &#x27; &lt;&lt; d[ed] &lt;&lt; &#x27; &#x27; &lt;&lt; cost[ed] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断哈密顿回路"><a href="#判断哈密顿回路" class="headerlink" title="判断哈密顿回路"></a>判断哈密顿回路</h3><p>哈密顿回路的四个条件</p>
<ul>
<li>起点与终点相同</li>
<li>每一步都有边</li>
<li>所有点都被访问</li>
<li>总共访问n+1次点(起点访问两次)</li>
</ul>
<p>DFS时判断这四个条件即可</p>
<p>下面这题a数组就是题目给出的访问序列，判断是否是哈密顿回路</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=310;</span><br><span class="line"></span><br><span class="line">int g[maxn][maxn],a[maxn],vis[maxn],n,m,k;</span><br><span class="line"></span><br><span class="line">bool check(int cnt)&#123;</span><br><span class="line">    memset(vis,0,sizeof vis);</span><br><span class="line">    if(a[cnt-1]!=a[0]||cnt!=n+1) return false;</span><br><span class="line">    for(int i=0;i&lt;cnt-1;i++)&#123;</span><br><span class="line">        vis[a[i]]=1;</span><br><span class="line">        if(!g[a[i]][a[i+1]]) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[a[cnt-1]]=1;</span><br><span class="line">    for(int i=0;i&lt;cnt;i++)</span><br><span class="line">        if(!vis[a[i]]) return false;</span><br><span class="line">    return true;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int x,y,cnt;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        g[x][y]=g[y][x]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    while(k--)&#123;</span><br><span class="line">        cin&gt;&gt;cnt;</span><br><span class="line">        for(int i=0;i&lt;cnt;i++) cin&gt;&gt;a[i];</span><br><span class="line">        if(check(cnt)) puts(&quot;YES&quot;);</span><br><span class="line">        else puts(&quot;NO&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉路径"><a href="#欧拉路径" class="headerlink" title="欧拉路径"></a>欧拉路径</h3><p>在图论中，欧拉路径是图中的一条路径，该路径满足恰好访问每个边一次。</p>
<p>而欧拉回路是一条在同一顶点处开始和结束的欧拉路径。</p>
<p>它们最早由欧拉于 17361736 年解决著名的哥尼斯堡七桥问题时提出。</p>
<p>事实证明，如果一个连通图的所有顶点的度数都为偶数，那么这个连通图具有欧拉回路，且这个图被称为欧拉图。</p>
<p>如果一个连通图中有两个顶点的度数为奇数，其他顶点的度数为偶数，那么所有欧拉路径都从其中一个度数为奇数的顶点开始，并在另一个度数为奇数的顶点结束。</p>
<p>具有欧拉路径但不具有欧拉回路的图被称为半欧拉图。</p>
<p>现在，给定一个<strong>无向</strong>图，请你判断它是欧拉图、半欧拉图还是非欧拉图。</p>
<p>思路就是迭代判断度数，DFS或BFS判断图的联通性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=510;</span><br><span class="line"></span><br><span class="line">int g[maxn][maxn],d[maxn],vis[maxn],n,m;</span><br><span class="line"></span><br><span class="line">int dfs(int u)&#123;</span><br><span class="line">    vis[u]=1;</span><br><span class="line">    int res=1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        if(!vis[i]&amp;&amp;g[u][i])</span><br><span class="line">            res+=dfs(i);</span><br><span class="line">    return res;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        g[a][b]=g[b][a]=1;</span><br><span class="line">        d[a]++,d[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    int cnt=dfs(1);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(i!=1) cout &lt;&lt; &#x27; &#x27;;</span><br><span class="line">        cout &lt;&lt; d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    if(cnt==n)&#123;</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            if(d[i]&amp;1) sum++;</span><br><span class="line">        if(sum==0) puts(&quot;Eulerian&quot;);</span><br><span class="line">        else if(sum==2) puts(&quot;Semi-Eulerian&quot;);</span><br><span class="line">        else puts(&quot;Non-Eulerian&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else puts(&quot;Non-Eulerian&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="顶点覆盖"><a href="#顶点覆盖" class="headerlink" title="顶点覆盖"></a>顶点覆盖</h3><p>如果图中的一个顶点集合能够满足图中的每一条边都至少有一个端点在该集合内，那么这个顶点集合就是图的顶点覆盖。</p>
<p>现在给定一张图，以及若干个顶点集合，请你判断这些顶点集合是否是图的顶点覆盖。</p>
<p>存一个边集每次遍历边集判断即可，特别简单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e4+10;</span><br><span class="line"></span><br><span class="line">struct edge&#123;</span><br><span class="line">    int from,to;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line">int vis[maxn],n,m,k;</span><br><span class="line">unordered_set&lt;int&gt; s;</span><br><span class="line"></span><br><span class="line">bool check()&#123;</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">        if(!s.count(e[i].from)&amp;&amp;!s.count(e[i].to))</span><br><span class="line">            return false;</span><br><span class="line">    return true;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        e[i]=&#123;a,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    while(k--)&#123;</span><br><span class="line">        int cnt,x;</span><br><span class="line">        cin&gt;&gt;cnt;</span><br><span class="line">        s.clear();</span><br><span class="line">        while(cnt--)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            s.insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">        if(check()) puts(&quot;Yes&quot;);</span><br><span class="line">        else puts(&quot;No&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大团"><a href="#最大团" class="headerlink" title="最大团"></a>最大团</h3><p>在一个无向图中，如果一个顶点子集满足子集内的任意两个不同顶点之间都是相连的，那么这个顶点子集就被称为一个团。</p>
<p>如果一个团不能通过加入某个新的顶点来扩展成一个更大的团，那么该团就被称为最大团。</p>
<p>现在，你需要判断给定顶点子集能否构成一个最大团。</p>
<p>也是比较简单的图论题目了，因为PAT的数据很小所以直接在给出的集合内部两两之间判断是否有边即可，如果有两点之间没有边那么就不是团。在接下来判断外面的点是否与集合中每个点都有边，如果有的话说明当前的集合不是最大团</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=210;</span><br><span class="line"></span><br><span class="line">int g[maxn][maxn],n,m,k;</span><br><span class="line">unordered_set&lt;int&gt; s;</span><br><span class="line"></span><br><span class="line">int check(vector&lt;int&gt;&amp; v)&#123;</span><br><span class="line">    s.clear();</span><br><span class="line">    for(int i=0;i&lt;v.size();i++)</span><br><span class="line">        for(int j=i+1;j&lt;v.size();j++)</span><br><span class="line">            if(!g[v[i]][v[j]])&#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">    for(int i=0;i&lt;v.size();i++) s.insert(v[i]);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        if(!s.count(i))&#123;</span><br><span class="line">            int flag=1;</span><br><span class="line">            for(auto j:v)</span><br><span class="line">                if(i!=j&amp;&amp;!g[i][j])</span><br><span class="line">                    flag=0;</span><br><span class="line">            if(flag) return 1;        </span><br><span class="line">        &#125;</span><br><span class="line">    return 2;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        g[a][b]=g[b][a]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    while(k--)&#123;</span><br><span class="line">        int cnt,x;</span><br><span class="line">        cin&gt;&gt;cnt;</span><br><span class="line">        vector&lt;int&gt; v;</span><br><span class="line">        while(cnt--) cin&gt;&gt;x,v.push_back(x);</span><br><span class="line">        if(check(v)==2) puts(&quot;Yes&quot;);</span><br><span class="line">        else if(check(v)==1) puts(&quot;Not Maximal&quot;);</span><br><span class="line">        else puts(&quot;Not a Clique&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>给出一个图和一堆序列，问序列是不是拓扑排序，输出不是拓扑排序的序列的编号</p>
<p>因为已经给出了序列，只需要每次判断点是不是入度为0，如果是的话就将其所有的连接的点的入度-1，然后继续往下判断，如果能一直走到序列结束那就是拓扑排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=100010;</span><br><span class="line"></span><br><span class="line">int h[maxn],e[maxn],ne[maxn],d[maxn],back[maxn],n,m,k,idx;</span><br><span class="line"></span><br><span class="line">void add(int a,int b)&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++,d[b]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool check(vector&lt;int&gt;&amp; v)&#123;</span><br><span class="line">    for(auto x:v)&#123;</span><br><span class="line">        if(d[x]!=0) return false;</span><br><span class="line">        for(int i=h[x];i!=-1;i=ne[i])&#123;</span><br><span class="line">            int y=e[i];</span><br><span class="line">            d[y]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    memset(h,-1,sizeof h);</span><br><span class="line">    int a,b;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        add(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    memcpy(back,d,sizeof d);</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">    for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">        memcpy(d,back,sizeof back);</span><br><span class="line">        int x;</span><br><span class="line">        vector&lt;int&gt; v;</span><br><span class="line">        for(int i=0;i&lt;n;i++) cin&gt;&gt;x,v.push_back(x);</span><br><span class="line">        if(!check(v)) ans.push_back(i);  </span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;ans.size();i++)&#123;</span><br><span class="line">        if(i) cout &lt;&lt; &#x27; &#x27;;</span><br><span class="line">        cout &lt;&lt; ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="染色问题"><a href="#染色问题" class="headerlink" title="染色问题"></a>染色问题</h3><h4 id="01-二分图染色"><a href="#01-二分图染色" class="headerlink" title="01 二分图染色"></a>01 二分图染色</h4><p>给定一个n个点m条边的无向图，图中可能存在重边和自环。</p>
<p>请你判断这个图是否是二分图。</p>
<p>使用DFS，一边遍历一边染色(标记1或者2，使用3-c进行颜色转换)，如果没有冲突就说明染色成功了，那么就是二分图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool dfs(int u,int c)&#123;</span><br><span class="line">    color[u]=c;</span><br><span class="line">    for(int i=h[u];i!=-1;i=ne[i])&#123;</span><br><span class="line">        int v=e[i];</span><br><span class="line">        if(!color[v])&#123;</span><br><span class="line">            if(!dfs(v,3-c))</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(color[v]==c) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="02-判断染色方案"><a href="#02-判断染色方案" class="headerlink" title="02 判断染色方案"></a>02 判断染色方案</h4><p>一个合适的顶点着色是指用各种颜色标记图中各个顶点，使得每条边的两个端点的颜色都不相同。</p>
<p>如果一种合适的顶点着色方案使用了一共 kk 种不同的颜色，则称其为合适的 kk 着色（<code>k-coloring</code>)。</p>
<p>现在，你需要判断给定的着色方案是否是合适的 kk 着色方案。</p>
<p>只需要将二分图染色的代码修改一番，将染色的代码删掉即可，判断的原理是一样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool dfs(int u)&#123;</span><br><span class="line">    vis[u]=1;</span><br><span class="line">    for(int i=h[u];~i;i=ne[i])&#123;</span><br><span class="line">        int v=e[i];</span><br><span class="line">        if(color[u]==color[v]) return false;</span><br><span class="line">        if(!vis[v]&amp;&amp;!dfs(v)) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><h4 id="01-高精度加法"><a href="#01-高精度加法" class="headerlink" title="01 高精度加法"></a>01 高精度加法</h4><p>注意在vector中数字是倒着存的(方便遍历)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; add(vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)&#123;</span><br><span class="line">    int t=0;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">    for(int i=0;i&lt;a.size()||i&lt;b.size();i++)&#123;</span><br><span class="line">        if(i&lt;a.size()) t+=a[i];</span><br><span class="line">        if(i&lt;b.size()) t+=b[i];</span><br><span class="line">        ans.push_back(t%10);</span><br><span class="line">        t/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    if(t) ans.push_back(1);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string sa,sb;</span><br><span class="line">    vector&lt;int&gt; a,b;</span><br><span class="line">    cin&gt;&gt;sa&gt;&gt;sb;</span><br><span class="line">    for(int i=sa.length()-1;i&gt;=0;i--) a.push_back(sa[i]-&#x27;0&#x27;);</span><br><span class="line">    for(int i=sb.length()-1;i&gt;=0;i--) b.push_back(sb[i]-&#x27;0&#x27;);</span><br><span class="line">    vector&lt;int&gt; ans=add(a,b);</span><br><span class="line">    for(int i=ans.size()-1;i&gt;=0;i--)</span><br><span class="line">        cout &lt;&lt; ans[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="02-高精度减法"><a href="#02-高精度减法" class="headerlink" title="02 高精度减法"></a>02 高精度减法</h4><p>注意在vector中数字是倒着存的(方便遍历)，<strong>cmp函数用于比较大小(重要！！！)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool cmp(vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)&#123;</span><br><span class="line">    if(a.size()!=b.size()) return a.size()&gt;b.size();</span><br><span class="line">    for(int i=a.size()-1;i&gt;=0;i--)</span><br><span class="line">        if(a[i]!=b[i])</span><br><span class="line">            return a[i]&gt;b[i];</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; sub(vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)&#123;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">    int t=0;</span><br><span class="line">    for(int i=0;i&lt;a.size();i++)&#123;</span><br><span class="line">        t=a[i]-t;</span><br><span class="line">        if(i&lt;b.size()) t-=b[i];</span><br><span class="line">        ans.push_back((t+10)%10);</span><br><span class="line">        if(t&lt;0) t=1;</span><br><span class="line">        else t=0;</span><br><span class="line">    &#125;</span><br><span class="line">    while(ans.size()&gt;1&amp;&amp;ans.back()==0) ans.pop_back();</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string sa,sb;</span><br><span class="line">    vector&lt;int&gt; a,b,ans;</span><br><span class="line">    cin&gt;&gt;sa&gt;&gt;sb;</span><br><span class="line">    for(int i=sa.length()-1;i&gt;=0;i--) a.push_back(sa[i]-&#x27;0&#x27;);</span><br><span class="line">    for(int i=sb.length()-1;i&gt;=0;i--) b.push_back(sb[i]-&#x27;0&#x27;);</span><br><span class="line">    if(cmp(a,b))</span><br><span class="line">        ans=sub(a,b);</span><br><span class="line">    else</span><br><span class="line">        ans=sub(b,a),cout &lt;&lt; &#x27;-&#x27;;</span><br><span class="line">    for(int i=ans.size()-1;i&gt;=0;i--)</span><br><span class="line">        cout &lt;&lt; ans[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="03-高精度乘法"><a href="#03-高精度乘法" class="headerlink" title="03 高精度乘法"></a>03 高精度乘法</h4><p>注意在vector中数字是倒着存的(方便遍历)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; mul(vector&lt;int&gt;&amp; a,int b)&#123;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">    int t=0;</span><br><span class="line">    for(int i=0;i&lt;a.size();i++)&#123;</span><br><span class="line">        t+=a[i]*b;</span><br><span class="line">        ans.push_back(t%10);</span><br><span class="line">        t/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    while(t) ans.push_back(t%10),t/=10;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string s;</span><br><span class="line">    vector&lt;int&gt; a;</span><br><span class="line">    int b;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;b;</span><br><span class="line">    for(int i=s.length()-1;i&gt;=0;i--)</span><br><span class="line">        a.push_back(s[i]-&#x27;0&#x27;);</span><br><span class="line">    vector&lt;int&gt; ans=mul(a,b);</span><br><span class="line">    for(int i=ans.size()-1;i&gt;=0;i--)</span><br><span class="line">        cout &lt;&lt; ans[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="04-高精度除法"><a href="#04-高精度除法" class="headerlink" title="04 高精度除法*"></a>04 高精度除法*</h4><p>注意在vector中数字是倒着存的(方便遍历)，r是余数，使用引用传递</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; div(vector&lt;int&gt;&amp; a,int b,int &amp;r)&#123;</span><br><span class="line">    r=0;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">    for(int i=a.size()-1;i&gt;=0;i--)&#123;</span><br><span class="line">        r=r*10+a[i];</span><br><span class="line">        ans.push_back(r/b);</span><br><span class="line">        r%=b;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(ans.begin(),ans.end());</span><br><span class="line">    while(ans.size()&gt;1&amp;&amp;ans.back()==0)</span><br><span class="line">        ans.pop_back();</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string s;</span><br><span class="line">    vector&lt;int&gt; a;</span><br><span class="line">    int b,r;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;b;</span><br><span class="line">    for(int i=s.length()-1;i&gt;=0;i--)</span><br><span class="line">        a.push_back(s[i]-&#x27;0&#x27;);</span><br><span class="line">    vector&lt;int&gt; ans=div(a,b,r);</span><br><span class="line">    for(int i=ans.size()-1;i&gt;=0;i--)</span><br><span class="line">        cout &lt;&lt; ans[i];</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分解质因子"><a href="#分解质因子" class="headerlink" title="分解质因子"></a>分解质因子</h3><p>给定一个整数 N，找出它的所有质因子，并输出。</p>
<p>思路：能除就一直除，但是不要忘记输出最后剩下来的n</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void divide(int n)&#123;</span><br><span class="line">    for(int i=2;i&lt;=n/i;i++)&#123;</span><br><span class="line">        if(n%i==0)&#123;</span><br><span class="line">            int s=0;</span><br><span class="line">            while(n%i==0)&#123;</span><br><span class="line">                s++;</span><br><span class="line">                n/=i;</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%d %d\n&quot;,i,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //注意不要忘记这里</span><br><span class="line">    if(n&gt;1) printf(&quot;%d %d\n&quot;,n,1);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,x;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">        divide(x);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分数运算-和差积商"><a href="#分数运算-和差积商" class="headerlink" title="分数运算(和差积商)"></a>分数运算(和差积商)</h3><p>给定两个有理数，你的任务是实现基本算术，即计算它们的和，差，积和商。</p>
<p>输入格式</p>
<p>共一行，以 <code>a1/b1 a2/b2</code> 的形式给出两个有理数。</p>
<p>分子和分母都在 <strong>long int</strong> 范围内，如果存在负号，则只能出现在分子前面，分母保证为非零数字。</p>
<p>输出格式</p>
<p>分别在四行输出两个有理数的和，差，积和商。</p>
<p>每行的格式为 <code>number1 operator number2 = result</code>。</p>
<p>请注意，所有有理数都必须采用最简形式，<code>k a/b</code>，其中 kk 是整数部分，而 a/ba/b 是最简分数部分。</p>
<p>如果数字为负，则必须将其包含在一对括号中。</p>
<p>如果除法中除数为 00，则输出 <code>Inf</code> 作为结果。</p>
<p>确保所有输出整数都在 <strong>long int</strong> 范围内。</p>
<p>输入样例1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2/3 -4/2</span><br></pre></td></tr></table></figure>
<p>输出样例1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2/3 + (-2) = (-1 1/3)</span><br><span class="line">2/3 - (-2) = 2 2/3</span><br><span class="line">2/3 * (-2) = (-1 1/3)</span><br><span class="line">2/3 / (-2) = (-1/3)</span><br></pre></td></tr></table></figure>
<p>输入样例2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5/3 0/6</span><br></pre></td></tr></table></figure>
<p>输出样例2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 2/3 + 0 = 1 2/3</span><br><span class="line">1 2/3 - 0 = 1 2/3</span><br><span class="line">1 2/3 * 0 = 0</span><br><span class="line">1 2/3 / 0 = Inf</span><br></pre></td></tr></table></figure>
<p>代码</p>
<p>由于数据不是很变态，所以打印的时候约分就可以了，如果数据很大那么需要在计算过程中进行约分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">ll gcd(ll a,ll b)&#123;</span><br><span class="line">    return b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(ll a,ll b)&#123;</span><br><span class="line">    ll t=gcd(a,b);</span><br><span class="line">    a/=t,b/=t;</span><br><span class="line">    if(b&lt;0) a*=-1,b*=-1;</span><br><span class="line">    bool flag=false;</span><br><span class="line">    if(a&lt;0) flag=true;</span><br><span class="line">    if(flag) printf(&quot;(&quot;);</span><br><span class="line">    if(b==1) printf(&quot;%lld&quot;,a);</span><br><span class="line">    else if(abs(a)&gt;b) printf(&quot;%lld %lld/%lld&quot;,a/b,abs(a-b*(a/b)),b);</span><br><span class="line">    else printf(&quot;%lld/%lld&quot;,a,b);</span><br><span class="line">    if(flag) printf(&quot;)&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll add(ll a,ll b,ll c,ll d)&#123;</span><br><span class="line">    print(a,b),cout &lt;&lt; &quot; + &quot;,print(c,d),cout &lt;&lt; &quot; = &quot;;</span><br><span class="line">    a=a*d+b*c,b=b*d;</span><br><span class="line">    print(a,b);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll sub(ll a,ll b,ll c,ll d)&#123;</span><br><span class="line">    print(a,b),cout &lt;&lt; &quot; - &quot;,print(c,d),cout &lt;&lt; &quot; = &quot;;</span><br><span class="line">    a=a*d-b*c,b=b*d;</span><br><span class="line">    print(a,b);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll mul(ll a,ll b,ll c,ll d)&#123;</span><br><span class="line">    print(a,b),cout &lt;&lt; &quot; * &quot;,print(c,d),cout &lt;&lt; &quot; = &quot;;</span><br><span class="line">    a=a*c,b=b*d;</span><br><span class="line">    print(a,b);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll div(ll a,ll b,ll c,ll d)&#123;</span><br><span class="line">    print(a,b),cout &lt;&lt; &quot; / &quot;,print(c,d),cout &lt;&lt; &quot; = &quot;;</span><br><span class="line">    a*=d,b*=c;</span><br><span class="line">    if(b==0) puts(&quot;Inf&quot;);</span><br><span class="line">    else&#123;</span><br><span class="line">        print(a,b);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    ll a,b,c,d;</span><br><span class="line">    scanf(&quot;%lld/%lld %lld/%lld&quot;,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">    add(a,b,c,d);</span><br><span class="line">    sub(a,b,c,d);</span><br><span class="line">    mul(a,b,c,d);</span><br><span class="line">    div(a,b,c,d);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="素数筛"><a href="#素数筛" class="headerlink" title="素数筛"></a>素数筛</h3><h4 id="01-朴素筛法"><a href="#01-朴素筛法" class="headerlink" title="01 朴素筛法"></a>01 朴素筛法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e6+10;</span><br><span class="line"></span><br><span class="line">int flag[maxn];</span><br><span class="line">vector&lt;int&gt; prime;</span><br><span class="line"></span><br><span class="line">void get_primes(int n)&#123;</span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!flag[i])&#123;</span><br><span class="line">            prime.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=i+i;j&lt;=n;j+=i)</span><br><span class="line">            flag[j]=true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    get_primes(n);</span><br><span class="line">    printf(&quot;%d\n&quot;,prime.size());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="02-埃氏筛法"><a href="#02-埃氏筛法" class="headerlink" title="02 埃氏筛法"></a>02 埃氏筛法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e6+10;</span><br><span class="line"></span><br><span class="line">int flag[maxn];</span><br><span class="line">vector&lt;int&gt; prime;</span><br><span class="line"></span><br><span class="line">void get_primes(int n)&#123;</span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!flag[i])&#123;</span><br><span class="line">            prime.push_back(i);</span><br><span class="line">            for(int j=i+i;j&lt;=n;j+=i)</span><br><span class="line">                flag[j]=true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    get_primes(n);</span><br><span class="line">    printf(&quot;%d\n&quot;,prime.size());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="03-线性筛"><a href="#03-线性筛" class="headerlink" title="03 线性筛"></a>03 线性筛</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e6+10;</span><br><span class="line"></span><br><span class="line">int flag[maxn];</span><br><span class="line">vector&lt;int&gt; prime;</span><br><span class="line"></span><br><span class="line">void get_primes(int n)&#123;</span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!flag[i]) prime.push_back(i);</span><br><span class="line">        for(int j=0;prime[j]&lt;=n/i;j++)&#123;</span><br><span class="line">            flag[prime[j]*i]=true;</span><br><span class="line">            if(i%prime[j]==0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    get_primes(n);</span><br><span class="line">    printf(&quot;%d\n&quot;,prime.size());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int qmi(int a,int b,int p)&#123;</span><br><span class="line">    int ans=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1) ans=1ll*ans*a%p;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">        a=1ll*a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,a,b,p;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;p);</span><br><span class="line">        printf(&quot;%d\n&quot;,qmi(a,b,p));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a><strong>动态规划</strong></h2><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><p>二维</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1010;</span><br><span class="line"></span><br><span class="line">int v[maxn],w[maxn],dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;=m;j++)&#123;</span><br><span class="line">            dp[i][j]=dp[i-1][j];</span><br><span class="line">            if(j&gt;=v[i])</span><br><span class="line">                dp[i][j]=max(dp[i][j],dp[i-1][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>滚动数组优化一维</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1010;</span><br><span class="line"></span><br><span class="line">int v[maxn],w[maxn],dp[maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=m;j&gt;=v[i];j--)&#123;</span><br><span class="line">                dp[j]=max(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="02-硬币找零"><a href="#02-硬币找零" class="headerlink" title="02 硬币找零"></a>02 硬币找零</h4><p>(01背包应用)</p>
<p>伊娃喜欢从整个宇宙中收集硬币。</p>
<p>有一天，她去了一家宇宙购物中心购物，结账时可以使用各种硬币付款。</p>
<p>但是，有一个特殊的付款要求：每张帐单，她都必须<strong>准确</strong>的支付所消费金额。</p>
<p>给定她拥有的所有硬币的面额，请你帮她确定对于给定的金额，她能否找到一些硬币来支付。</p>
<p>输入格式</p>
<p>第一行包含两个整数 N 和 M，分别表示硬币数量以及需要支付的金额。</p>
<p>第二行包含 N 个整数，表示每个硬币的面额。</p>
<p>输出格式</p>
<p>共一行，按照面额升序的顺序，输出用来支付的所有硬币的面额。</p>
<p>如果支付方式不唯一，则输出最小的支付面额序列。</p>
<p>如果无解，则输出 <code>No Solution</code>。</p>
<p>对于两个序列 <code>&#123;A[1], A[2], ...&#125;</code> 和 <code>&#123;B[1], B[2], ...&#125;</code>，如果存在 k≥1k≥1 使得所有 i&lt;ki&lt;k，满足 A[i]=B[i]A[i]=B[i] 成立，并且 A[k]&lt;B[k]，则我们称序列 AA 小于序列 BB。</p>
<p>数据范围</p>
<p>1≤N≤10^4,<br>1≤M≤100,<br>硬币面值不超过 100100</p>
<p>输入样例1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 9</span><br><span class="line">5 9 8 7 2 3 4 1</span><br></pre></td></tr></table></figure>
<p>输出样例1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3 5</span><br></pre></td></tr></table></figure>
<p>输入样例2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 8</span><br><span class="line">7 2 4 3</span><br></pre></td></tr></table></figure>
<p>输出样例2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No Solution</span><br></pre></td></tr></table></figure>
<p>代码</p>
<p>为了保证最小的面额支付序列，需要将硬币面额从大到小进行dp，保证后面面额小的可以覆盖面额大的方案</p>
<p>输出路径的时候只需要从后往前沿着true的路径倒着回去即可，因为是bool数组所以只会存储一个支付方案</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1e4+10,M=110;</span><br><span class="line"></span><br><span class="line">bool f[N][M];</span><br><span class="line">int a[N];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    f[0][0]=true;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    sort(a+1,a+1+n,greater&lt;int&gt;());</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        for(int j=0;j&lt;=m;j++)&#123;</span><br><span class="line">            f[i][j]=f[i-1][j];</span><br><span class="line">            if(j&gt;=a[i]) f[i][j]|=f[i-1][j-a[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    if(!f[n][m]) puts(&quot;No Solution&quot;);</span><br><span class="line">    else&#123;</span><br><span class="line">        bool flag=true;</span><br><span class="line">        while(n)&#123;</span><br><span class="line">            if(m&gt;=a[n]&amp;&amp;f[n-1][m-a[n]])&#123;</span><br><span class="line">                if(flag) flag=false;</span><br><span class="line">                else cout &lt;&lt; &#x27; &#x27;;</span><br><span class="line">                cout &lt;&lt; a[n];</span><br><span class="line">                m-=a[n];</span><br><span class="line">            &#125;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="03-完全背包"><a href="#03-完全背包" class="headerlink" title="03 完全背包"></a>03 完全背包</h4><p>朴素版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1010;</span><br><span class="line"></span><br><span class="line">int dp[maxn][maxn],v[maxn],w[maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        for(int j=0;j&lt;=m;j++)</span><br><span class="line">            for(int k=0;k*v[i]&lt;=j;k++)</span><br><span class="line">                dp[i][j]=max(dp[i][j],dp[i-1][j-k*v[i]]+k*w[i]);</span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1010;</span><br><span class="line"></span><br><span class="line">int dp[maxn][maxn],v[maxn],w[maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;=m;j++)&#123;</span><br><span class="line">            dp[i][j]=dp[i-1][j];</span><br><span class="line">            if(j&gt;=v[i])</span><br><span class="line">                dp[i][j]=max(dp[i][j],dp[i][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>滚动数组终极优化版</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1010;</span><br><span class="line"></span><br><span class="line">int dp[maxn],v[maxn],w[maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        for(int j=v[i];j&lt;=m;j++)</span><br><span class="line">            dp[j]=max(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">    cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="04-整数分解"><a href="#04-整数分解" class="headerlink" title="04 整数分解"></a>04 整数分解</h4><p>(完全背包应用)</p>
<p>正整数 NN 的 K−P 分解，是将 N 写为 K 个正整数的 P 次幂的和。</p>
<p>请你编写一个程序，给定 N,K,P 的情况下，找到 N 的 K−P 分解。</p>
<p>输入格式</p>
<p>共一行，包含三个整数 N,K,P。</p>
<p>输出格式</p>
<p>如果存在 N 的 K−P 分解，则以如下格式输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">N = n[1]^P + ... n[K]^P</span><br></pre></td></tr></table></figure>
<p>其中，n[i]是第 i 个因子，所有因子必须按照不升序顺序输出。</p>
<p>注意，答案也许不唯一。</p>
<p>例如，169的 5−2 分解共有 99 种，如 122+42+22+22+12，112+62+22+22+22 等等。</p>
<p>你需要输出各因子之和最大的一种解法。</p>
<p>如果仍不能确定唯一解法，则选择因子序列更大的解法。</p>
<p>我们称序列 {a1,a2,…,aK} 大于序列 {b1,b2,…,bK}，当且仅当存在 1≤L≤K，满足当 ibL。</p>
<p>如果无解，则直接输出 <code>Impossible</code>。</p>
<p>数据范围</p>
<p>1≤K≤N≤400,<br>2≤P≤7</p>
<p>输入样例1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">169 5 2</span><br></pre></td></tr></table></figure>
<p>输出样例1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">169 = 6^2 + 6^2 + 6^2 + 6^2 + 5^2</span><br></pre></td></tr></table></figure>
<p>输入样例2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">169 167 3</span><br></pre></td></tr></table></figure>
<p>输出样例2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Impossible</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=410;</span><br><span class="line"></span><br><span class="line">int f[30][maxn][maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k,p,m;</span><br><span class="line">    memset(f,-0x3f,sizeof f);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;p;</span><br><span class="line">    f[0][0][0]=0;</span><br><span class="line">    for(m=1;;m++)&#123;</span><br><span class="line">        int val=pow(m,p);</span><br><span class="line">        if(val&gt;n) break;</span><br><span class="line">        for(int i=0;i&lt;=n;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;=k;j++)&#123;</span><br><span class="line">                f[m][i][j]=f[m-1][i][j];</span><br><span class="line">                if(j&amp;&amp;i&gt;=val) f[m][i][j]=max(f[m][i][j],f[m][i-val][j-1]+m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m--;</span><br><span class="line">    if(f[m][n][k]&lt;0) puts(&quot;Impossible&quot;);</span><br><span class="line">    else&#123;</span><br><span class="line">        bool flag=true;</span><br><span class="line">        printf(&quot;%d = &quot;,n);</span><br><span class="line">        while(m)&#123;</span><br><span class="line">            int val=pow(m,p);</span><br><span class="line">            while(f[m][n-val][k-1]+m&gt;=f[m-1][n][k])&#123;</span><br><span class="line">                if(!flag) cout &lt;&lt; &quot; + &quot;;</span><br><span class="line">                else flag=false;</span><br><span class="line">                printf(&quot;%d^%d&quot;,m,p);</span><br><span class="line">                n-=val,k--;</span><br><span class="line">            &#125;</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="05-多重背包"><a href="#05-多重背包" class="headerlink" title="05 多重背包*"></a>05 多重背包*</h4><p>PAT题目最多最多也只会涉及到01背包和完全背包了，多重背包不太可能，但是还是放一下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=110;</span><br><span class="line"></span><br><span class="line">int dp[maxn][maxn],v[maxn],w[maxn],s[maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i];</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        for(int j=0;j&lt;=m;j++)</span><br><span class="line">            for(int k=0;k&lt;=s[i]&amp;&amp;k*v[i]&lt;=j;k++)</span><br><span class="line">                dp[i][j]=max(dp[i][j],dp[i-1][j-k*v[i]]+k*w[i]);</span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大子序列和"><a href="#最大子序列和" class="headerlink" title="最大子序列和"></a>最大子序列和</h3><p>给定一个包含 KK 个整数的序列 {N1,N2,…,NK}。</p>
<p>连续子序列定义为 {Ni,Ni+1,…,Nj}，其中 1≤i≤j≤K。</p>
<p>最大子序列是指序列内各元素之和最大的连续子序列。</p>
<p>例如，给定序列 {−2,11,−4,13,−5,−2}，它的最大子序列为 {11,−4,13}，其各元素之和为 20。</p>
<p>现在你需要求出最大子序列的各元素之和，并且输出最大子序列的第一个元素和最后一个元素的值。</p>
<p>输入格式</p>
<p>第一行包含一个整数 K。</p>
<p>第二行包含 K 个整数。</p>
<p>输出格式</p>
<p>输出一行三个整数，分别表示最大子序列的各元素之和以及最大子序列的第一个元素和最后一个元素的值。</p>
<p>设最大子序列为 {Ni,Ni+1,…,Nj}，如果答案不唯一，则选择 i 更小的解，如果仍不唯一，则选择 j 更小的解。</p>
<p>注意，我们规定，如果所有 KK 个数字均为负数，则其最大和定义为 0，并且应该输出整个序列的第一个数字和最后一个数字。</p>
<p>数据范围</p>
<p>1≤K≤10000,序列内元素的绝对值不超过 10^5。</p>
<p>输入样例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">-10 1 2 3 4 -5 -23 3 7 -21</span><br></pre></td></tr></table></figure>
<p>输出样例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 1 4</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=10010;</span><br><span class="line"></span><br><span class="line">int a[maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,ans=-1,l,r;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    for(int i=0,f=-1,st;i&lt;n;i++)&#123;</span><br><span class="line">        if(f&lt;0) f=0,st=i;</span><br><span class="line">        f+=a[i];</span><br><span class="line">        if(f&gt;ans)&#123;</span><br><span class="line">            ans=f;</span><br><span class="line">            l=a[st],r=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans&lt;0) ans=0,l=a[0],r=a[n-1];</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; &#x27; &#x27; &lt;&lt; l &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><h4 id="01-最长公共子序列"><a href="#01-最长公共子序列" class="headerlink" title="01 最长公共子序列"></a>01 最长公共子序列</h4><p>dp[i][j]=max(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]+1)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1010;</span><br><span class="line"></span><br><span class="line">char a[maxn],b[maxn];</span><br><span class="line">int dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    scanf(&quot;%s%s&quot;,a+1,b+1);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">            dp[i][j]=max(dp[i-1][j],dp[i][j-1]);</span><br><span class="line">            if(a[i]==b[j]) dp[i][j]=dp[i-1][j-1]+1;</span><br><span class="line">        &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,dp[n][m]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="02-变种-一个字符匹配多个字符"><a href="#02-变种-一个字符匹配多个字符" class="headerlink" title="02 变种(一个字符匹配多个字符)"></a>02 变种(一个字符匹配多个字符)</h4><p>a数组中的字符可以匹配多次b数组中的字符，所以dp[i][j]=max(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]+1)要改成f[i][j]=max(f[i-1][j],f[i][j-1],f[i][j-1]+1)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=210,M=1e4+10;</span><br><span class="line"></span><br><span class="line">int a[N],b[M];</span><br><span class="line">int f[N][M];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=m;i++) cin&gt;&gt;a[i];</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    for(int i=1;i&lt;=k;i++) cin&gt;&gt;b[i];</span><br><span class="line">    for(int i=1;i&lt;=m;i++)</span><br><span class="line">        for(int j=1;j&lt;=k;j++)&#123;</span><br><span class="line">            if(a[i]==b[j]) f[i][j]=max(f[i][j],f[i][j-1]+1);</span><br><span class="line">            else f[i][j]=max(f[i-1][j],f[i][j-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[m][k] &lt;&lt; endl;    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="状态机模型"><a href="#状态机模型" class="headerlink" title="状态机模型"></a>状态机模型</h3><p>字符串 <code>APPAPT</code> 中共包含两个 <code>PAT</code> 作为子串。</p>
<p>第一个子串由第二，第四和第六个字符组成，第二个子串由第三，第四和第六个字符组成。</p>
<p>现在给定一个字符串，请你求出字符串中包含的 <code>PAT</code> 的数量。</p>
<p>输入格式</p>
<p>共一行，包含一个由大写字母 P,A,T 构成的字符串。</p>
<p>输出格式</p>
<p>输出字符串中包含的 <code>PAT</code> 的数量。</p>
<p>由于结果可能很大，请你输出对 1000000007 取模后的结果。</p>
<p>数据范围</p>
<p>给定字符串的长度不超过 10^5。</p>
<p>输入样例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPAPT</span><br></pre></td></tr></table></figure>
<p>输出样例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<p>代码</p>
<p>将初始状态设置为0，匹配P的状态设置为1，匹配P后又匹配了A的状态设置为2，匹配了P和A之后又匹配了T的状态设置为3</p>
<p>f[i][j]表示为只考虑给定字符串前i个字符且走到了状态j的所有路线的数量</p>
</div>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2022-02-26</span>
            
            
             
        
        </i>
    </div>
    <br>
    
    
        
            
    
            <div class="post-footer-pre-next">
                
                    <span>上一篇：<a href='/2022/2202202221/'>ArcGIS Pro 功能介绍</a></span>
                

                
                    <span class="post-footer-pre-next-last-span-right">下一篇：<a href="/2022/20220220/">USD简介和各在DCC软件中的应用</a>
                    </span>
                
            </div>
    
        
    

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2025 China 

            
                

            
        </span>
       
    
</div>



<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>🌊看过大海的人不会忘记海的广阔🌊</span>
            
                <span class="footer-last-span-right"><i>本站由<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo</a>驱动｜使用<a target="_blank" rel="noopener" href="https://github.com/HiNinoJay/hexo-theme-A4">Hexo-theme-A4</a>主题</i></span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery/lightgallery.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-thumbnail.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-fullscreen.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-autoplay.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-zoom.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-rotate.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-paper.umd.min.js"></script>




<script type="text/javascript">
     
    if (typeof lightGallery !== "undefined") {
        var options1 = {
            selector: '.gallery-item',
            plugins: [lgThumbnail, lgFullscreen, lgAutoplay, lgZoom, lgRotate, lgPager], // 启用插件
            thumbnail: true,          // 显示缩略图
            zoom: true,               // 启用缩放功
            rotate: true,             // 启用旋转功能能
            autoplay: true,        // 启用自动播放功能
            fullScreen: true,      // 启用全屏功能
            pager: false, //页码,
            zoomFromOrigin: true,   // 从原始位置缩放
            actualSize: true,       // 启用查看实际大小的功能
            enableZoomAfter: 300,    // 延迟缩放，确保图片加载完成后可缩放
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1); // 修复选择器
    }
    
</script>


    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> 

                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>
<script src="/js/emojiHandler.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    wrapEmojis('.paper');
  });
</script>